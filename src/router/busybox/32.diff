diff -urpN busybox-1.31.1/Config.in busybox-1.32.0/Config.in
--- busybox-1.31.1/Config.in	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/Config.in	2020-06-26 22:47:44.000000000 +0400
@@ -156,12 +156,13 @@ config FEATURE_PIDFILE
 config PID_FILE_PATH
 	string "Directory for pidfiles"
 	default "/var/run"
-	depends on FEATURE_PIDFILE
+	depends on FEATURE_PIDFILE || FEATURE_CROND_SPECIAL_TIMES
 	help
 	This is the default path where pidfiles are created.  Applets which
 	allow you to set the pidfile path on the command line will override
 	this value.  The option has no effect on applets that require you to
-	specify a pidfile path.
+	specify a pidfile path.  When crond has the 'Support special times'
+	option enabled, the 'crond.reboot' file is also stored here.
 
 config BUSYBOX
 	bool "Include busybox applet"
@@ -661,6 +662,19 @@ config WERROR
 
 	Most people should answer N.
 
+config WARN_SIMPLE_MSG
+	bool "Warn about single parameter bb_xx_msg calls"
+	default n
+	help
+	This will cause warnings to be shown for any instances of
+	bb_error_msg(), bb_error_msg_and_die(), bb_perror_msg(),
+	bb_perror_msg_and_die(), bb_herror_msg() or bb_herror_msg_and_die()
+	being called with a single parameter. In these cases the equivalent
+	bb_simple_xx_msg function should be used instead.
+	Note that use of STRERROR_FMT may give false positives.
+
+	If you aren't developing busybox, say N here.
+
 choice
 	prompt "Additional debugging library"
 	default NO_DEBUG_LIB
diff -urpN busybox-1.31.1/Makefile busybox-1.32.0/Makefile
--- busybox-1.31.1/Makefile	2019-10-25 12:44:52.000000000 +0400
+++ busybox-1.32.0/Makefile	2020-06-26 23:22:49.000000000 +0400
@@ -1,6 +1,6 @@
 VERSION = 1
-PATCHLEVEL = 31
-SUBLEVEL = 1
+PATCHLEVEL = 32
+SUBLEVEL = 0
 EXTRAVERSION =
 NAME = Unnamed
 
diff -urpN busybox-1.31.1/Makefile.flags busybox-1.32.0/Makefile.flags
--- busybox-1.31.1/Makefile.flags	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/Makefile.flags	2020-06-26 22:47:44.000000000 +0400
@@ -15,7 +15,7 @@ CPPFLAGS += \
 	-include include/autoconf.h \
 	-D_GNU_SOURCE -DNDEBUG \
 	$(if $(CONFIG_LFS),-D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64) \
-	-D"BB_VER=KBUILD_STR($(BB_VER))"
+	-DBB_VER=$(squote)$(quote)$(BB_VER)$(quote)$(squote)
 
 CFLAGS += $(call cc-option,-Wall,)
 CFLAGS += $(call cc-option,-Wshadow,)
@@ -47,12 +47,28 @@ endif
 # gcc 3.x emits bogus "old style proto" warning on find.c:alloc_action()
 CFLAGS += $(call cc-ifversion, -ge, 0400, -Wold-style-definition)
 
-CFLAGS += $(call cc-option,-fno-builtin-strlen -finline-limit=0 -fomit-frame-pointer -ffunction-sections -fdata-sections,)
+ifneq ($(CC),clang)
+# "clang-9: warning: optimization flag '-finline-limit=0' is not supported
+CFLAGS += $(call cc-option,-finline-limit=0,)
+endif
+
+CFLAGS += $(call cc-option,-fno-builtin-strlen -fomit-frame-pointer -ffunction-sections -fdata-sections,)
 # -fno-guess-branch-probability: prohibit pseudo-random guessing
 # of branch probabilities (hopefully makes bloatcheck more stable):
 CFLAGS += $(call cc-option,-fno-guess-branch-probability,)
-CFLAGS += $(call cc-option,-funsigned-char -static-libgcc,)
-CFLAGS += $(call cc-option,-falign-functions=1 -falign-jumps=1 -falign-labels=1 -falign-loops=1,)
+CFLAGS += $(call cc-option,-funsigned-char,)
+
+ifneq ($(CC),clang)
+# "clang-9: warning: argument unused during compilation: '-static-libgcc'"
+CFLAGS += $(call cc-option,-static-libgcc,)
+endif
+
+CFLAGS += $(call cc-option,-falign-functions=1,)
+ifneq ($(CC),clang)
+# "clang-9: warning: optimization flag '-falign-jumps=1' is not supported" (and same for other two)
+CFLAGS += $(call cc-option,-falign-jumps=1 -falign-labels=1 -falign-loops=1,)
+endif
+
 # Defeat .eh_frame bloat (gcc 4.6.3 x86-32 defconfig: 20% smaller busybox binary):
 CFLAGS += $(call cc-option,-fno-unwind-tables,)
 CFLAGS += $(call cc-option,-fno-asynchronous-unwind-tables,)
@@ -60,6 +76,11 @@ CFLAGS += $(call cc-option,-fno-asynchro
 # (try disabling this and comparing assembly, it's instructive)
 CFLAGS += $(call cc-option,-fno-builtin-printf,)
 
+# clang-9 does not like "str" + N and "if (CONFIG_ITEM && cond)" constructs
+ifeq ($(CC),clang)
+CFLAGS += $(call cc-option,-Wno-string-plus-int -Wno-constant-logical-operand)
+endif
+
 # FIXME: These warnings are at least partially to be concerned about and should
 # be fixed..
 #CFLAGS += $(call cc-option,-Wconversion,)
@@ -129,10 +150,12 @@ endif
 # fall back to using a temp file:
 CRYPT_AVAILABLE := $(shell echo 'int main(void){return 0;}' >crypttest.c; $(CC) $(CFLAGS) -lcrypt -o /dev/null crypttest.c >/dev/null 2>&1 && echo "y"; rm crypttest.c)
 ifeq ($(CRYPT_AVAILABLE),y)
-LDLIBS += m crypt
+LDLIBS += m rt crypt
 else
-LDLIBS += m
+LDLIBS += m rt
 endif
+# libm may be needed for dc, awk, ntpd
+# librt may be needed for clock_gettime()
 
 # libpam may use libpthread, libdl and/or libaudit.
 # On some platforms that requires an explicit -lpthread, -ldl, -laudit.
diff -urpN busybox-1.31.1/applets_sh/mim busybox-1.32.0/applets_sh/mim
--- busybox-1.31.1/applets_sh/mim	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/applets_sh/mim	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,39 @@
+#!/bin/sh
+MIMFILE="Mimfile"
+if [ $# -ge 2 ] && [ "$1" = "-f" ]
+then
+	MIMFILE="$2"
+	shift 2
+fi
+exec <"$MIMFILE" || exit 1
+{
+	INCASE=false
+	while read -r REPLY
+	do
+		case $REPLY in
+		*:)
+			if ! $INCASE
+			then
+				printf '[ $# -eq 0 ] && set -- "%s"
+TARGET="$1"
+shift
+case "$TARGET" in
+' "${REPLY%:}"
+			else
+				printf ';;\n'
+			fi
+			printf '%s)\n' "${REPLY%:}"
+			INCASE=true
+			;;
+		"") ;;
+		*) printf '%s\n' "${REPLY##[ 	]}";;
+		esac
+	done
+	$INCASE && printf ';;\n'
+	printf '*)
+echo "Unknown command $TARGET"
+exit 1
+;;
+esac
+'
+} | sh -s "$@"
diff -urpN busybox-1.31.1/archival/bbunzip.c busybox-1.32.0/archival/bbunzip.c
--- busybox-1.31.1/archival/bbunzip.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/bbunzip.c	2020-06-26 22:47:44.000000000 +0400
@@ -114,7 +114,7 @@ int FAST_FUNC bbunpack(char **argv,
 
 		/* Check that the input is sane */
 		if (!(option_mask32 & BBUNPK_OPT_FORCE) && isatty(STDIN_FILENO)) {
-			bb_error_msg_and_die("compressed data not read from terminal, "
+			bb_simple_error_msg_and_die("compressed data not read from terminal, "
 					"use -f to force it");
 		}
 
@@ -386,7 +386,7 @@ int gunzip_main(int argc UNUSED_PARAM, c
 	 * Normally, "zcat" is just "gunzip -c".
 	 * But if seamless magic is enabled, then we are much more clever.
 	 */
-	if (ENABLE_ZCAT && (!ENABLE_GUNZIP || applet_name[1] == 'c'))
+	if (ENABLE_ZCAT && applet_name[1] == 'c')
 		option_mask32 |= BBUNPK_OPT_STDOUT | BBUNPK_SEAMLESS_MAGIC;
 
 	return bbunpack(argv, unpack_gz_stream, make_new_name_gunzip, /*unused:*/ NULL);
@@ -536,6 +536,7 @@ int unlzma_main(int argc UNUSED_PARAM, c
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
 //usage:     "\n	-k	Keep input files"
+//usage:     "\n	-t	Test file integrity"
 //usage:
 //usage:#define xz_trivial_usage
 //usage:       "-d [-cfk] [FILE]..."
@@ -545,6 +546,7 @@ int unlzma_main(int argc UNUSED_PARAM, c
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
 //usage:     "\n	-k	Keep input files"
+//usage:     "\n	-t	Test file integrity"
 //usage:
 //usage:#define xzcat_trivial_usage
 //usage:       "[FILE]..."
diff -urpN busybox-1.31.1/archival/bzip2.c busybox-1.32.0/archival/bzip2.c
--- busybox-1.31.1/archival/bzip2.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/bzip2.c	2020-06-26 22:47:44.000000000 +0400
@@ -145,7 +145,7 @@ IF_DESKTOP(long long) int bz_write(bz_st
 			if (n2 != n) {
 				if (n2 >= 0)
 					errno = 0; /* prevent bogus error message */
-				bb_perror_msg(n2 >= 0 ? "short write" : bb_msg_write_error);
+				bb_simple_perror_msg(n2 >= 0 ? "short write" : bb_msg_write_error);
 				return -1;
 			}
 		}
@@ -187,7 +187,7 @@ IF_DESKTOP(long long) int FAST_FUNC comp
 	while (1) {
 		count = full_read(STDIN_FILENO, rbuf, IOBUF_SIZE);
 		if (count < 0) {
-			bb_perror_msg(bb_msg_read_error);
+			bb_simple_perror_msg(bb_msg_read_error);
 			total = -1;
 			break;
 		}
diff -urpN busybox-1.31.1/archival/cpio.c busybox-1.32.0/archival/cpio.c
--- busybox-1.31.1/archival/cpio.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/cpio.c	2020-06-26 22:47:44.000000000 +0400
@@ -516,6 +516,7 @@ int cpio_main(int argc UNUSED_PARAM, cha
 	if (archive_handle->cpio__blocks != (off_t)-1
 	 && !(opt & OPT_QUIET)
 	) {
+		fflush_all();
 		fprintf(stderr, "%"OFF_FMT"u blocks\n", archive_handle->cpio__blocks);
 	}
 
diff -urpN busybox-1.31.1/archival/dpkg.c busybox-1.32.0/archival/dpkg.c
--- busybox-1.31.1/archival/dpkg.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/dpkg.c	2020-06-26 22:47:44.000000000 +0400
@@ -487,7 +487,7 @@ static void add_split_dependencies(commo
 					} else if (strncmp(version, ">=", offset_ch) == 0) {
 						edge->operator = VER_MORE_EQUAL;
 					} else {
-						bb_error_msg_and_die("illegal operator");
+						bb_simple_error_msg_and_die("illegal operator");
 					}
 				}
 				/* skip to start of version numbers */
@@ -730,7 +730,7 @@ static void set_status(const unsigned st
 			status = new_value_num;
 			break;
 		default:
-			bb_error_msg_and_die("DEBUG ONLY: this shouldnt happen");
+			bb_simple_error_msg_and_die("DEBUG ONLY: this shouldnt happen");
 	}
 
 	new_status = xasprintf("%s %s %s", name_hashtable[want], name_hashtable[flag], name_hashtable[status]);
@@ -944,10 +944,10 @@ static void write_status_file(deb_file_t
 	/* Create a separate backfile to dpkg */
 	if (rename("/var/lib/dpkg/status", "/var/lib/dpkg/status.udeb.bak") == -1) {
 		if (errno != ENOENT)
-			bb_error_msg_and_die("can't create backup status file");
+			bb_simple_error_msg_and_die("can't create backup status file");
 		/* Its ok if renaming the status file fails because status
 		 * file doesn't exist, maybe we are starting from scratch */
-		bb_error_msg("no status file found, creating new one");
+		bb_simple_error_msg("no status file found, creating new one");
 	}
 
 	xrename("/var/lib/dpkg/status.udeb", "/var/lib/dpkg/status");
@@ -1816,7 +1816,7 @@ int dpkg_main(int argc UNUSED_PARAM, cha
 			init_archive_deb_control(archive_handle);
 			deb_file[deb_count]->control_file = deb_extract_control_file_to_buffer(archive_handle, control_list);
 			if (deb_file[deb_count]->control_file == NULL) {
-				bb_error_msg_and_die("can't extract control file");
+				bb_simple_error_msg_and_die("can't extract control file");
 			}
 			deb_file[deb_count]->filename = xstrdup(argv[0]);
 			package_num = fill_package_struct(deb_file[deb_count]->control_file);
@@ -1879,13 +1879,13 @@ int dpkg_main(int argc UNUSED_PARAM, cha
 		argv++;
 	}
 	if (!deb_count)
-		bb_error_msg_and_die("no package files specified");
+		bb_simple_error_msg_and_die("no package files specified");
 	deb_file[deb_count] = NULL;
 
 	/* Check that the deb file arguments are installable */
 	if (!(opt & OPT_force_ignore_depends)) {
 		if (!check_deps(deb_file, 0 /*, deb_count*/)) {
-			bb_error_msg_and_die("dependency check failed");
+			bb_simple_error_msg_and_die("dependency check failed");
 		}
 	}
 
diff -urpN busybox-1.31.1/archival/gzip.c busybox-1.32.0/archival/gzip.c
--- busybox-1.31.1/archival/gzip.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/gzip.c	2020-06-26 22:47:44.000000000 +0400
@@ -52,7 +52,7 @@ aa:      85.1% -- replaced with aa.gz
 //config:	help
 //config:	Enable support for compression levels 4-9. The default level
 //config:	is 6. If levels 1-3 are specified, 4 is used.
-//config:	If this option is not selected, -N options are ignored and -9
+//config:	If this option is not selected, -N options are ignored and -6
 //config:	is used.
 //config:
 //config:config FEATURE_GZIP_DECOMPRESS
@@ -99,7 +99,7 @@ aa:      85.1% -- replaced with aa.gz
 /* Diagnostic functions */
 #ifdef DEBUG
 static int verbose;
-#  define Assert(cond,msg) { if (!(cond)) bb_error_msg(msg); }
+#  define Assert(cond,msg) { if (!(cond)) bb_simple_error_msg(msg); }
 #  define Trace(x) fprintf x
 #  define Tracev(x) {if (verbose) fprintf x; }
 #  define Tracevv(x) {if (verbose > 1) fprintf x; }
@@ -259,12 +259,13 @@ enum {
 
 #if !ENABLE_FEATURE_GZIP_LEVELS
 
-	max_chain_length = 4096,
+	comp_level_minus4 = 6 - 4,
+	max_chain_length = 128,
 /* To speed up deflation, hash chains are never searched beyond this length.
  * A higher limit improves compression ratio but degrades the speed.
  */
 
-	max_lazy_match = 258,
+	max_lazy_match = 16,
 /* Attempt to find a better match only when the current match is strictly
  * smaller than this value. This mechanism is used only for compression
  * levels >= 4.
@@ -276,7 +277,7 @@ enum {
  * max_insert_length is used only for compression levels <= 3.
  */
 
-	good_match = 32,
+	good_match = 8,
 /* Use a faster search when the previous match is longer than this */
 
 /* Values for max_lazy_match, good_match and max_chain_length, depending on
@@ -285,7 +286,7 @@ enum {
  * found for specific files.
  */
 
-	nice_match = 258,	/* Stop searching when current match exceeds this */
+	nice_match = 128,	/* Stop searching when current match exceeds this */
 /* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
  * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
  * meaning.
@@ -334,14 +335,16 @@ struct globals {
 #define head (G1.prev + WSIZE) /* hash head (see deflate.c) */
 
 #if ENABLE_FEATURE_GZIP_LEVELS
+	unsigned comp_level_minus4;	/* can be a byte */
 	unsigned max_chain_length;
 	unsigned max_lazy_match;
 	unsigned good_match;
 	unsigned nice_match;
-#define max_chain_length (G1.max_chain_length)
-#define max_lazy_match   (G1.max_lazy_match)
-#define good_match	 (G1.good_match)
-#define nice_match	 (G1.nice_match)
+#define comp_level_minus4 (G1.comp_level_minus4)
+#define max_chain_length  (G1.max_chain_length)
+#define max_lazy_match    (G1.max_lazy_match)
+#define good_match        (G1.good_match)
+#define nice_match        (G1.nice_match)
 #endif
 
 /* =========================================================================== */
@@ -504,7 +507,7 @@ static ALWAYS_INLINE void flush_outbuf_i
  * pointer, then initialize the crc shift register contents instead.
  * Return the current crc in either case.
  */
-static void updcrc(uch * s, unsigned n)
+static void updcrc(uch *s, unsigned n)
 {
 	G1.crc = crc32_block_endian0(G1.crc, s, n, global_crc32_table /*G1.crc_32_tab*/);
 }
@@ -607,7 +610,7 @@ static void bi_windup(void)
  * Copy a stored block to the zip file, storing first the length and its
  * one's complement if requested.
  */
-static void copy_block(char *buf, unsigned len, int header)
+static void copy_block(const char *buf, unsigned len, int header)
 {
 	bi_windup();		/* align on byte boundary */
 
@@ -787,7 +790,7 @@ static void check_match(IPos start, IPos
 	/* check that the match is indeed a match */
 	if (memcmp(G1.window + match, G1.window + start, length) != 0) {
 		bb_error_msg(" start %d, match %d, length %d", start, match, length);
-		bb_error_msg("invalid match");
+		bb_simple_error_msg("invalid match");
 	}
 	if (verbose > 1) {
 		bb_error_msg("\\[%d,%d]", start - match, length);
@@ -1007,7 +1010,8 @@ struct globals2 {
 	tree_desc d_desc;
 	tree_desc bl_desc;
 
-	ush bl_count[MAX_BITS + 1];
+	/* was "ush", but "unsigned" results in smaller code */
+	unsigned bl_count[MAX_BITS + 1];
 
 /* The lengths of the bit length codes are sent in order of decreasing
  * probability, to avoid transmitting the lengths for unused bit length codes.
@@ -1118,7 +1122,7 @@ static void init_block(void)
 	(tree[n].Freq < tree[m].Freq \
 	|| (tree[n].Freq == tree[m].Freq && G2.depth[n] <= G2.depth[m]))
 
-static void pqdownheap(ct_data * tree, int k)
+static void pqdownheap(const ct_data *tree, int k)
 {
 	int v = G2.heap[k];
 	int j = k << 1;		/* left son of k */
@@ -1152,22 +1156,15 @@ static void pqdownheap(ct_data * tree, i
  *     The length opt_len is updated; static_len is also updated if stree is
  *     not null.
  */
-static void gen_bitlen(tree_desc * desc)
+static void gen_bitlen(const tree_desc *desc)
 {
-	ct_data *tree = desc->dyn_tree;
-	const uint8_t *extra = desc->extra_bits;
-	int base = desc->extra_base;
-	int max_code = desc->max_code;
-	int max_length = desc->max_length;
-	ct_data *stree = desc->static_tree;
-	int h;				/* heap index */
-	int n, m;			/* iterate over the tree elements */
-	int bits;			/* bit length */
-	int xbits;			/* extra bits */
-	ush f;				/* frequency */
-	int overflow = 0;	/* number of elements with bit length too large */
+#define tree desc->dyn_tree
+	int h;          /* heap index */
+	int n, m;       /* iterate over the tree elements */
+	int bits;       /* bit length */
+	int overflow;   /* number of elements with bit length too large */
 
-	for (bits = 0; bits <= MAX_BITS; bits++)
+	for (bits = 0; bits < ARRAY_SIZE(G2.bl_count); bits++)
 		G2.bl_count[bits] = 0;
 
 	/* In a first pass, compute the optimal bit lengths (which may
@@ -1175,28 +1172,32 @@ static void gen_bitlen(tree_desc * desc)
 	 */
 	tree[G2.heap[G2.heap_max]].Len = 0;	/* root of the heap */
 
+	overflow = 0;
 	for (h = G2.heap_max + 1; h < HEAP_SIZE; h++) {
+		ulg f;          /* frequency */
+		int xbits;      /* extra bits */
+
 		n = G2.heap[h];
 		bits = tree[tree[n].Dad].Len + 1;
-		if (bits > max_length) {
-			bits = max_length;
+		if (bits > desc->max_length) {
+			bits = desc->max_length;
 			overflow++;
 		}
 		tree[n].Len = (ush) bits;
 		/* We overwrite tree[n].Dad which is no longer needed */
 
-		if (n > max_code)
+		if (n > desc->max_code)
 			continue;	/* not a leaf node */
 
 		G2.bl_count[bits]++;
 		xbits = 0;
-		if (n >= base)
-			xbits = extra[n - base];
+		if (n >= desc->extra_base)
+			xbits = desc->extra_bits[n - desc->extra_base];
 		f = tree[n].Freq;
-		G2.opt_len += (ulg) f *(bits + xbits);
+		G2.opt_len += f * (bits + xbits);
 
-		if (stree)
-			G2.static_len += (ulg) f * (stree[n].Len + xbits);
+		if (desc->static_tree)
+			G2.static_len += f * (desc->static_tree[n].Len + xbits);
 	}
 	if (overflow == 0)
 		return;
@@ -1206,14 +1207,14 @@ static void gen_bitlen(tree_desc * desc)
 
 	/* Find the first bit length which could increase: */
 	do {
-		bits = max_length - 1;
+		bits = desc->max_length - 1;
 		while (G2.bl_count[bits] == 0)
 			bits--;
 		G2.bl_count[bits]--;	/* move one leaf down the tree */
 		G2.bl_count[bits + 1] += 2;	/* move one overflow item as its brother */
-		G2.bl_count[max_length]--;
+		G2.bl_count[desc->max_length]--;
 		/* The brother of the overflow item also moves one step up,
-		 * but this does not affect bl_count[max_length]
+		 * but this does not affect bl_count[desc->max_length]
 		 */
 		overflow -= 2;
 	} while (overflow > 0);
@@ -1223,11 +1224,11 @@ static void gen_bitlen(tree_desc * desc)
 	 * lengths instead of fixing only the wrong ones. This idea is taken
 	 * from 'ar' written by Haruhiko Okumura.)
 	 */
-	for (bits = max_length; bits != 0; bits--) {
+	for (bits = desc->max_length; bits != 0; bits--) {
 		n = G2.bl_count[bits];
 		while (n != 0) {
 			m = G2.heap[--h];
-			if (m > max_code)
+			if (m > desc->max_code)
 				continue;
 			if (tree[m].Len != (unsigned) bits) {
 				Trace((stderr, "code %d bits %d->%d\n", m, tree[m].Len, bits));
@@ -1237,6 +1238,7 @@ static void gen_bitlen(tree_desc * desc)
 			n--;
 		}
 	}
+#undef tree
 }
 
 /* ===========================================================================
@@ -1247,12 +1249,13 @@ static void gen_bitlen(tree_desc * desc)
  * OUT assertion: the field code is set for all tree elements of non
  *     zero code length.
  */
-static void gen_codes(ct_data * tree, int max_code)
+static void gen_codes(ct_data *tree, int max_code)
 {
-	ush next_code[MAX_BITS + 1];	/* next code value for each bit length */
-	ush code = 0;		/* running code value */
-	int bits;			/* bit index */
-	int n;				/* code index */
+	/* next_code[] and code used to be "ush", but "unsigned" results in smaller code */
+	unsigned next_code[MAX_BITS + 1]; /* next code value for each bit length */
+	unsigned code = 0;      /* running code value */
+	int bits;               /* bit index */
+	int n;                  /* code index */
 
 	/* The distribution counts are first used to generate the code values
 	 * without bit reversal.
@@ -1304,7 +1307,7 @@ do { \
 	pqdownheap(tree, SMALLEST); \
 } while (0)
 
-static void build_tree(tree_desc * desc)
+static void build_tree(tree_desc *desc)
 {
 	ct_data *tree = desc->dyn_tree;
 	ct_data *stree = desc->static_tree;
@@ -1382,10 +1385,10 @@ static void build_tree(tree_desc * desc)
 	/* At this point, the fields freq and dad are set. We can now
 	 * generate the bit lengths.
 	 */
-	gen_bitlen((tree_desc *) desc);
+	gen_bitlen(desc);
 
 	/* The field len is now set, we can generate the bit codes */
-	gen_codes((ct_data *) tree, max_code);
+	gen_codes(tree, max_code);
 }
 
 /* ===========================================================================
@@ -1394,7 +1397,7 @@ static void build_tree(tree_desc * desc)
  * counts. (The contribution of the bit length codes will be added later
  * during the construction of bl_tree.)
  */
-static void scan_tree(ct_data * tree, int max_code)
+static void scan_tree(ct_data *tree, int max_code)
 {
 	int n;				/* iterates over all tree elements */
 	int prevlen = -1;	/* last emitted length */
@@ -1446,7 +1449,7 @@ static void scan_tree(ct_data * tree, in
  * Send a literal or distance tree in compressed form, using the codes in
  * bl_tree.
  */
-static void send_tree(ct_data * tree, int max_code)
+static void send_tree(const ct_data *tree, int max_code)
 {
 	int n;				/* iterates over all tree elements */
 	int prevlen = -1;	/* last emitted length */
@@ -1622,7 +1625,7 @@ static int ct_tally(int dist, int lc)
 /* ===========================================================================
  * Send the block data compressed using the given Huffman trees
  */
-static void compress_block(ct_data * ltree, ct_data * dtree)
+static void compress_block(const ct_data *ltree, const ct_data *dtree)
 {
 	unsigned dist;          /* distance of matched string */
 	int lc;                 /* match length or unmatched char (if dist == 0) */
@@ -1672,7 +1675,7 @@ static void compress_block(ct_data * ltr
  * trees or store, and output the encoded block to the zip file. This function
  * returns the total compressed length for the file so far.
  */
-static void flush_block(char *buf, ulg stored_len, int eof)
+static void flush_block(const char *buf, ulg stored_len, int eof)
 {
 	ulg opt_lenb, static_lenb;      /* opt_len and static_len in bytes */
 	int max_blindex;                /* index of last bit length code of non zero freq */
@@ -1919,7 +1922,7 @@ static void bi_init(void)
 /* ===========================================================================
  * Initialize the "longest match" routines for a new file
  */
-static void lm_init(unsigned *flags16p)
+static void lm_init(void)
 {
 	unsigned j;
 
@@ -1927,8 +1930,6 @@ static void lm_init(unsigned *flags16p)
 	memset(head, 0, HASH_SIZE * sizeof(*head));
 	/* prev will be initialized on the fly */
 
-	/* speed options for the general purpose bit flag */
-	*flags16p |= 2;	/* FAST 4, SLOW 2 */
 	/* ??? reduce max_chain_length for binary files */
 
 	//G1.strstart = 0; // globals are zeroed in pack_gzip()
@@ -2076,10 +2077,16 @@ static void zip(void)
 
 	bi_init();
 	ct_init();
-	deflate_flags = 0;  /* pkzip -es, -en or -ex equivalent */
-	lm_init(&deflate_flags);
+	lm_init();
 
-	put_16bit(deflate_flags | 0x300); /* extra flags. OS id = 3 (Unix) */
+	deflate_flags = 0x300; /* extra flags. OS id = 3 (Unix) */
+#if ENABLE_FEATURE_GZIP_LEVELS
+	/* Note that comp_level < 4 do not exist in this version of gzip */
+	if (comp_level_minus4 == 9 - 4) {
+		deflate_flags |= 0x02; /* SLOW flag */
+	}
+#endif
+	put_16bit(deflate_flags);
 
 	/* The above 32-bit misaligns outbuf (10 bytes are stored), flush it */
 	flush_outbuf_if_32bit_optimized();
@@ -2222,8 +2229,11 @@ int gzip_main(int argc UNUSED_PARAM, cha
 #if ENABLE_FEATURE_GZIP_LEVELS
 	opt >>= (BBUNPK_OPTSTRLEN IF_FEATURE_GZIP_DECOMPRESS(+ 2) + 1); /* drop cfkvq[dt]n bits */
 	if (opt == 0)
-		opt = 1 << 6; /* default: 6 */
+		opt = 1 << 5; /* default: 6 */
 	opt = ffs(opt >> 4); /* Maps -1..-4 to [0], -5 to [1] ... -9 to [5] */
+
+	comp_level_minus4 = opt;
+
 	max_chain_length = 1 << gzip_level_config[opt].chain_shift;
 	good_match	 = gzip_level_config[opt].good;
 	max_lazy_match	 = gzip_level_config[opt].lazy2 * 2;
diff -urpN busybox-1.31.1/archival/libarchive/data_extract_all.c busybox-1.32.0/archival/libarchive/data_extract_all.c
--- busybox-1.31.1/archival/libarchive/data_extract_all.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/libarchive/data_extract_all.c	2020-06-26 22:47:44.000000000 +0400
@@ -103,7 +103,7 @@ void FAST_FUNC data_extract_all(archive_
 		struct stat existing_sb;
 		if (lstat(dst_name, &existing_sb) == -1) {
 			if (errno != ENOENT) {
-				bb_perror_msg_and_die("can't stat old file");
+				bb_simple_perror_msg_and_die("can't stat old file");
 			}
 		}
 		else if (existing_sb.st_mtime >= file_header->mtime) {
@@ -207,7 +207,7 @@ void FAST_FUNC data_extract_all(archive_
 		}
 		break;
 	default:
-		bb_error_msg_and_die("unrecognized file type");
+		bb_simple_error_msg_and_die("unrecognized file type");
 	}
 
 	if (!S_ISLNK(file_header->mode)) {
diff -urpN busybox-1.31.1/archival/libarchive/decompress_bunzip2.c busybox-1.32.0/archival/libarchive/decompress_bunzip2.c
--- busybox-1.31.1/archival/libarchive/decompress_bunzip2.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/libarchive/decompress_bunzip2.c	2020-06-26 22:47:44.000000000 +0400
@@ -817,7 +817,7 @@ unpack_bz2_stream(transformer_state_t *x
 			break;
 		}
 		if (bd->headerCRC != bd->totalCRC) {
-			bb_error_msg("CRC error");
+			bb_simple_error_msg("CRC error");
 			break;
 		}
 
diff -urpN busybox-1.31.1/archival/libarchive/decompress_gunzip.c busybox-1.32.0/archival/libarchive/decompress_gunzip.c
--- busybox-1.31.1/archival/libarchive/decompress_gunzip.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/libarchive/decompress_gunzip.c	2020-06-26 22:47:44.000000000 +0400
@@ -39,7 +39,8 @@ typedef struct huft_t {
 	unsigned char e;	/* number of extra bits or operation */
 	unsigned char b;	/* number of bits in this code or subcode */
 	union {
-		unsigned short n;	/* literal, length base, or distance base */
+		unsigned n;	/* literal, length base, or distance base */
+		/* ^^^^^ was "unsigned short", but that results in larger code */
 		struct huft_t *t;	/* pointer to next level of table */
 	} v;
 } huft_t;
@@ -184,29 +185,26 @@ static const uint16_t mask_bits[] ALIGN2
 	0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
 };
 
-/* Copy lengths for literal codes 257..285 */
-static const uint16_t cplens[] ALIGN2 = {
-	3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
-	67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
+/* Put lengths/offsets and extra bits in a struct of arrays
+ * to make calls to huft_build() have one fewer parameter.
+ */
+struct cp_ext {
+	uint16_t cp[31];
+	uint8_t ext[31];
 };
-
+/* Copy lengths and extra bits for literal codes 257..285 */
 /* note: see note #13 above about the 258 in this list. */
-/* Extra bits for literal codes 257..285 */
-static const uint8_t cplext[] ALIGN1 = {
-	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
-	5, 5, 5, 0, 99, 99
-}; /* 99 == invalid */
-
-/* Copy offsets for distance codes 0..29 */
-static const uint16_t cpdist[] ALIGN2 = {
-	1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,
-	769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577
+static const struct cp_ext lit = {
+	/*257 258 259 260 261 262 263 264 265 266 267 268 269 270 271  272  273  274  275  276   277   278   279   280   281   282   283    284    285 */
+	/*0   1   2   3   4   5   6   7   8   9   10  11  12  13   14   15   16   17   18   19    20    21    22    23    24    25    26     27     28     29  30 */
+	{ 3,  4,  5,  6,  7,  8,  9,  10, 11, 13, 15, 17, 19, 23,  27,  31,  35,  43,  51,  59,   67,   83,   99,  115,  131,  163,  195,   227,   258,     0, 0  },
+	{ 0,  0,  0,  0,  0,  0,  0,   0,  1,  1,  1,  1,  2,  2,   2,   2,   3,   3,   3,   3,    4,    4,    4,    4,    5,    5,    5,     5,     0,    99, 99 } /* 99 == invalid */
 };
-
-/* Extra bits for distance codes */
-static const uint8_t cpdext[] ALIGN1 = {
-	0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
-	11, 11, 12, 12, 13, 13
+/* Copy offsets and extra bits for distance codes 0..29 */
+static const struct cp_ext dist = {
+	/*0   1   2   3   4   5   6   7   8   9   10  11  12  13   14   15   16   17   18   19    20    21    22    23    24    25    26     27     28     29 */
+	{ 1,  2,  3,  4,  5,  7,  9,  13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 },
+	{ 0,  0,  0,  0,  1,  1,  2,   2,  3,  3,  4,  4,  5,  5,   6,   6,   7,   7,   8,   8,    9,    9,   10,   10,   11,   11,   12,    12,    13,    13 }
 };
 
 /* Tables for deflate from PKZIP's appnote.txt. */
@@ -277,22 +275,25 @@ static unsigned fill_bitbuffer(STATE_PAR
 
 
 /* Given a list of code lengths and a maximum table size, make a set of
- * tables to decode that set of codes.  Return zero on success, one if
- * the given code set is incomplete (the tables are still built in this
- * case), two if the input is invalid (an oversubscribed set of lengths)
- * - in this case stores NULL in *t.
+ * tables to decode that set of codes.
  *
  * b:	code lengths in bits (all assumed <= BMAX)
  * n:	number of codes (assumed <= N_MAX)
  * s:	number of simple-valued codes (0..s-1)
- * d:	list of base values for non-simple codes
- * e:	list of extra bits for non-simple codes
- * t:	result: starting table
+ * cp_ext->cp,ext: list of base values/extra bits for non-simple codes
  * m:	maximum lookup bits, returns actual
+ * result: starting table
+ *
+ * On error, returns a value with lowest-bit set on error.
+ * It can be just the value of 0x1,
+ * or a valid pointer to a Huffman table, ORed with 0x1 if incompete table
+ * is given: "fixed inflate" decoder feeds us such data.
  */
-static int huft_build(const unsigned *b, const unsigned n,
-			const unsigned s, const unsigned short *d,
-			const unsigned char *e, huft_t **t, unsigned *m)
+#define BAD_HUFT(p) ((uintptr_t)(p) & 1)
+#define ERR_RET     ((huft_t*)(uintptr_t)1)
+static huft_t* huft_build(const unsigned *b, const unsigned n,
+			const unsigned s, const struct cp_ext *cp_ext,
+			unsigned *m)
 {
 	unsigned a;             /* counter for codes of length k */
 	unsigned c[BMAX + 1];   /* bit length count table */
@@ -314,12 +315,12 @@ static int huft_build(const unsigned *b,
 	unsigned *xp;           /* pointer into x */
 	int y;                  /* number of dummy codes added */
 	unsigned z;             /* number of entries in current table */
+	huft_t *result;
+	huft_t **t;
 
 	/* Length of EOB code, if any */
 	eob_len = n > 256 ? b[256] : BMAX;
 
-	*t = NULL;
-
 	/* Generate counts for each bit length */
 	memset(c, 0, sizeof(c));
 	p = b;
@@ -335,9 +336,8 @@ static int huft_build(const unsigned *b,
 		q[1].b = 1;
 		q[2].e = 99;    /* invalid code marker */
 		q[2].b = 1;
-		*t = q + 1;
 		*m = 1;
-		return 0;
+		return q + 1;
 	}
 
 	/* Find minimum and maximum length, bound *m by those */
@@ -353,11 +353,11 @@ static int huft_build(const unsigned *b,
 	for (y = 1 << j; j < i; j++, y <<= 1) {
 		y -= c[j];
 		if (y < 0)
-			return 2; /* bad input: more codes than bits */
+			return ERR_RET; /* bad input: more codes than bits */
 	}
 	y -= c[i];
 	if (y < 0)
-		return 2;
+		return ERR_RET;
 	c[i] += y;
 
 	/* Generate starting offsets into the value table for each length */
@@ -384,6 +384,8 @@ static int huft_build(const unsigned *b,
 	} while (++i < n);
 
 	/* Generate the Huffman codes and for each, make the table entries */
+	result = ERR_RET;
+	t = &result;
 	x[0] = i = 0;   /* first Huffman code is zero */
 	p = v;          /* grab values in bit order */
 	htl = -1;       /* no tables yet--level -1 */
@@ -449,8 +451,8 @@ static int huft_build(const unsigned *b,
 				r.e = (unsigned char) (*p < 256 ? 16 : 15);	/* 256 is EOB code */
 				r.v.n = (unsigned short) (*p++); /* simple code is just the value */
 			} else {
-				r.e = (unsigned char) e[*p - s]; /* non-simple--look up in lists */
-				r.v.n = d[*p++ - s];
+				r.e = (unsigned char) cp_ext->ext[*p - s]; /* non-simple--look up in lists */
+				r.v.n = cp_ext->cp[*p++ - s];
 			}
 
 			/* fill code-like entries with r */
@@ -475,8 +477,11 @@ static int huft_build(const unsigned *b,
 	/* return actual size of base table */
 	*m = ws[1];
 
-	/* Return 1 if we were given an incomplete table */
-	return y != 0 && g != 1;
+	if (y != 0 && g != 1) /* we were given an incomplete table */
+		/* return "result" ORed with 1 */
+		return (void*)((uintptr_t)result | 1);
+
+	return result;
 }
 
 
@@ -777,14 +782,17 @@ static int inflate_block(STATE_PARAM sma
 		for (; i < 288; i++) /* make a complete, but wrong code set */
 			ll[i] = 8;
 		bl = 7;
-		huft_build(ll, 288, 257, cplens, cplext, &inflate_codes_tl, &bl);
-		/* huft_build() never return nonzero - we use known data */
+		inflate_codes_tl = huft_build(ll, 288, 257, &lit, &bl);
+		/* ^^^ never returns error here - we use known data */
 
 		/* set up distance table */
 		for (i = 0; i < 30; i++) /* make an incomplete code set */
 			ll[i] = 5;
 		bd = 5;
-		huft_build(ll, 30, 0, cpdist, cpdext, &inflate_codes_td, &bd);
+		inflate_codes_td = huft_build(ll, 30, 0, &dist, &bd);
+		/* ^^^ does return error here! (lsb bit is set) - we gave it incomplete code set */
+		/* clearing error bit: */
+		inflate_codes_td = (void*)((uintptr_t)inflate_codes_td & ~(uintptr_t)1);
 
 		/* set up data for inflate_codes() */
 		inflate_codes_setup(PASS_STATE bl, bd);
@@ -850,9 +858,9 @@ static int inflate_block(STATE_PARAM sma
 
 		/* build decoding table for trees - single level, 7 bit lookup */
 		bl = 7;
-		i = huft_build(ll, 19, 19, NULL, NULL, &inflate_codes_tl, &bl);
-		if (i != 0) {
-			abort_unzip(PASS_STATE_ONLY); //return i;	/* incomplete code set */
+		inflate_codes_tl = huft_build(ll, 19, 19, NULL, &bl);
+		if (BAD_HUFT(inflate_codes_tl)) {
+			abort_unzip(PASS_STATE_ONLY);	/* incomplete code set */
 		}
 
 		/* read in literal and distance code lengths */
@@ -915,14 +923,13 @@ static int inflate_block(STATE_PARAM sma
 
 		/* build the decoding tables for literal/length and distance codes */
 		bl = lbits;
-
-		i = huft_build(ll, nl, 257, cplens, cplext, &inflate_codes_tl, &bl);
-		if (i != 0) {
+		inflate_codes_tl = huft_build(ll, nl, 257, &lit, &bl);
+		if (BAD_HUFT(inflate_codes_tl)) {
 			abort_unzip(PASS_STATE_ONLY);
 		}
 		bd = dbits;
-		i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &inflate_codes_td, &bd);
-		if (i != 0) {
+		inflate_codes_td = huft_build(ll + nl, nd, 0, &dist, &bd);
+		if (BAD_HUFT(inflate_codes_td)) {
 			abort_unzip(PASS_STATE_ONLY);
 		}
 
@@ -1012,7 +1019,7 @@ inflate_unzip_internal(STATE_PARAM trans
 	error_msg = "corrupted data";
 	if (setjmp(error_jmp)) {
 		/* Error from deep inside zip machinery */
-		bb_error_msg(error_msg);
+		bb_simple_error_msg(error_msg);
 		n = -1;
 		goto ret;
 	}
@@ -1085,7 +1092,7 @@ static int top_up(STATE_PARAM unsigned n
 		bytebuffer_offset = 0;
 		bytebuffer_size = full_read(gunzip_src_fd, &bytebuffer[count], bytebuffer_max - count);
 		if ((int)bytebuffer_size < 0) {
-			bb_error_msg(bb_msg_read_error);
+			bb_simple_error_msg(bb_msg_read_error);
 			return 0;
 		}
 		bytebuffer_size += count;
@@ -1211,7 +1218,7 @@ unpack_gz_stream(transformer_state_t *xs
 
 		if (full_read(xstate->src_fd, &magic2, 2) != 2) {
  bad_magic:
-			bb_error_msg("invalid magic");
+			bb_simple_error_msg("invalid magic");
 			return -1;
 		}
 		if (magic2 == COMPRESS_MAGIC) {
@@ -1233,7 +1240,7 @@ unpack_gz_stream(transformer_state_t *xs
 
  again:
 	if (!check_header_gzip(PASS_STATE xstate)) {
-		bb_error_msg("corrupted data");
+		bb_simple_error_msg("corrupted data");
 		total = -1;
 		goto ret;
 	}
@@ -1246,7 +1253,7 @@ unpack_gz_stream(transformer_state_t *xs
 	total += n;
 
 	if (!top_up(PASS_STATE 8)) {
-		bb_error_msg("corrupted data");
+		bb_simple_error_msg("corrupted data");
 		total = -1;
 		goto ret;
 	}
@@ -1254,7 +1261,7 @@ unpack_gz_stream(transformer_state_t *xs
 	/* Validate decompression - crc */
 	v32 = buffer_read_le_u32(PASS_STATE_ONLY);
 	if ((~gunzip_crc) != v32) {
-		bb_error_msg("crc error");
+		bb_simple_error_msg("crc error");
 		total = -1;
 		goto ret;
 	}
@@ -1262,7 +1269,7 @@ unpack_gz_stream(transformer_state_t *xs
 	/* Validate decompression - size */
 	v32 = buffer_read_le_u32(PASS_STATE_ONLY);
 	if ((uint32_t)gunzip_bytes_out != v32) {
-		bb_error_msg("incorrect length");
+		bb_simple_error_msg("incorrect length");
 		total = -1;
 	}
 
diff -urpN busybox-1.31.1/archival/libarchive/decompress_uncompress.c busybox-1.32.0/archival/libarchive/decompress_uncompress.c
--- busybox-1.31.1/archival/libarchive/decompress_uncompress.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/libarchive/decompress_uncompress.c	2020-06-26 22:47:44.000000000 +0400
@@ -113,7 +113,7 @@ unpack_Z_stream(transformer_state_t *xst
 	/* xread isn't good here, we have to return - caller may want
 	 * to do some cleanup (e.g. delete incomplete unpacked file etc) */
 	if (full_read(xstate->src_fd, inbuf, 1) != 1) {
-		bb_error_msg("short read");
+		bb_simple_error_msg("short read");
 		goto err;
 	}
 
@@ -166,7 +166,7 @@ unpack_Z_stream(transformer_state_t *xst
 		if (insize < (int) (IBUFSIZ + 64) - IBUFSIZ) {
 			rsize = safe_read(xstate->src_fd, inbuf + insize, IBUFSIZ);
 			if (rsize < 0)
-				bb_error_msg_and_die(bb_msg_read_error);
+				bb_simple_error_msg_and_die(bb_msg_read_error);
 			insize += rsize;
 		}
 
@@ -200,7 +200,7 @@ unpack_Z_stream(transformer_state_t *xst
 
 			if (oldcode == -1) {
 				if (code >= 256)
-					bb_error_msg_and_die("corrupted data"); /* %ld", code); */
+					bb_simple_error_msg_and_die("corrupted data"); /* %ld", code); */
 				oldcode = code;
 				finchar = (int) oldcode;
 				outbuf[outpos++] = (unsigned char) finchar;
@@ -236,7 +236,7 @@ unpack_Z_stream(transformer_state_t *xst
 						insize, posbits, p[-1], p[0], p[1], p[2], p[3],
 						(posbits & 07));
 */
-					bb_error_msg("corrupted data");
+					bb_simple_error_msg("corrupted data");
 					goto err;
 				}
 
@@ -247,7 +247,7 @@ unpack_Z_stream(transformer_state_t *xst
 			/* Generate output characters in reverse order */
 			while (code >= 256) {
 				if (stackp <= &htabof(0))
-					bb_error_msg_and_die("corrupted data");
+					bb_simple_error_msg_and_die("corrupted data");
 				*--stackp = tab_suffixof(code);
 				code = tab_prefixof(code);
 			}
diff -urpN busybox-1.31.1/archival/libarchive/decompress_unlzma.c busybox-1.32.0/archival/libarchive/decompress_unlzma.c
--- busybox-1.31.1/archival/libarchive/decompress_unlzma.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/libarchive/decompress_unlzma.c	2020-06-26 22:47:44.000000000 +0400
@@ -59,7 +59,7 @@ static void rc_read(rc_t *rc)
 //TODO: return -1 instead
 //This will make unlzma delete broken unpacked file on unpack errors
 	if (buffer_size <= 0)
-		bb_error_msg_and_die("unexpected EOF");
+		bb_simple_error_msg_and_die("unexpected EOF");
 	rc->buffer_end = RC_BUFFER + buffer_size;
 	rc->ptr = RC_BUFFER;
 }
@@ -234,7 +234,7 @@ unpack_lzma_stream(transformer_state_t *
 	if (full_read(xstate->src_fd, &header, sizeof(header)) != sizeof(header)
 	 || header.pos >= (9 * 5 * 5)
 	) {
-		bb_error_msg("bad lzma header");
+		bb_simple_error_msg("bad lzma header");
 		return -1;
 	}
 
@@ -513,7 +513,7 @@ unpack_lzma_stream(transformer_state_t *
 			 * potentially more detailed information).
 			 * Do not fail silently.
 			 */
-			bb_error_msg("corrupted data");
+			bb_simple_error_msg("corrupted data");
 			total_written = -1; /* failure */
 		}
 		rc_free(rc);
diff -urpN busybox-1.31.1/archival/libarchive/decompress_unxz.c busybox-1.32.0/archival/libarchive/decompress_unxz.c
--- busybox-1.31.1/archival/libarchive/decompress_unxz.c	2019-10-21 18:54:40.000000000 +0400
+++ busybox-1.32.0/archival/libarchive/decompress_unxz.c	2020-06-26 22:47:44.000000000 +0400
@@ -74,7 +74,7 @@ unpack_xz_stream(transformer_state_t *xs
 		if (iobuf.in_pos == iobuf.in_size) {
 			int rd = safe_read(xstate->src_fd, membuf, BUFSIZ);
 			if (rd < 0) {
-				bb_error_msg(bb_msg_read_error);
+				bb_simple_error_msg(bb_msg_read_error);
 				total = -1;
 				break;
 			}
@@ -141,7 +141,7 @@ unpack_xz_stream(transformer_state_t *xs
 			continue;
 		}
 		if (xz_result != XZ_OK && xz_result != XZ_UNSUPPORTED_CHECK) {
-			bb_error_msg("corrupted data");
+			bb_simple_error_msg("corrupted data");
 			total = -1;
 			break;
 		}
diff -urpN busybox-1.31.1/archival/libarchive/get_header_ar.c busybox-1.32.0/archival/libarchive/get_header_ar.c
--- busybox-1.31.1/archival/libarchive/get_header_ar.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/libarchive/get_header_ar.c	2020-06-26 22:47:44.000000000 +0400
@@ -22,7 +22,7 @@ static unsigned read_num(char *str, int
 	 * on misformatted numbers bb_strtou returns all-ones */
 	err = bb_strtou(str, NULL, base);
 	if (err == -1)
-		bb_error_msg_and_die("invalid ar header");
+		bb_simple_error_msg_and_die("invalid ar header");
 	return err;
 }
 
@@ -53,7 +53,7 @@ char FAST_FUNC get_header_ar(archive_han
 	archive_handle->offset += 60;
 
 	if (ar.formatted.magic[0] != '`' || ar.formatted.magic[1] != '\n')
-		bb_error_msg_and_die("invalid ar header");
+		bb_simple_error_msg_and_die("invalid ar header");
 
 	/*
 	 * Note that the fields MUST be read in reverse order as
@@ -86,7 +86,7 @@ char FAST_FUNC get_header_ar(archive_han
 			return get_header_ar(archive_handle);
 		}
 #else
-		bb_error_msg_and_die("long filenames not supported");
+		bb_simple_error_msg_and_die("long filenames not supported");
 #endif
 	}
 	/* Only size is always present, the rest may be missing in
@@ -107,7 +107,7 @@ char FAST_FUNC get_header_ar(archive_han
 		long_offset = read_num(&ar.formatted.name[1], 10,
 				       sizeof(ar.formatted.name) - 1);
 		if (long_offset >= archive_handle->ar__long_name_size) {
-			bb_error_msg_and_die("can't resolve long filename");
+			bb_simple_error_msg_and_die("can't resolve long filename");
 		}
 		typed->name = xstrdup(archive_handle->ar__long_names + long_offset);
 	} else
diff -urpN busybox-1.31.1/archival/libarchive/get_header_cpio.c busybox-1.32.0/archival/libarchive/get_header_cpio.c
--- busybox-1.31.1/archival/libarchive/get_header_cpio.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/libarchive/get_header_cpio.c	2020-06-26 22:47:44.000000000 +0400
@@ -33,14 +33,14 @@ char FAST_FUNC get_header_cpio(archive_h
 		goto create_hardlinks;
 	}
 	if (size != 110) {
-		bb_error_msg_and_die("short read");
+		bb_simple_error_msg_and_die("short read");
 	}
 	archive_handle->offset += 110;
 
 	if (!is_prefixed_with(&cpio_header[0], "07070")
 	 || (cpio_header[5] != '1' && cpio_header[5] != '2')
 	) {
-		bb_error_msg_and_die("unsupported cpio format, use newc or crc");
+		bb_simple_error_msg_and_die("unsupported cpio format, use newc or crc");
 	}
 
 	if (sscanf(cpio_header + 6,
@@ -50,7 +50,7 @@ char FAST_FUNC get_header_cpio(archive_h
 			&inode, &mode, &uid, &gid,
 			&nlink, &mtime, &size,
 			&major, &minor, &namesize) != 10)
-		bb_error_msg_and_die("damaged cpio file");
+		bb_simple_error_msg_and_die("damaged cpio file");
 	file_header->mode = mode;
 	/* "cpio -R USER:GRP" support: */
 	if (archive_handle->cpio__owner.uid != (uid_t)-1L)
diff -urpN busybox-1.31.1/archival/libarchive/get_header_tar.c busybox-1.32.0/archival/libarchive/get_header_tar.c
--- busybox-1.31.1/archival/libarchive/get_header_tar.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/libarchive/get_header_tar.c	2020-06-26 22:47:44.000000000 +0400
@@ -32,7 +32,7 @@ static unsigned long long getOctal(char
 	if (*end != '\0' && *end != ' ') {
 		int8_t first = str[0];
 		if (!(first & 0x80))
-			bb_error_msg_and_die("corrupted octal value in tar header");
+			bb_simple_error_msg_and_die("corrupted octal value in tar header");
 		/*
 		 * GNU tar uses "base-256 encoding" for very large numbers.
 		 * Encoding is binary, with highest bit always set as a marker
@@ -100,7 +100,7 @@ static void process_pax_hdr(archive_hand
 		 || errno != EINVAL
 		 || *end != ' '
 		) {
-			bb_error_msg("malformed extended header, skipped");
+			bb_simple_error_msg("malformed extended header, skipped");
 			// More verbose version:
 			//bb_error_msg("malformed extended header at %"OFF_FMT"d, skipped",
 			//		archive_handle->offset - (sz + len));
@@ -194,13 +194,13 @@ char FAST_FUNC get_header_tar(archive_ha
 		 * the very first read fails. Grrr.
 		 */
 		if (archive_handle->offset == 0)
-			bb_error_msg("short read");
+			bb_simple_error_msg("short read");
 		/* this merely signals end of archive, not exit(1): */
 		return EXIT_FAILURE;
 	}
 	if (i != 512) {
 		IF_FEATURE_TAR_AUTODETECT(goto autodetect;)
-		bb_error_msg_and_die("short read");
+		bb_simple_error_msg_and_die("short read");
 	}
 
 #else
@@ -243,11 +243,11 @@ char FAST_FUNC get_header_tar(archive_ha
 			goto err;
 		if (setup_unzip_on_fd(archive_handle->src_fd, /*fail_if_not_compressed:*/ 0) != 0)
  err:
-			bb_error_msg_and_die("invalid tar magic");
+			bb_simple_error_msg_and_die("invalid tar magic");
 		archive_handle->offset = 0;
 		goto again_after_align;
 #endif
-		bb_error_msg_and_die("invalid tar magic");
+		bb_simple_error_msg_and_die("invalid tar magic");
 	}
 
 	/* Do checksum on headers.
@@ -282,7 +282,7 @@ char FAST_FUNC get_header_tar(archive_ha
 	if (sum_u != sum
 	    IF_FEATURE_TAR_OLDSUN_COMPATIBILITY(&& sum_s != sum)
 	) {
-		bb_error_msg_and_die("invalid tar header checksum");
+		bb_simple_error_msg_and_die("invalid tar header checksum");
 	}
 
 	/* GET_OCTAL trashes subsequent field, therefore we call it
diff -urpN busybox-1.31.1/archival/libarchive/open_transformer.c busybox-1.32.0/archival/libarchive/open_transformer.c
--- busybox-1.31.1/archival/libarchive/open_transformer.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/libarchive/open_transformer.c	2020-06-26 22:47:44.000000000 +0400
@@ -15,7 +15,7 @@ int FAST_FUNC check_signature16(transfor
 	if (!xstate->signature_skipped) {
 		uint16_t magic2;
 		if (full_read(xstate->src_fd, &magic2, 2) != 2 || magic2 != magic16) {
-			bb_error_msg("invalid magic");
+			bb_simple_error_msg("invalid magic");
 			return -1;
 		}
 		xstate->signature_skipped = 2;
@@ -46,7 +46,7 @@ ssize_t FAST_FUNC transformer_write(tran
 	} else {
 		nwrote = full_write(xstate->dst_fd, buf, bufsize);
 		if (nwrote != (ssize_t)bufsize) {
-			bb_perror_msg("write");
+			bb_simple_perror_msg("write");
 			nwrote = -1;
 			goto ret;
 		}
@@ -205,7 +205,7 @@ static transformer_state_t *setup_transf
 
 	/* No known magic seen */
 	if (fail_if_not_compressed)
-		bb_error_msg_and_die("no gzip"
+		bb_simple_error_msg_and_die("no gzip"
 			IF_FEATURE_SEAMLESS_BZ2("/bzip2")
 			IF_FEATURE_SEAMLESS_XZ("/xz")
 			" magic");
diff -urpN busybox-1.31.1/archival/libarchive/seek_by_jump.c busybox-1.32.0/archival/libarchive/seek_by_jump.c
--- busybox-1.31.1/archival/libarchive/seek_by_jump.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/libarchive/seek_by_jump.c	2020-06-26 22:47:44.000000000 +0400
@@ -13,6 +13,6 @@ void FAST_FUNC seek_by_jump(int fd, off_
 		if (errno == ESPIPE)
 			seek_by_read(fd, amount);
 		else
-			bb_perror_msg_and_die("seek failure");
+			bb_simple_perror_msg_and_die("seek failure");
 	}
 }
diff -urpN busybox-1.31.1/archival/libarchive/unpack_ar_archive.c busybox-1.32.0/archival/libarchive/unpack_ar_archive.c
--- busybox-1.31.1/archival/libarchive/unpack_ar_archive.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/libarchive/unpack_ar_archive.c	2020-06-26 22:47:44.000000000 +0400
@@ -12,7 +12,7 @@ void FAST_FUNC unpack_ar_archive(archive
 
 	xread(ar_archive->src_fd, magic, AR_MAGIC_LEN);
 	if (!is_prefixed_with(magic, AR_MAGIC)) {
-		bb_error_msg_and_die("invalid ar magic");
+		bb_simple_error_msg_and_die("invalid ar magic");
 	}
 	ar_archive->offset += AR_MAGIC_LEN;
 
diff -urpN busybox-1.31.1/archival/lzop.c busybox-1.32.0/archival/lzop.c
--- busybox-1.31.1/archival/lzop.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/lzop.c	2020-06-26 22:47:44.000000000 +0400
@@ -752,7 +752,7 @@ static FAST_FUNC void lzo_check(
 	 */
 	uint32_t c = fn(init, buf, len);
 	if (c != ref)
-		bb_error_msg_and_die("checksum error");
+		bb_simple_error_msg_and_die("checksum error");
 }
 
 /**********************************************************************/
@@ -785,15 +785,15 @@ static NOINLINE int lzo_decompress(uint3
 		/* error if split file */
 		if (dst_len == 0xffffffffL)
 			/* should not happen - not yet implemented */
-			bb_error_msg_and_die("this file is a split lzop file");
+			bb_simple_error_msg_and_die("this file is a split lzop file");
 
 		if (dst_len > MAX_BLOCK_SIZE)
-			bb_error_msg_and_die("corrupted data");
+			bb_simple_error_msg_and_die("corrupted data");
 
 		/* read compressed block size */
 		src_len = read32();
 		if (src_len <= 0 || src_len > dst_len)
-			bb_error_msg_and_die("corrupted data");
+			bb_simple_error_msg_and_die("corrupted data");
 
 		if (dst_len > block_size) {
 			if (b2) {
@@ -846,7 +846,7 @@ static NOINLINE int lzo_decompress(uint3
 				r = lzo1x_decompress_safe(b1, src_len, b2, &d /*, NULL*/);
 
 			if (r != 0 /*LZO_E_OK*/ || dst_len != d) {
-				bb_error_msg_and_die("corrupted data");
+				bb_simple_error_msg_and_die("corrupted data");
 			}
 			dst = b2;
 		} else {
@@ -913,7 +913,7 @@ static void check_magic(void)
 	unsigned char magic[sizeof(lzop_magic)];
 	xread(0, magic, sizeof(magic));
 	if (memcmp(magic, lzop_magic, sizeof(lzop_magic)) != 0)
-		bb_error_msg_and_die("bad magic number");
+		bb_simple_error_msg_and_die("bad magic number");
 }
 
 /**********************************************************************/
@@ -1049,7 +1049,7 @@ static void lzo_set_method(header_t *h)
 		else if (option_mask32 & OPT_8)
 			level = 8;
 #else
-		bb_error_msg_and_die("high compression not compiled in");
+		bb_simple_error_msg_and_die("high compression not compiled in");
 #endif
 	}
 
diff -urpN busybox-1.31.1/archival/rpm.c busybox-1.32.0/archival/rpm.c
--- busybox-1.31.1/archival/rpm.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/rpm.c	2020-06-26 22:47:44.000000000 +0400
@@ -543,7 +543,7 @@ int rpm2cpio_main(int argc UNUSED_PARAM,
 	}
 
 	if (bb_copyfd_eof(rpm_fd, STDOUT_FILENO) < 0)
-		bb_error_msg_and_die("error unpacking");
+		bb_simple_error_msg_and_die("error unpacking");
 
 	if (ENABLE_FEATURE_CLEAN_UP) {
 		close(rpm_fd);
diff -urpN busybox-1.31.1/archival/tar.c busybox-1.32.0/archival/tar.c
--- busybox-1.31.1/archival/tar.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/tar.c	2020-06-26 22:47:44.000000000 +0400
@@ -232,7 +232,7 @@ static HardLinkInfo *findHardLinkInfo(Ha
 }
 
 /* Put an octal string into the specified buffer.
- * The number is zero padded and possibly null terminated.
+ * The number is zero padded and possibly NUL terminated.
  * Stores low-order bits only if whole value does not fit. */
 static void putOctal(char *cp, int len, off_t value)
 {
@@ -283,31 +283,32 @@ static void chksum_and_xwrite(int fd, st
 # if ENABLE_FEATURE_TAR_GNU_EXTENSIONS
 static void writeLongname(int fd, int type, const char *name, int dir)
 {
-	static const struct {
+	struct prefilled {
 		char mode[8];             /* 100-107 */
 		char uid[8];              /* 108-115 */
 		char gid[8];              /* 116-123 */
 		char size[12];            /* 124-135 */
 		char mtime[12];           /* 136-147 */
-	} prefilled = {
-		"0000000",
-		"0000000",
-		"0000000",
-		"00000000000",
-		"00000000000",
 	};
 	struct tar_header_t header;
 	int size;
 
+	memset(&header, 0, sizeof(header));
+	header.typeflag = type;
+	strcpy(header.name, "././@LongLink");
+	/* This sets mode/uid/gid/mtime to "00...00<NUL>" strings */
+	memset(header.mode, '0', sizeof(struct prefilled));
+	header.mode [sizeof(header.mode ) - 1] = '\0';
+	header.uid  [sizeof(header.uid  ) - 1] = '\0';
+	header.gid  [sizeof(header.gid  ) - 1] = '\0';
+	/* header.size is filled by '0' now, will be corrected below */
+	header.mtime[sizeof(header.mtime) - 1] = '\0';
+
 	dir = !!dir; /* normalize: 0/1 */
 	size = strlen(name) + 1 + dir; /* GNU tar uses strlen+1 */
 	/* + dir: account for possible '/' */
 
-	memset(&header, 0, sizeof(header));
-	strcpy(header.name, "././@LongLink");
-	memcpy(header.mode, prefilled.mode, sizeof(prefilled));
 	PUT_OCTAL(header.size, size);
-	header.typeflag = type;
 	chksum_and_xwrite(fd, &header);
 
 	/* Write filename[/] and pad the block. */
@@ -369,7 +370,7 @@ static int writeTarHeader(struct TarBall
 		/* If it is larger than 100 bytes, bail out */
 		if (header.linkname[sizeof(header.linkname)-1]) {
 			free(lpath);
-			bb_error_msg("names longer than "NAME_SIZE_STR" chars not supported");
+			bb_simple_error_msg("names longer than "NAME_SIZE_STR" chars not supported");
 			return FALSE;
 		}
 # endif
@@ -542,7 +543,7 @@ static int FAST_FUNC writeFileToTarball(
 
 # if !ENABLE_FEATURE_TAR_GNU_EXTENSIONS
 	if (strlen(header_name) >= NAME_SIZE) {
-		bb_error_msg("names longer than "NAME_SIZE_STR" chars not supported");
+		bb_simple_error_msg("names longer than "NAME_SIZE_STR" chars not supported");
 		return TRUE;
 	}
 # endif
@@ -636,8 +637,14 @@ static void NOINLINE vfork_compressor(in
 		}
 		xmove_fd(data.rd, 0);
 		xmove_fd(tfd, 1);
-		/* exec gzip/bzip2 program/applet */
-		BB_EXECLP(gzip, gzip, "-f", (char *)0);
+
+		/* exec gzip/bzip2/... program */
+		//BB_EXECLP(gzip, gzip, "-f", (char *)0); - WRONG for "xz",
+		// if xz is an enabled applet, it'll be a version which
+		// can only decompress. We do need to execute external
+		// program, not applet.
+		execlp(gzip, gzip, "-f", (char *)0);
+
 		vfork_exec_errno = errno;
 		_exit(EXIT_FAILURE);
 	}
@@ -715,13 +722,13 @@ static NOINLINE int writeTarFile(
 		freeHardLinkInfo(&tbInfo->hlInfoHead);
 
 	if (errorFlag)
-		bb_error_msg("error exit delayed from previous errors");
+		bb_simple_error_msg("error exit delayed from previous errors");
 
 # if SEAMLESS_COMPRESSION
 	if (gzip) {
 		int status;
 		if (safe_waitpid(-1, &status, 0) == -1)
-			bb_perror_msg("waitpid");
+			bb_simple_perror_msg("waitpid");
 		else if (!WIFEXITED(status) || WEXITSTATUS(status))
 			/* gzip was killed or has exited with nonzero! */
 			errorFlag = TRUE;
@@ -761,7 +768,7 @@ static llist_t *append_file_list_to_list
 //usage:	IF_FEATURE_SEAMLESS_GZ("z")
 //usage:	IF_FEATURE_SEAMLESS_XZ("J")
 //usage:	IF_FEATURE_SEAMLESS_BZ2("j")
-//usage:	IF_FEATURE_SEAMLESS_LZMA("a")
+//usage:	"a"
 //usage:	IF_FEATURE_TAR_CREATE("h")
 //usage:	IF_FEATURE_TAR_NOPRESERVE_TIME("m")
 //usage:	"vokO] "
@@ -800,9 +807,7 @@ static llist_t *append_file_list_to_list
 //usage:	IF_FEATURE_SEAMLESS_BZ2(
 //usage:     "\n	-j	(De)compress using bzip2"
 //usage:	)
-//usage:	IF_FEATURE_SEAMLESS_LZMA(
-//usage:     "\n	-a	(De)compress using lzma"
-//usage:	)
+//usage:     "\n	-a	(De)compress based on extension"
 //usage:	IF_FEATURE_TAR_CREATE(
 //usage:     "\n	-h	Follow symlinks"
 //usage:	)
@@ -819,6 +824,7 @@ static llist_t *append_file_list_to_list
 //usage:       "$ tar -cf /tmp/tarball.tar /usr/local\n"
 
 // Supported but aren't in --help:
+//	lzma
 //	no-recursion
 //	numeric-owner
 //	no-same-permissions
@@ -832,15 +838,16 @@ enum {
 	IF_FEATURE_TAR_CREATE(   OPTBIT_CREATE      ,)
 	IF_FEATURE_TAR_CREATE(   OPTBIT_DEREFERENCE ,)
 	IF_FEATURE_SEAMLESS_BZ2( OPTBIT_BZIP2       ,)
-	IF_FEATURE_SEAMLESS_LZMA(OPTBIT_LZMA        ,)
 	IF_FEATURE_TAR_FROM(     OPTBIT_INCLUDE_FROM,)
 	IF_FEATURE_TAR_FROM(     OPTBIT_EXCLUDE_FROM,)
 	IF_FEATURE_SEAMLESS_GZ(  OPTBIT_GZIP        ,)
-	IF_FEATURE_SEAMLESS_XZ(  OPTBIT_XZ          ,) // 16th bit
-	IF_FEATURE_SEAMLESS_Z(   OPTBIT_COMPRESS    ,)
+	IF_FEATURE_SEAMLESS_XZ(  OPTBIT_XZ          ,)
+	IF_FEATURE_SEAMLESS_Z(   OPTBIT_COMPRESS    ,) // 16th bit
+	OPTBIT_AUTOCOMPRESS_BY_EXT,
 	IF_FEATURE_TAR_NOPRESERVE_TIME(OPTBIT_NOPRESERVE_TIME,)
 #if ENABLE_FEATURE_TAR_LONG_OPTIONS
 	OPTBIT_STRIP_COMPONENTS,
+	IF_FEATURE_SEAMLESS_LZMA(OPTBIT_LZMA        ,)
 	OPTBIT_NORECURSION,
 	IF_FEATURE_TAR_TO_COMMAND(OPTBIT_2COMMAND   ,)
 	OPTBIT_NUMERIC_OWNER,
@@ -859,14 +866,15 @@ enum {
 	OPT_CREATE       = IF_FEATURE_TAR_CREATE(   (1 << OPTBIT_CREATE      )) + 0, // c
 	OPT_DEREFERENCE  = IF_FEATURE_TAR_CREATE(   (1 << OPTBIT_DEREFERENCE )) + 0, // h
 	OPT_BZIP2        = IF_FEATURE_SEAMLESS_BZ2( (1 << OPTBIT_BZIP2       )) + 0, // j
-	OPT_LZMA         = IF_FEATURE_SEAMLESS_LZMA((1 << OPTBIT_LZMA        )) + 0, // a
 	OPT_INCLUDE_FROM = IF_FEATURE_TAR_FROM(     (1 << OPTBIT_INCLUDE_FROM)) + 0, // T
 	OPT_EXCLUDE_FROM = IF_FEATURE_TAR_FROM(     (1 << OPTBIT_EXCLUDE_FROM)) + 0, // X
 	OPT_GZIP         = IF_FEATURE_SEAMLESS_GZ(  (1 << OPTBIT_GZIP        )) + 0, // z
 	OPT_XZ           = IF_FEATURE_SEAMLESS_XZ(  (1 << OPTBIT_XZ          )) + 0, // J
 	OPT_COMPRESS     = IF_FEATURE_SEAMLESS_Z(   (1 << OPTBIT_COMPRESS    )) + 0, // Z
+	OPT_AUTOCOMPRESS_BY_EXT = 1 << OPTBIT_AUTOCOMPRESS_BY_EXT,                   // a
 	OPT_NOPRESERVE_TIME  = IF_FEATURE_TAR_NOPRESERVE_TIME((1 << OPTBIT_NOPRESERVE_TIME)) + 0, // m
 	OPT_STRIP_COMPONENTS = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_STRIP_COMPONENTS)) + 0, // strip-components
+	OPT_LZMA             = IF_FEATURE_TAR_LONG_OPTIONS(IF_FEATURE_SEAMLESS_LZMA((1 << OPTBIT_LZMA))) + 0, // lzma
 	OPT_NORECURSION      = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_NORECURSION    )) + 0, // no-recursion
 	OPT_2COMMAND         = IF_FEATURE_TAR_TO_COMMAND(  (1 << OPTBIT_2COMMAND       )) + 0, // to-command
 	OPT_NUMERIC_OWNER    = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_NUMERIC_OWNER  )) + 0, // numeric-owner
@@ -896,9 +904,6 @@ static const char tar_longopts[] ALIGN1
 # if ENABLE_FEATURE_SEAMLESS_BZ2
 	"bzip2\0"               No_argument       "j"
 # endif
-# if ENABLE_FEATURE_SEAMLESS_LZMA
-	"lzma\0"                No_argument       "a"
-# endif
 # if ENABLE_FEATURE_TAR_FROM
 	"files-from\0"          Required_argument "T"
 	"exclude-from\0"        Required_argument "X"
@@ -912,10 +917,14 @@ static const char tar_longopts[] ALIGN1
 # if ENABLE_FEATURE_SEAMLESS_Z
 	"compress\0"            No_argument       "Z"
 # endif
+	"auto-compress\0"       No_argument       "a"
 # if ENABLE_FEATURE_TAR_NOPRESERVE_TIME
 	"touch\0"               No_argument       "m"
 # endif
-	"strip-components\0"	Required_argument "\xf9"
+	"strip-components\0"	Required_argument "\xf8"
+# if ENABLE_FEATURE_SEAMLESS_LZMA
+	"lzma\0"                No_argument       "\xf9"
+# endif
 	"no-recursion\0"	No_argument       "\xfa"
 # if ENABLE_FEATURE_TAR_TO_COMMAND
 	"to-command\0"		Required_argument "\xfb"
@@ -1004,13 +1013,13 @@ int tar_main(int argc UNUSED_PARAM, char
 		"txC:f:Oopvk"
 		IF_FEATURE_TAR_CREATE(   "ch"    )
 		IF_FEATURE_SEAMLESS_BZ2( "j"     )
-		IF_FEATURE_SEAMLESS_LZMA("a"     )
 		IF_FEATURE_TAR_FROM(     "T:*X:*")
 		IF_FEATURE_SEAMLESS_GZ(  "z"     )
 		IF_FEATURE_SEAMLESS_XZ(  "J"     )
 		IF_FEATURE_SEAMLESS_Z(   "Z"     )
+		"a"
 		IF_FEATURE_TAR_NOPRESERVE_TIME("m")
-		IF_FEATURE_TAR_LONG_OPTIONS("\xf9:") // --strip-components
+		IF_FEATURE_TAR_LONG_OPTIONS("\xf8:") // --strip-components
 		"\0"
 		"tt:vv:" // count -t,-v
 #if ENABLE_FEATURE_TAR_LONG_OPTIONS && ENABLE_FEATURE_TAR_FROM
@@ -1020,7 +1029,7 @@ int tar_main(int argc UNUSED_PARAM, char
 		IF_FEATURE_TAR_CREATE("c--tx:t--cx:x--ct") // mutually exclusive
 		IF_NOT_FEATURE_TAR_CREATE("t--x:x--t") // mutually exclusive
 #if ENABLE_FEATURE_TAR_LONG_OPTIONS
-		":\xf9+" // --strip-components=NUM
+		":\xf8+" // --strip-components=NUM
 #endif
 		LONGOPTS
 		, &base_dir // -C dir
@@ -1039,7 +1048,7 @@ int tar_main(int argc UNUSED_PARAM, char
 		);
 #if DBG_OPTION_PARSING
 	bb_error_msg("opt: 0x%08x", opt);
-# define showopt(o) bb_error_msg("opt & %s(%x): %x", #o, o, opt & o);
+# define showopt(o) bb_error_msg("opt & %s(%x):\t%x", #o, o, opt & o);
 	showopt(OPT_TEST            );
 	showopt(OPT_EXTRACT         );
 	showopt(OPT_BASEDIR         );
@@ -1052,14 +1061,15 @@ int tar_main(int argc UNUSED_PARAM, char
 	showopt(OPT_CREATE          );
 	showopt(OPT_DEREFERENCE     );
 	showopt(OPT_BZIP2           );
-	showopt(OPT_LZMA            );
 	showopt(OPT_INCLUDE_FROM    );
 	showopt(OPT_EXCLUDE_FROM    );
 	showopt(OPT_GZIP            );
 	showopt(OPT_XZ              );
 	showopt(OPT_COMPRESS        );
+	showopt(OPT_AUTOCOMPRESS_BY_EXT);
 	showopt(OPT_NOPRESERVE_TIME );
 	showopt(OPT_STRIP_COMPONENTS);
+	showopt(OPT_LZMA            );
 	showopt(OPT_NORECURSION     );
 	showopt(OPT_2COMMAND        );
 	showopt(OPT_NUMERIC_OWNER   );
@@ -1150,7 +1160,7 @@ int tar_main(int argc UNUSED_PARAM, char
 		if (opt & OPT_CREATE) {
 			/* Make sure there is at least one file to tar up */
 			if (tar_handle->accept == NULL)
-				bb_error_msg_and_die("empty archive");
+				bb_simple_error_msg_and_die("empty archive");
 
 			tar_fd = STDOUT_FILENO;
 			/* Mimicking GNU tar 1.15.1: */
@@ -1178,6 +1188,21 @@ int tar_main(int argc UNUSED_PARAM, char
 				bb_perror_msg_and_die("can't open '%s'", tar_filename);
 		} else {
 			tar_handle->src_fd = xopen(tar_filename, flags);
+#if ENABLE_FEATURE_TAR_CREATE
+			if ((OPT_GZIP | OPT_BZIP2 | OPT_XZ | OPT_LZMA) != 0 /* at least one is config-enabled */
+			 && (opt & OPT_AUTOCOMPRESS_BY_EXT)
+			 && flags != O_RDONLY
+			) {
+				if (OPT_GZIP != 0 && is_suffixed_with(tar_filename, "gz"))
+					opt |= OPT_GZIP;
+				if (OPT_BZIP2 != 0 && is_suffixed_with(tar_filename, "bz2"))
+					opt |= OPT_BZIP2;
+				if (OPT_XZ != 0 && is_suffixed_with(tar_filename, "xz"))
+					opt |= OPT_XZ;
+				if (OPT_LZMA != 0 && is_suffixed_with(tar_filename, "lzma"))
+					opt |= OPT_LZMA;
+			}
+#endif
 		}
 	}
 
diff -urpN busybox-1.31.1/archival/unzip.c busybox-1.32.0/archival/unzip.c
--- busybox-1.31.1/archival/unzip.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/archival/unzip.c	2020-06-26 22:47:44.000000000 +0400
@@ -322,7 +322,7 @@ static uint32_t read_next_cdf(uint32_t c
 static void die_if_bad_fnamesize(unsigned sz)
 {
 	if (sz > 0xfff) /* more than 4k?! no funny business please */
-		bb_error_msg_and_die("bad archive");
+		bb_simple_error_msg_and_die("bad archive");
 }
 
 static void unzip_skip(off_t skip)
@@ -359,7 +359,7 @@ static void unzip_extract_symlink(llist_
 		xread(zip_fd, target, zip->fmt.ucmpsize);
 	} else {
 #if 1
-		bb_error_msg_and_die("compressed symlink is not supported");
+		bb_simple_error_msg_and_die("compressed symlink is not supported");
 #else
 		transformer_state_t xstate;
 		init_transformer_state(&xstate);
@@ -399,10 +399,10 @@ static void unzip_extract(zip_header_t *
 	if (zip->fmt.method == 8) {
 		/* Method 8 - inflate */
 		if (inflate_unzip(&xstate) < 0)
-			bb_error_msg_and_die("inflate error");
+			bb_simple_error_msg_and_die("inflate error");
 		/* Validate decompression - crc */
 		if (zip->fmt.crc32 != (xstate.crc32 ^ 0xffffffffL)) {
-			bb_error_msg_and_die("crc error");
+			bb_simple_error_msg_and_die("crc error");
 		}
 	}
 #if ENABLE_FEATURE_UNZIP_BZIP2
@@ -412,7 +412,7 @@ static void unzip_extract(zip_header_t *
 		 */
 		xstate.bytes_out = unpack_bz2_stream(&xstate);
 		if (xstate.bytes_out < 0)
-			bb_error_msg_and_die("inflate error");
+			bb_simple_error_msg_and_die("inflate error");
 	}
 #endif
 #if ENABLE_FEATURE_UNZIP_LZMA
@@ -420,7 +420,7 @@ static void unzip_extract(zip_header_t *
 		/* Not tested yet */
 		xstate.bytes_out = unpack_lzma_stream(&xstate);
 		if (xstate.bytes_out < 0)
-			bb_error_msg_and_die("inflate error");
+			bb_simple_error_msg_and_die("inflate error");
 	}
 #endif
 #if ENABLE_FEATURE_UNZIP_XZ
@@ -428,7 +428,7 @@ static void unzip_extract(zip_header_t *
 		/* Not tested yet */
 		xstate.bytes_out = unpack_xz_stream(&xstate);
 		if (xstate.bytes_out < 0)
-			bb_error_msg_and_die("inflate error");
+			bb_simple_error_msg_and_die("inflate error");
 	}
 #endif
 	else {
@@ -439,7 +439,7 @@ static void unzip_extract(zip_header_t *
 	if (zip->fmt.ucmpsize != xstate.bytes_out) {
 		/* Don't die. Who knows, maybe len calculation
 		 * was botched somewhere. After all, crc matched! */
-		bb_error_msg("bad length");
+		bb_simple_error_msg("bad length");
 	}
 }
 
@@ -447,7 +447,7 @@ static void my_fgets80(char *buf80)
 {
 	fflush_all();
 	if (!fgets(buf80, 80, stdin)) {
-		bb_perror_msg_and_die("can't read standard input");
+		bb_simple_perror_msg_and_die("can't read standard input");
 	}
 }
 
@@ -646,8 +646,14 @@ int unzip_main(int argc, char **argv)
 	}
 
 	/* Change dir if necessary */
-	if (base_dir)
+	if (base_dir) {
+		/* -p DIR: try to create, errors don't matter.
+		 * UnZip 6.00 does no multi-level mkdir (-p DIR1/DIR2 syntax),
+		 * not using bb_make_directory() here (yet?)
+		 */
+		mkdir(base_dir, 0777);
 		xchdir(base_dir);
+	}
 
 	if (quiet <= 1) { /* not -qq */
 		if (quiet == 0) {
diff -urpN busybox-1.31.1/console-tools/loadfont.c busybox-1.32.0/console-tools/loadfont.c
--- busybox-1.31.1/console-tools/loadfont.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/console-tools/loadfont.c	2020-06-26 22:47:44.000000000 +0400
@@ -225,7 +225,7 @@ static void do_loadtable(int fd, unsigne
 				if (unicode == PSF2_SEPARATOR) {
 					break;
 				} else if (unicode == PSF2_STARTSEQ) {
-					bb_error_msg_and_die("unicode sequences not implemented");
+					bb_simple_error_msg_and_die("unicode sequences not implemented");
 				} else if (unicode >= 0xC0) {
 					if (unicode >= 0xFC)
 						unicode &= 0x01, maxct = 5;
@@ -239,12 +239,12 @@ static void do_loadtable(int fd, unsigne
 						unicode &= 0x1F, maxct = 1;
 					do {
 						if (tailsz <= 0 || *inbuf < 0x80 || *inbuf > 0xBF)
-							bb_error_msg_and_die("illegal UTF-8 character");
+							bb_simple_error_msg_and_die("illegal UTF-8 character");
 						--tailsz;
 						unicode = (unicode << 6) + (*inbuf++ & 0x3F);
 					} while (--maxct > 0);
 				} else if (unicode >= 0x80) {
-					bb_error_msg_and_die("illegal UTF-8 character");
+					bb_simple_error_msg_and_die("illegal UTF-8 character");
 				}
 #else
 				return;
@@ -281,7 +281,7 @@ static void do_load(int fd, unsigned cha
 
 	if (len >= sizeof(struct psf1_header) && PSF1_MAGIC_OK(psf1h(buffer))) {
 		if (psf1h(buffer)->mode > PSF1_MAXMODE)
-			bb_error_msg_and_die("unsupported psf file mode");
+			bb_simple_error_msg_and_die("unsupported psf file mode");
 		if (psf1h(buffer)->mode & PSF1_MODE512)
 			fontsize = 512;
 		if (psf1h(buffer)->mode & PSF1_MODEHASTAB)
@@ -292,7 +292,7 @@ static void do_load(int fd, unsigned cha
 #if ENABLE_FEATURE_LOADFONT_PSF2
 	if (len >= sizeof(struct psf2_header) && PSF2_MAGIC_OK(psf2h(buffer))) {
 		if (psf2h(buffer)->version > PSF2_MAXVERSION)
-			bb_error_msg_and_die("unsupported psf file version");
+			bb_simple_error_msg_and_die("unsupported psf file version");
 		fontsize = psf2h(buffer)->length;
 		if (psf2h(buffer)->flags & PSF2_HAS_UNICODE_TABLE)
 			has_table = 2;
@@ -311,19 +311,19 @@ static void do_load(int fd, unsigned cha
 	} else
 #endif
 	{
-		bb_error_msg_and_die("input file: bad length or unsupported font type");
+		bb_simple_error_msg_and_die("input file: bad length or unsupported font type");
 	}
 
 #if !defined(PIO_FONTX) || defined(__sparc__)
 	if (fontsize != 256)
-		bb_error_msg_and_die("only fontsize 256 supported");
+		bb_simple_error_msg_and_die("only fontsize 256 supported");
 #endif
 
 	table = font + fontsize * charsize;
 	buffer += len;
 
 	if (table > buffer || (!has_table && table != buffer))
-		bb_error_msg_and_die("input file: bad length");
+		bb_simple_error_msg_and_die("input file: bad length");
 
 	do_loadfont(fd, font, height, width, charsize, fontsize);
 
@@ -361,7 +361,7 @@ int loadfont_main(int argc UNUSED_PARAM,
 	buffer = xmalloc_read(STDIN_FILENO, &len);
 	// xmalloc_open_zipped_read_close(filename, &len);
 	if (!buffer)
-		bb_perror_msg_and_die("error reading input font");
+		bb_simple_perror_msg_and_die("error reading input font");
 	do_load(get_console_fd_or_die(), buffer, len);
 
 	return EXIT_SUCCESS;
@@ -502,7 +502,7 @@ int setfont_main(int argc UNUSED_PARAM,
 				if (a < 0 || a >= E_TABSZ
 				 || b < 0 || b > 65535
 				) {
-					bb_error_msg_and_die("map format");
+					bb_simple_error_msg_and_die("map format");
 				}
 				// patch map
 				unicodes[a] = b;
diff -urpN busybox-1.31.1/console-tools/loadkmap.c busybox-1.32.0/console-tools/loadkmap.c
--- busybox-1.31.1/console-tools/loadkmap.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/console-tools/loadkmap.c	2020-06-26 22:47:44.000000000 +0400
@@ -69,7 +69,7 @@ int loadkmap_main(int argc UNUSED_PARAM,
 
 	xread(STDIN_FILENO, flags, 7);
 	if (!is_prefixed_with(flags, BINARY_KEYMAP_MAGIC))
-		bb_error_msg_and_die("not a valid binary keymap");
+		bb_simple_error_msg_and_die("not a valid binary keymap");
 
 	xread(STDIN_FILENO, flags, MAX_NR_KEYMAPS);
 
diff -urpN busybox-1.31.1/console-tools/openvt.c busybox-1.32.0/console-tools/openvt.c
--- busybox-1.31.1/console-tools/openvt.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/console-tools/openvt.c	2020-06-26 22:47:44.000000000 +0400
@@ -87,7 +87,7 @@ static int get_vt_fd(void)
 	fd = open(DEV_CONSOLE, O_RDONLY | O_NONBLOCK);
 	if (fd >= 0 && !not_vt_fd(fd))
 		return fd;
-	bb_error_msg_and_die("can't find open VT");
+	bb_simple_error_msg_and_die("can't find open VT");
 }
 
 static int find_free_vtno(void)
@@ -98,7 +98,7 @@ static int find_free_vtno(void)
 	errno = 0;
 	/*xfunc_error_retval = 3; - do we need compat? */
 	if (ioctl(fd, VT_OPENQRY, &vtno) != 0 || vtno <= 0)
-		bb_perror_msg_and_die("can't find open VT");
+		bb_simple_perror_msg_and_die("can't find open VT");
 // Not really needed, grep for DAEMON_CLOSE_EXTRA_FDS
 //	if (fd > 2)
 //		close(fd);
diff -urpN busybox-1.31.1/console-tools/showkey.c busybox-1.32.0/console-tools/showkey.c
--- busybox-1.31.1/console-tools/showkey.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/console-tools/showkey.c	2020-06-26 22:47:44.000000000 +0400
@@ -56,7 +56,7 @@ static void xset1(struct termios *t)
 {
 	int ret = tcsetattr(STDIN_FILENO, TCSAFLUSH, t);
 	if (ret) {
-		bb_perror_msg("can't tcsetattr for stdin");
+		bb_simple_perror_msg("can't tcsetattr for stdin");
 	}
 }
 
diff -urpN busybox-1.31.1/coreutils/chgrp.c busybox-1.32.0/coreutils/chgrp.c
--- busybox-1.31.1/coreutils/chgrp.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/chgrp.c	2020-06-26 22:47:44.000000000 +0400
@@ -21,15 +21,15 @@
 /* http://www.opengroup.org/onlinepubs/007904975/utilities/chgrp.html */
 
 //usage:#define chgrp_trivial_usage
-//usage:       "[-RhLHP"IF_DESKTOP("cvf")"]... GROUP FILE..."
+//usage:       "[-Rh"IF_DESKTOP("LHPcvf")"]... GROUP FILE..."
 //usage:#define chgrp_full_usage "\n\n"
 //usage:       "Change the group membership of each FILE to GROUP\n"
 //usage:     "\n	-R	Recurse"
 //usage:     "\n	-h	Affect symlinks instead of symlink targets"
+//usage:	IF_DESKTOP(
 //usage:     "\n	-L	Traverse all symlinks to directories"
 //usage:     "\n	-H	Traverse symlinks on command line only"
 //usage:     "\n	-P	Don't traverse symlinks (default)"
-//usage:	IF_DESKTOP(
 //usage:     "\n	-c	List changed files"
 //usage:     "\n	-v	Verbose"
 //usage:     "\n	-f	Hide errors"
diff -urpN busybox-1.31.1/coreutils/cp.c busybox-1.32.0/coreutils/cp.c
--- busybox-1.31.1/coreutils/cp.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/cp.c	2020-06-26 22:47:44.000000000 +0400
@@ -217,7 +217,7 @@ int cp_main(int argc, char **argv)
 		//	flags, FILEUTILS_RMDEST, OPT_parents);
 		if (flags & OPT_parents) {
 			if (!(d_flags & 2)) {
-				bb_error_msg_and_die("with --parents, the destination must be a directory");
+				bb_simple_error_msg_and_die("with --parents, the destination must be a directory");
 			}
 		}
 		if (flags & FILEUTILS_RMDEST) {
@@ -236,7 +236,7 @@ int cp_main(int argc, char **argv)
 			goto DO_COPY; /* NB: argc==2 -> *++argv==last */
 		}
 	} else if (flags & FILEUTILS_NO_TARGET_DIR) {
-		bb_error_msg_and_die("too many arguments");
+		bb_simple_error_msg_and_die("too many arguments");
 	}
 
 	while (1) {
diff -urpN busybox-1.31.1/coreutils/cut.c busybox-1.32.0/coreutils/cut.c
--- busybox-1.31.1/coreutils/cut.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/cut.c	2020-06-26 22:47:44.000000000 +0400
@@ -209,11 +209,11 @@ int cut_main(int argc UNUSED_PARAM, char
 //	argc -= optind;
 	argv += optind;
 	if (!(opt & (CUT_OPT_BYTE_FLGS | CUT_OPT_CHAR_FLGS | CUT_OPT_FIELDS_FLGS)))
-		bb_error_msg_and_die("expected a list of bytes, characters, or fields");
+		bb_simple_error_msg_and_die("expected a list of bytes, characters, or fields");
 
 	if (opt & CUT_OPT_DELIM_FLGS) {
 		if (ltok[0] && ltok[1]) { /* more than 1 char? */
-			bb_error_msg_and_die("the delimiter must be a single character");
+			bb_simple_error_msg_and_die("the delimiter must be a single character");
 		}
 		delim = ltok[0];
 	}
@@ -288,7 +288,7 @@ int cut_main(int argc UNUSED_PARAM, char
 
 		/* make sure we got some cut positions out of all that */
 		if (nlists == 0)
-			bb_error_msg_and_die("missing list of positions");
+			bb_simple_error_msg_and_die("missing list of positions");
 
 		/* now that the lists are parsed, we need to sort them to make life
 		 * easier on us when it comes time to print the chars / fields / lines
diff -urpN busybox-1.31.1/coreutils/date.c busybox-1.32.0/coreutils/date.c
--- busybox-1.31.1/coreutils/date.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/date.c	2020-06-26 22:47:44.000000000 +0400
@@ -33,10 +33,9 @@
 //config:	Enable option (-I) to output an ISO-8601 compliant
 //config:	date/time string.
 //config:
-//config:# defaults to "no": stat's nanosecond field is a bit non-portable
 //config:config FEATURE_DATE_NANO
 //config:	bool "Support %[num]N nanosecond format specifier"
-//config:	default n  # syscall(__NR_clock_gettime)
+//config:	default n # stat's nanosecond field is a bit non-portable
 //config:	depends on DATE
 //config:	select PLATFORM_LINUX
 //config:	help
@@ -272,13 +271,14 @@ int date_main(int argc UNUSED_PARAM, cha
 #endif
 	} else {
 #if ENABLE_FEATURE_DATE_NANO
-		/* libc has incredibly messy way of doing this,
-		 * typically requiring -lrt. We just skip all this mess */
-		syscall(__NR_clock_gettime, CLOCK_REALTIME, &ts);
+		clock_gettime(CLOCK_REALTIME, &ts);
 #else
 		time(&ts.tv_sec);
 #endif
 	}
+#if !ENABLE_FEATURE_DATE_NANO
+	ts.tv_nsec = 0;
+#endif
 	localtime_r(&ts.tv_sec, &tm_time);
 
 	/* If date string is given, update tm_time, and maybe set date */
@@ -301,10 +301,11 @@ int date_main(int argc UNUSED_PARAM, cha
 		if (date_str[0] != '@')
 			tm_time.tm_isdst = -1;
 		ts.tv_sec = validate_tm_time(date_str, &tm_time);
+		ts.tv_nsec = 0;
 
 		/* if setting time, set it */
-		if ((opt & OPT_SET) && stime(&ts.tv_sec) < 0) {
-			bb_perror_msg("can't set date");
+		if ((opt & OPT_SET) && clock_settime(CLOCK_REALTIME, &ts) < 0) {
+			bb_simple_perror_msg("can't set date");
 		}
 	}
 
diff -urpN busybox-1.31.1/coreutils/df.c busybox-1.32.0/coreutils/df.c
--- busybox-1.31.1/coreutils/df.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/df.c	2020-06-26 22:47:44.000000000 +0400
@@ -178,7 +178,7 @@ int df_main(int argc UNUSED_PARAM, char
 	if (!argv[0]) {
 		mount_table = setmntent(bb_path_mtab_file, "r");
 		if (!mount_table)
-			bb_perror_msg_and_die(bb_path_mtab_file);
+			bb_simple_perror_msg_and_die(bb_path_mtab_file);
 	}
 
 	while (1) {
diff -urpN busybox-1.31.1/coreutils/echo.c busybox-1.32.0/coreutils/echo.c
--- busybox-1.31.1/coreutils/echo.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/echo.c	2020-06-26 22:47:44.000000000 +0400
@@ -188,7 +188,7 @@ int echo_main(int argc UNUSED_PARAM, cha
 	/*r =*/ full_write(STDOUT_FILENO, buffer, out - buffer);
 	free(buffer);
 	if (/*WRONG:r < 0*/ errno) {
-		bb_perror_msg(bb_msg_write_error);
+		bb_simple_perror_msg(bb_msg_write_error);
 		return 1;
 	}
 	return 0;
diff -urpN busybox-1.31.1/coreutils/env.c busybox-1.32.0/coreutils/env.c
--- busybox-1.31.1/coreutils/env.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/env.c	2020-06-26 22:47:44.000000000 +0400
@@ -79,7 +79,7 @@ int env_main(int argc UNUSED_PARAM, char
 
 	while (*argv && (strchr(*argv, '=') != NULL)) {
 		if (putenv(*argv) < 0) {
-			bb_perror_msg_and_die("putenv");
+			bb_simple_perror_msg_and_die("putenv");
 		}
 		++argv;
 	}
diff -urpN busybox-1.31.1/coreutils/expand.c busybox-1.32.0/coreutils/expand.c
--- busybox-1.31.1/coreutils/expand.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/expand.c	2020-06-26 22:47:44.000000000 +0400
@@ -160,7 +160,7 @@ static void unexpand(FILE *file, unsigne
 					putchar('\t');
 			}
 
-			if ((opt & OPT_INITIAL) && ptr != line) {
+			if (!(opt & OPT_ALL) && ptr != line) {
 				printf("%*s%s", len, "", ptr);
 				break;
 			}
@@ -207,13 +207,13 @@ int expand_main(int argc UNUSED_PARAM, c
 				"ft:a"
 				"\0"
 				"ta" /* -t NUM sets -a */,
-				"first-only\0"       No_argument       "i"
+				"first-only\0"       No_argument       "f"
 				"tabs\0"             Required_argument "t"
 				"all\0"              No_argument       "a"
 				, &opt_t
 		);
-		/* -f --first-only is the default */
-		if (!(opt & OPT_ALL)) opt |= OPT_INITIAL;
+		/* -t implies -a, but an explicit -f overrides */
+		if (opt & OPT_INITIAL) opt &= ~OPT_ALL;
 	}
 	tab_size = xatou_range(opt_t, 1, UINT_MAX);
 
@@ -247,7 +247,7 @@ int expand_main(int argc UNUSED_PARAM, c
 	/* Now close stdin also */
 	/* (if we didn't read from it, it's a no-op) */
 	if (fclose(stdin))
-		bb_perror_msg_and_die(bb_msg_standard_input);
+		bb_simple_perror_msg_and_die(bb_msg_standard_input);
 
 	fflush_stdout_and_exit(exit_status);
 }
diff -urpN busybox-1.31.1/coreutils/expr.c busybox-1.32.0/coreutils/expr.c
--- busybox-1.31.1/coreutils/expr.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/expr.c	2020-06-26 22:47:44.000000000 +0400
@@ -249,7 +249,7 @@ static arith_t arithmetic_common(VALUE *
 	arith_t li, ri;
 
 	if (!toarith(l) || !toarith(r))
-		bb_error_msg_and_die("non-numeric argument");
+		bb_simple_error_msg_and_die("non-numeric argument");
 	li = l->u.i;
 	ri = r->u.i;
 	if (op == '+')
@@ -259,7 +259,7 @@ static arith_t arithmetic_common(VALUE *
 	if (op == '*')
 		return li * ri;
 	if (ri == 0)
-		bb_error_msg_and_die("division by zero");
+		bb_simple_error_msg_and_die("division by zero");
 	if (op == '/')
 		return li / ri;
 	return li % ri;
@@ -319,19 +319,19 @@ static VALUE *eval7(void)
 	VALUE *v;
 
 	if (!*G.args)
-		bb_error_msg_and_die("syntax error");
+		bb_simple_error_msg_and_die("syntax error");
 
 	if (nextarg("(")) {
 		G.args++;
 		v = eval();
 		if (!nextarg(")"))
-			bb_error_msg_and_die("syntax error");
+			bb_simple_error_msg_and_die("syntax error");
 		G.args++;
 		return v;
 	}
 
 	if (nextarg(")"))
-		bb_error_msg_and_die("syntax error");
+		bb_simple_error_msg_and_die("syntax error");
 
 	return str_value(*G.args++);
 }
@@ -353,7 +353,7 @@ static VALUE *eval6(void)
 	G.args++; /* We have a valid token, so get the next argument.  */
 	if (key == 1) { /* quote */
 		if (!*G.args)
-			bb_error_msg_and_die("syntax error");
+			bb_simple_error_msg_and_die("syntax error");
 		return str_value(*G.args++);
 	}
 	if (key == 2) { /* length */
@@ -546,11 +546,11 @@ int expr_main(int argc UNUSED_PARAM, cha
 	xfunc_error_retval = 2; /* coreutils compat */
 	G.args = argv + 1;
 	if (*G.args == NULL) {
-		bb_error_msg_and_die("too few arguments");
+		bb_simple_error_msg_and_die("too few arguments");
 	}
 	v = eval();
 	if (*G.args)
-		bb_error_msg_and_die("syntax error");
+		bb_simple_error_msg_and_die("syntax error");
 	if (v->type == INTEGER)
 		printf("%" PF_REZ "d\n", PF_REZ_TYPE v->u.i);
 	else
diff -urpN busybox-1.31.1/coreutils/id.c busybox-1.32.0/coreutils/id.c
--- busybox-1.31.1/coreutils/id.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/id.c	2020-06-26 22:47:44.000000000 +0400
@@ -231,7 +231,7 @@ int id_main(int argc UNUSED_PARAM, char
 			}
 		} else if (n < 0) { /* error in get_groups() */
 			if (ENABLE_DESKTOP)
-				bb_error_msg_and_die("can't get groups");
+				bb_simple_error_msg_and_die("can't get groups");
 			return EXIT_FAILURE;
 		}
 		if (ENABLE_FEATURE_CLEAN_UP)
diff -urpN busybox-1.31.1/coreutils/install.c busybox-1.32.0/coreutils/install.c
--- busybox-1.31.1/coreutils/install.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/install.c	2020-06-26 22:47:44.000000000 +0400
@@ -238,7 +238,7 @@ int install_main(int argc, char **argv)
 				args[2] = dest;
 				args[3] = NULL;
 				if (spawn_and_wait(args)) {
-					bb_perror_msg("strip");
+					bb_simple_perror_msg("strip");
 					ret = EXIT_FAILURE;
 				}
 			}
diff -urpN busybox-1.31.1/coreutils/ln.c busybox-1.32.0/coreutils/ln.c
--- busybox-1.31.1/coreutils/ln.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/ln.c	2020-06-26 22:47:44.000000000 +0400
@@ -41,7 +41,6 @@
 
 /* This is a NOEXEC applet. Be very careful! */
 
-
 #define LN_SYMLINK          (1 << 0)
 #define LN_FORCE            (1 << 1)
 #define LN_NODEREFERENCE    (1 << 2)
@@ -63,13 +62,28 @@ int ln_main(int argc, char **argv)
 	int (*link_func)(const char *, const char *);
 
 	opts = getopt32(argv, "^" "sfnbS:vT" "\0" "-1", &suffix);
-
+/*
+	-s, --symbolic		make symbolic links instead of hard links
+	-f, --force		remove existing destination files
+	-n, --no-dereference	treat LINK_NAME as a normal file if it is a symbolic link to a directory
+	-b			like --backup but does not accept an argument
+	--backup[=CONTROL]	make a backup of each existing destination file
+	-S, --suffix=SUFFIX	override the usual backup suffix
+	-v, --verbose
+	-T, --no-target-directory
+	-d, -F, --directory	allow the superuser to attempt to hard link directories
+	-i, --interactive	prompt whether to remove destinations
+	-L, --logical		dereference TARGETs that are symbolic links
+	-P, --physical		make hard links directly to symbolic links
+	-r, --relative		create symbolic links relative to link location
+	-t, --target-directory=DIRECTORY	specify the DIRECTORY in which to create the links
+ */
 	last = argv[argc - 1];
 	argv += optind;
 	argc -= optind;
 
 	if ((opts & LN_LINKFILE) && argc > 2) {
-		bb_error_msg_and_die("-T accepts 2 args max");
+		bb_simple_error_msg_and_die("-T accepts 2 args max");
 	}
 
 	if (!argv[1]) {
@@ -86,8 +100,11 @@ int ln_main(int argc, char **argv)
 		src = last;
 
 		if (is_directory(src,
-		                (opts & LN_NODEREFERENCE) ^ LN_NODEREFERENCE
-		                )
+				/*followlinks:*/ !(opts & (LN_NODEREFERENCE|LN_LINKFILE))
+				/* Why LN_LINKFILE does not follow links:
+				 * -T/--no-target-directory implies -n/--no-dereference
+				 */
+				)
 		) {
 			if (opts & LN_LINKFILE) {
 				bb_error_msg_and_die("'%s' is a directory", src);
diff -urpN busybox-1.31.1/coreutils/logname.c busybox-1.32.0/coreutils/logname.c
--- busybox-1.31.1/coreutils/logname.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/logname.c	2020-06-26 22:47:44.000000000 +0400
@@ -56,5 +56,5 @@ int logname_main(int argc UNUSED_PARAM,
 		return fflush_all();
 	}
 
-	bb_perror_msg_and_die("getlogin");
+	bb_simple_perror_msg_and_die("getlogin");
 }
diff -urpN busybox-1.31.1/coreutils/md5_sha1_sum.c busybox-1.32.0/coreutils/md5_sha1_sum.c
--- busybox-1.31.1/coreutils/md5_sha1_sum.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/md5_sha1_sum.c	2020-06-26 22:47:44.000000000 +0400
@@ -300,7 +300,7 @@ int md5_sha1_sum_main(int argc UNUSED_PA
 				}
 				if (filename_ptr == NULL) {
 					if (flags & FLAG_WARN) {
-						bb_error_msg("invalid format");
+						bb_simple_error_msg("invalid format");
 					}
 					count_failed++;
 					return_value = EXIT_FAILURE;
diff -urpN busybox-1.31.1/coreutils/od_bloaty.c busybox-1.32.0/coreutils/od_bloaty.c
--- busybox-1.31.1/coreutils/od_bloaty.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/od_bloaty.c	2020-06-26 22:47:44.000000000 +0400
@@ -536,7 +536,7 @@ check_and_close(void)
 	}
 
 	if (ferror(stdout)) {
-		bb_error_msg_and_die(bb_msg_write_error);
+		bb_simple_error_msg_and_die(bb_msg_write_error);
 	}
 }
 
@@ -841,7 +841,7 @@ skip(off_t n_skip)
 	}
 
 	if (n_skip)
-		bb_error_msg_and_die("can't skip past end of combined input");
+		bb_simple_error_msg_and_die("can't skip past end of combined input");
 }
 
 
@@ -1308,10 +1308,10 @@ int od_main(int argc UNUSED_PARAM, char
 					pseudo_start = o2;
 					argv[1] = NULL;
 				} else {
-					bb_error_msg_and_die("the last two arguments must be offsets");
+					bb_simple_error_msg_and_die("the last two arguments must be offsets");
 				}
 			} else { /* >3 args */
-				bb_error_msg_and_die("too many arguments");
+				bb_simple_error_msg_and_die("too many arguments");
 			}
 
 			if (pseudo_start >= 0) {
@@ -1332,7 +1332,7 @@ int od_main(int argc UNUSED_PARAM, char
 	if (option_mask32 & OPT_N) {
 		end_offset = n_bytes_to_skip + max_bytes_to_format;
 		if (end_offset < n_bytes_to_skip)
-			bb_error_msg_and_die("SKIP + SIZE is too large");
+			bb_simple_error_msg_and_die("SKIP + SIZE is too large");
 	}
 
 	if (G.n_specs == 0) {
@@ -1389,7 +1389,7 @@ int od_main(int argc UNUSED_PARAM, char
 		dump(n_bytes_to_skip, end_offset);
 
 	if (fclose(stdin))
-		bb_perror_msg_and_die(bb_msg_standard_input);
+		bb_simple_perror_msg_and_die(bb_msg_standard_input);
 
 	return G.exit_code;
 }
diff -urpN busybox-1.31.1/coreutils/paste.c busybox-1.32.0/coreutils/paste.c
--- busybox-1.31.1/coreutils/paste.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/paste.c	2020-06-26 22:47:44.000000000 +0400
@@ -116,7 +116,7 @@ int paste_main(int argc UNUSED_PARAM, ch
 
 	if (opt & PASTE_OPT_DELIMITERS) {
 		if (!delims[0])
-			bb_error_msg_and_die("-d '' is not supported");
+			bb_simple_error_msg_and_die("-d '' is not supported");
 		/* unknown mappings are not changed: "\z" -> '\\' 'z' */
 		/* trailing backslash, if any, is preserved */
 		del_cnt = strcpy_and_process_escape_sequences(delims, delims) - delims;
diff -urpN busybox-1.31.1/coreutils/printf.c busybox-1.32.0/coreutils/printf.c
--- busybox-1.31.1/coreutils/printf.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/printf.c	2020-06-26 22:47:44.000000000 +0400
@@ -430,7 +430,7 @@ int printf_main(int argc UNUSED_PARAM, c
 		if (ENABLE_ASH_PRINTF
 		 && applet_name[0] != 'p'
 		) {
-			bb_error_msg("usage: printf FORMAT [ARGUMENT...]");
+			bb_simple_error_msg("usage: printf FORMAT [ARGUMENT...]");
 			return 2; /* bash compat */
 		}
 		bb_show_usage();
diff -urpN busybox-1.31.1/coreutils/rm.c busybox-1.32.0/coreutils/rm.c
--- busybox-1.31.1/coreutils/rm.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/rm.c	2020-06-26 22:47:44.000000000 +0400
@@ -62,7 +62,7 @@ int rm_main(int argc UNUSED_PARAM, char
 			const char *base = bb_get_last_path_component_strip(*argv);
 
 			if (DOT_OR_DOTDOT(base)) {
-				bb_error_msg("can't remove '.' or '..'");
+				bb_simple_error_msg("can't remove '.' or '..'");
 			} else if (remove_file(*argv, flags) >= 0) {
 				continue;
 			}
diff -urpN busybox-1.31.1/coreutils/sort.c busybox-1.32.0/coreutils/sort.c
--- busybox-1.31.1/coreutils/sort.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/sort.c	2020-06-26 22:47:44.000000000 +0400
@@ -277,7 +277,7 @@ static int compare_keys(const void *xarg
 		/* Perform actual comparison */
 		switch (flags & (FLAG_n | FLAG_g | FLAG_M | FLAG_V)) {
 		default:
-			bb_error_msg_and_die("unknown sort type");
+			bb_simple_error_msg_and_die("unknown sort type");
 			break;
 #if defined(HAVE_STRVERSCMP) && HAVE_STRVERSCMP == 1
 		case FLAG_V:
@@ -398,10 +398,10 @@ static unsigned str2u(char **str)
 {
 	unsigned long lu;
 	if (!isdigit((*str)[0]))
-		bb_error_msg_and_die("bad field specification");
+		bb_simple_error_msg_and_die("bad field specification");
 	lu = strtoul(*str, str, 10);
 	if ((sizeof(long) > sizeof(int) && lu > INT_MAX) || !lu)
-		bb_error_msg_and_die("bad field specification");
+		bb_simple_error_msg_and_die("bad field specification");
 	return lu;
 }
 #endif
@@ -461,7 +461,7 @@ int sort_main(int argc UNUSED_PARAM, cha
 #if ENABLE_FEATURE_SORT_BIG
 	if (opts & FLAG_t) {
 		if (!str_t[0] || str_t[1])
-			bb_error_msg_and_die("bad -t parameter");
+			bb_simple_error_msg_and_die("bad -t parameter");
 		key_separator = str_t[0];
 	}
 	/* note: below this point we use option_mask32, not opts,
@@ -504,10 +504,10 @@ int sort_main(int argc UNUSED_PARAM, cha
 					because comma isn't in OPT_STR */
 				idx = strchr(OPT_STR, *str_k);
 				if (!idx)
-					bb_error_msg_and_die("unknown key option");
+					bb_simple_error_msg_and_die("unknown key option");
 				flag = 1 << (idx - OPT_STR);
 				if (flag & ~FLAG_allowed_for_k)
-					bb_error_msg_and_die("unknown sort type");
+					bb_simple_error_msg_and_die("unknown sort type");
 				/* b after ',' means strip _trailing_ space */
 				if (i && flag == FLAG_b)
 					flag = FLAG_bb;
diff -urpN busybox-1.31.1/coreutils/split.c busybox-1.32.0/coreutils/split.c
--- busybox-1.31.1/coreutils/split.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/split.c	2020-06-26 22:47:44.000000000 +0400
@@ -127,7 +127,7 @@ int split_main(int argc UNUSED_PARAM, ch
 	}
 
 	if (NAME_MAX < strlen(sfx) + suffix_len)
-		bb_error_msg_and_die("suffix too long");
+		bb_simple_error_msg_and_die("suffix too long");
 
 	{
 		char *char_p = xzalloc(suffix_len + 1);
@@ -147,7 +147,7 @@ int split_main(int argc UNUSED_PARAM, ch
 		do {
 			if (!remaining) {
 				if (!pfx)
-					bb_error_msg_and_die("suffixes exhausted");
+					bb_simple_error_msg_and_die("suffixes exhausted");
 				xmove_fd(xopen(pfx, O_WRONLY | O_CREAT | O_TRUNC), 1);
 				pfx = next_file(pfx, suffix_len);
 				remaining = cnt;
diff -urpN busybox-1.31.1/coreutils/stat.c busybox-1.32.0/coreutils/stat.c
--- busybox-1.31.1/coreutils/stat.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/stat.c	2020-06-26 22:47:44.000000000 +0400
@@ -150,20 +150,16 @@ static const char *file_type(const struc
 	return "weird file";
 }
 
-static const char *human_time(time_t t)
+static const char *human_time(struct timespec *ts)
 {
-	/* Old
-	static char *str;
-	str = ctime(&t);
-	str[strlen(str)-1] = '\0';
-	return str;
-	*/
-	/* coreutils 6.3 compat: */
+	char fmt[sizeof("%Y-%m-%d %H:%M:%S.123456789 %z") + /*paranoia*/ 8];
 
-	/*static char buf[sizeof("YYYY-MM-DD HH:MM:SS.000000000")] ALIGN1;*/
+	/* coreutils 6.3 compat */
 #define buf bb_common_bufsiz1
 	setup_common_bufsiz();
-	strcpy(strftime_YYYYMMDDHHMMSS(buf, COMMON_BUFSIZE, &t), ".000000000");
+
+	sprintf(stpcpy(fmt, "%Y-%m-%d %H:%M:%S"), ".%09u %%z", (unsigned)ts->tv_nsec);
+	strftime(buf, COMMON_BUFSIZE, fmt, localtime(&ts->tv_sec));
 	return buf;
 #undef buf
 }
@@ -384,19 +380,19 @@ static void FAST_FUNC print_stat(char *p
 		strcat(pformat, "lu");
 		printf(pformat, (unsigned long) statbuf->st_blksize);
 	} else if (m == 'x') {
-		printfs(pformat, human_time(statbuf->st_atime));
+		printfs(pformat, human_time(&statbuf->st_atim));
 	} else if (m == 'X') {
 		strcat(pformat, TYPE_SIGNED(time_t) ? "ld" : "lu");
 		/* note: (unsigned long) would be wrong:
 		 * imagine (unsigned long64)int32 */
 		printf(pformat, (long) statbuf->st_atime);
 	} else if (m == 'y') {
-		printfs(pformat, human_time(statbuf->st_mtime));
+		printfs(pformat, human_time(&statbuf->st_mtim));
 	} else if (m == 'Y') {
 		strcat(pformat, TYPE_SIGNED(time_t) ? "ld" : "lu");
 		printf(pformat, (long) statbuf->st_mtime);
 	} else if (m == 'z') {
-		printfs(pformat, human_time(statbuf->st_ctime));
+		printfs(pformat, human_time(&statbuf->st_ctim));
 	} else if (m == 'Z') {
 		strcat(pformat, TYPE_SIGNED(time_t) ? "ld" : "lu");
 		printf(pformat, (long) statbuf->st_ctime);
@@ -501,7 +497,7 @@ static bool do_statfs(const char *filena
 	if (format == NULL) {
 # if !ENABLE_SELINUX
 		format = (option_mask32 & OPT_TERSE
-			? "%n %i %l %t %s %b %f %a %c %d\n"
+			? "%n %i %l %t %s %b %f %a %c %d"
 			: "  File: \"%n\"\n"
 			  "    ID: %-8i Namelen: %-7l Type: %T\n"
 			  "Block size: %-10s\n"
@@ -509,25 +505,26 @@ static bool do_statfs(const char *filena
 			  "Inodes: Total: %-10c Free: %d");
 # else
 		format = (option_mask32 & OPT_TERSE
-			? (option_mask32 & OPT_SELINUX ? "%n %i %l %t %s %b %f %a %c %d %C\n":
-			"%n %i %l %t %s %b %f %a %c %d\n")
-			: (option_mask32 & OPT_SELINUX ?
-			"  File: \"%n\"\n"
-			"    ID: %-8i Namelen: %-7l Type: %T\n"
-			"Block size: %-10s\n"
-			"Blocks: Total: %-10b Free: %-10f Available: %a\n"
-			"Inodes: Total: %-10c Free: %d"
-			"  S_context: %C\n":
-			"  File: \"%n\"\n"
-			"    ID: %-8i Namelen: %-7l Type: %T\n"
-			"Block size: %-10s\n"
-			"Blocks: Total: %-10b Free: %-10f Available: %a\n"
-			"Inodes: Total: %-10c Free: %d\n")
+			? (option_mask32 & OPT_SELINUX
+				? "%n %i %l %t %s %b %f %a %c %d %C"
+				: "%n %i %l %t %s %b %f %a %c %d")
+			: (option_mask32 & OPT_SELINUX
+				? "  File: \"%n\"\n"
+				"    ID: %-8i Namelen: %-7l Type: %T\n"
+				"Block size: %-10s\n"
+				"Blocks: Total: %-10b Free: %-10f Available: %a\n"
+				"Inodes: Total: %-10c Free: %d"
+				"  S_context: %C"
+				: "  File: \"%n\"\n"
+				"    ID: %-8i Namelen: %-7l Type: %T\n"
+				"Block size: %-10s\n"
+				"Blocks: Total: %-10b Free: %-10f Available: %a\n"
+				"Inodes: Total: %-10c Free: %d")
 			);
 # endif /* SELINUX */
 	}
 	print_it(format, filename, print_statfs, &statfsbuf IF_SELINUX(, scontext));
-#else /* FEATURE_STAT_FORMAT */
+#else /* !FEATURE_STAT_FORMAT */
 	format = (option_mask32 & OPT_TERSE
 		? "%s %llx %lu "
 		: "  File: \"%s\"\n"
@@ -624,14 +621,14 @@ static bool do_stat(const char *filename
 					"Device: %Dh/%dd\tInode: %-10i  Links: %-5h"
 					" Device type: %t,%T\n"
 					"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
-					"Access: %x\n" "Modify: %y\n" "Change: %z\n";
+					"Access: %x\n" "Modify: %y\n" "Change: %z";
 			} else {
 				format =
 					"  File: %N\n"
 					"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
 					"Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
 					"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
-					"Access: %x\n" "Modify: %y\n" "Change: %z\n";
+					"Access: %x\n" "Modify: %y\n" "Change: %z";
 			}
 		}
 # else
@@ -650,14 +647,14 @@ static bool do_stat(const char *filename
 					" Device type: %t,%T\n"
 					"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
 					"   S_Context: %C\n"
-					"Access: %x\n" "Modify: %y\n" "Change: %z\n"
+					"Access: %x\n" "Modify: %y\n" "Change: %z"
 					:
 					"  File: %N\n"
 					"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
 					"Device: %Dh/%dd\tInode: %-10i  Links: %-5h"
 					" Device type: %t,%T\n"
 					"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
-					"Access: %x\n" "Modify: %y\n" "Change: %z\n"
+					"Access: %x\n" "Modify: %y\n" "Change: %z"
 					);
 			} else {
 				format = (option_mask32 & OPT_SELINUX ?
@@ -666,13 +663,13 @@ static bool do_stat(const char *filename
 					"Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
 					"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
 					"S_Context: %C\n"
-					"Access: %x\n" "Modify: %y\n" "Change: %z\n"
+					"Access: %x\n" "Modify: %y\n" "Change: %z"
 					:
 					"  File: %N\n"
 					"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
 					"Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
 					"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
-					"Access: %x\n" "Modify: %y\n" "Change: %z\n"
+					"Access: %x\n" "Modify: %y\n" "Change: %z"
 					);
 			}
 		}
@@ -749,9 +746,9 @@ static bool do_stat(const char *filename
 		if (option_mask32 & OPT_SELINUX)
 			printf("   S_Context: %s\n", scontext);
 # endif
-		printf("Access: %s\n", human_time(statbuf.st_atime));
-		printf("Modify: %s\n", human_time(statbuf.st_mtime));
-		printf("Change: %s\n", human_time(statbuf.st_ctime));
+		printf("Access: %s\n", human_time(&statbuf.st_atim));
+		printf("Modify: %s\n", human_time(&statbuf.st_mtim));
+		printf("Change: %s\n", human_time(&statbuf.st_ctim));
 	}
 #endif  /* FEATURE_STAT_FORMAT */
 	return 1;
diff -urpN busybox-1.31.1/coreutils/stty.c busybox-1.32.0/coreutils/stty.c
--- busybox-1.31.1/coreutils/stty.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/stty.c	2020-06-26 22:47:44.000000000 +0400
@@ -1320,7 +1320,7 @@ int stty_main(int argc UNUSED_PARAM, cha
 					break;
 				case 'F':
 					if (file_name)
-						bb_error_msg_and_die("only one device may be specified");
+						bb_simple_error_msg_and_die("only one device may be specified");
 					file_name = &arg[i+1]; /* "-Fdevice" ? */
 					if (!file_name[0]) { /* nope, "-F device" */
 						int p = k+1; /* argv[p] is argnext */
@@ -1405,13 +1405,13 @@ int stty_main(int argc UNUSED_PARAM, cha
 	if ((stty_state & (STTY_verbose_output | STTY_recoverable_output)) ==
 		(STTY_verbose_output | STTY_recoverable_output)
 	) {
-		bb_error_msg_and_die("-a and -g are mutually exclusive");
+		bb_simple_error_msg_and_die("-a and -g are mutually exclusive");
 	}
 	/* Specifying -a or -g with non-options is an error */
 	if ((stty_state & (STTY_verbose_output | STTY_recoverable_output))
 	 && !(stty_state & STTY_noargs)
 	) {
-		bb_error_msg_and_die("modes may not be set when -a or -g is used");
+		bb_simple_error_msg_and_die("modes may not be set when -a or -g is used");
 	}
 
 	/* Now it is safe to start doing things */
diff -urpN busybox-1.31.1/coreutils/tail.c busybox-1.32.0/coreutils/tail.c
--- busybox-1.31.1/coreutils/tail.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/tail.c	2020-06-26 22:47:44.000000000 +0400
@@ -89,7 +89,7 @@ static ssize_t tail_read(int fd, char *b
 
 	r = full_read(fd, buf, count);
 	if (r < 0) {
-		bb_perror_msg(bb_msg_read_error);
+		bb_simple_perror_msg(bb_msg_read_error);
 		G.exitcode = EXIT_FAILURE;
 	}
 
@@ -186,7 +186,7 @@ int tail_main(int argc, char **argv)
 	} while (++i < argc);
 
 	if (!nfiles)
-		bb_error_msg_and_die("no files");
+		bb_simple_error_msg_and_die("no files");
 
 	/* prepare the buffer */
 	tailbufsize = BUFSIZ;
diff -urpN busybox-1.31.1/coreutils/tee.c busybox-1.32.0/coreutils/tee.c
--- busybox-1.31.1/coreutils/tee.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/tee.c	2020-06-26 22:47:44.000000000 +0400
@@ -39,6 +39,19 @@
 //usage:       "$ cat /tmp/foo\n"
 //usage:       "Hello\n"
 
+// Bare "tee" with no below options does not install SIGPIPE handler - just dies on it.
+// TODO:
+//	--output-error[=MODE]
+//		'warn'		diagnose errors writing to any output
+//		'warn-nopipe'	diagnose errors writing to any output not a pipe
+//		'exit'		exit on error writing to any output
+//		'exit-nopipe'	exit on error writing to any output not a pipe
+// ^^^ all of these should set SIGPIPE to SIG_IGN.
+// Because "exit" mode should print error message and exit1(1) - not die on SIGPIPE.
+// "exit-nopipe" does not exit on EPIPE and does not set exitcode to 1 too.
+//	-p	diagnose errors writing to non pipes
+// ^^^^ this should set SIGPIPE to SIG_IGN. EPIPE is ignored (same as "warn-nopipe")
+
 #include "libbb.h"
 #include "common_bufsiz.h"
 
@@ -66,12 +79,12 @@ int tee_main(int argc, char **argv)
 	mode += (retval & 2);	/* Since 'a' is the 2nd option... */
 
 	if (retval & 1) {
-		signal(SIGINT, SIG_IGN); /* TODO - switch to sigaction. (why?) */
+		signal(SIGINT, SIG_IGN);
 	}
 	retval = EXIT_SUCCESS;
-	/* gnu tee ignores SIGPIPE in case one of the output files is a pipe
-	 * that doesn't consume all its input.  Good idea... */
-	signal(SIGPIPE, SIG_IGN);
+	/* if (opt_p || opt_output_error)
+		signal(SIGPIPE, SIG_IGN);
+	 */
 
 	/* Allocate an array of FILE *'s, with one extra for a sentinel. */
 	fp = files = xzalloc(sizeof(FILE *) * (argc + 2));
@@ -79,6 +92,7 @@ int tee_main(int argc, char **argv)
 
 	files[0] = stdout;
 	goto GOT_NEW_FILE;
+
 	do {
 		*fp = stdout;
 		if (NOT_LONE_DASH(*argv)) {
@@ -102,6 +116,7 @@ int tee_main(int argc, char **argv)
 		fp = files;
 		do
 			fwrite(buf, 1, c, *fp);
+			/* if (opt_p && fwrite() != c && !EPIPE) bb_error_msg("..."); */
 		while (*++fp);
 	}
 	if (c < 0) {		/* Make sure read errors are signaled. */
@@ -113,6 +128,7 @@ int tee_main(int argc, char **argv)
 		fp = files;
 		do
 			putc(c, *fp);
+			/* if (opt_p && putc() == EOF && !EPIPE) bb_error_msg("..."); */
 		while (*++fp);
 	}
 #endif
diff -urpN busybox-1.31.1/coreutils/test.c busybox-1.32.0/coreutils/test.c
--- busybox-1.31.1/coreutils/test.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/test.c	2020-06-26 22:47:44.000000000 +0400
@@ -411,7 +411,7 @@ extern struct test_statics *const test_p
 #define leaving         (S.leaving      )
 
 #define INIT_S() do { \
-	(*(struct test_statics**)&test_ptr_to_statics) = xzalloc(sizeof(S)); \
+	(*(struct test_statics**)not_const_pp(&test_ptr_to_statics)) = xzalloc(sizeof(S)); \
 	barrier(); \
 } while (0)
 #define DEINIT_S() do { \
@@ -832,12 +832,12 @@ int test_main(int argc, char **argv)
 		--argc;
 		if (!arg0[1]) { /* "[" ? */
 			if (NOT_LONE_CHAR(argv[argc], ']')) {
-				bb_error_msg("missing ]");
+				bb_simple_error_msg("missing ]");
 				return 2;
 			}
 		} else { /* assuming "[[" */
 			if (strcmp(argv[argc], "]]") != 0) {
-				bb_error_msg("missing ]]");
+				bb_simple_error_msg("missing ]]");
 				return 2;
 			}
 		}
diff -urpN busybox-1.31.1/coreutils/tr.c busybox-1.32.0/coreutils/tr.c
--- busybox-1.31.1/coreutils/tr.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/tr.c	2020-06-26 22:47:44.000000000 +0400
@@ -308,7 +308,7 @@ int tr_main(int argc UNUSED_PARAM, char
 		str1_length = complement(str1, str1_length);
 	if (*argv) {
 		if (argv[0][0] == '\0')
-			bb_error_msg_and_die("STRING2 cannot be empty");
+			bb_simple_error_msg_and_die("STRING2 cannot be empty");
 		str2_length = expand(*argv, &str2);
 		map(vector, str1, str1_length,
 				str2, str2_length);
@@ -333,7 +333,7 @@ int tr_main(int argc UNUSED_PARAM, char
 			read_chars = safe_read(STDIN_FILENO, str1, TR_BUFSIZ);
 			if (read_chars <= 0) {
 				if (read_chars < 0)
-					bb_perror_msg_and_die(bb_msg_read_error);
+					bb_simple_perror_msg_and_die(bb_msg_read_error);
 				break;
 			}
 			in_index = 0;
diff -urpN busybox-1.31.1/coreutils/uudecode.c busybox-1.32.0/coreutils/uudecode.c
--- busybox-1.31.1/coreutils/uudecode.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/uudecode.c	2020-06-26 22:47:44.000000000 +0400
@@ -82,7 +82,7 @@ static void FAST_FUNC read_stduu(FILE *s
 			continue;
 		}
 		if (encoded_len > 60) {
-			bb_error_msg_and_die("line too long");
+			bb_simple_error_msg_and_die("line too long");
 		}
 
 		dst = line;
@@ -108,7 +108,7 @@ static void FAST_FUNC read_stduu(FILE *s
 		fwrite(line, 1, dst - line, dst_stream);
 		free(line);
 	}
-	bb_error_msg_and_die("short file");
+	bb_simple_error_msg_and_die("short file");
 }
 #endif
 
@@ -166,7 +166,7 @@ int uudecode_main(int argc UNUSED_PARAM,
 		/* fclose_if_not_stdin(src_stream); - redundant */
 		return EXIT_SUCCESS;
 	}
-	bb_error_msg_and_die("no 'begin' line");
+	bb_simple_error_msg_and_die("no 'begin' line");
 }
 #endif
 
@@ -216,7 +216,7 @@ int base64_main(int argc UNUSED_PARAM, c
 			if (!size)
 				break;
 			if ((ssize_t)size < 0)
-				bb_perror_msg_and_die(bb_msg_read_error);
+				bb_simple_perror_msg_and_die(bb_msg_read_error);
 			/* Encode the buffer we just read in */
 			bb_uuencode(dst_buf, src_buf, size, bb_uuenc_tbl_base64);
 			xwrite(STDOUT_FILENO, dst_buf, 4 * ((size + 2) / 3));
diff -urpN busybox-1.31.1/coreutils/uuencode.c busybox-1.32.0/coreutils/uuencode.c
--- busybox-1.31.1/coreutils/uuencode.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/coreutils/uuencode.c	2020-06-26 22:47:44.000000000 +0400
@@ -66,7 +66,7 @@ int uuencode_main(int argc UNUSED_PARAM,
 		if (!size)
 			break;
 		if ((ssize_t)size < 0)
-			bb_perror_msg_and_die(bb_msg_read_error);
+			bb_simple_perror_msg_and_die(bb_msg_read_error);
 		/* Encode the buffer we just read in */
 		bb_uuencode(dst_buf, src_buf, size, tbl);
 		bb_putchar('\n');
diff -urpN busybox-1.31.1/debianutils/start_stop_daemon.c busybox-1.32.0/debianutils/start_stop_daemon.c
--- busybox-1.31.1/debianutils/start_stop_daemon.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/debianutils/start_stop_daemon.c	2020-06-26 22:47:44.000000000 +0400
@@ -317,7 +317,7 @@ static void do_procinit(void)
 	}
 	closedir(procdir);
 	if (!pid)
-		bb_error_msg_and_die("nothing in /proc - not mounted?");
+		bb_simple_error_msg_and_die("nothing in /proc - not mounted?");
 }
 
 static int do_stop(void)
@@ -337,7 +337,7 @@ static int do_stop(void)
 	} else if (userspec) {
 		what = xasprintf("process(es) owned by '%s'", userspec);
 	} else {
-		bb_error_msg_and_die("internal error, please report");
+		bb_simple_error_msg_and_die("internal error, please report");
 	}
 
 	if (!G.found_procs) {
diff -urpN busybox-1.31.1/e2fsprogs/chattr.c busybox-1.32.0/e2fsprogs/chattr.c
--- busybox-1.31.1/e2fsprogs/chattr.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/e2fsprogs/chattr.c	2020-06-26 22:47:44.000000000 +0400
@@ -196,11 +196,11 @@ int chattr_main(int argc UNUSED_PARAM, c
 
 	/* run sanity checks on all the arguments given us */
 	if ((g.flags & OPT_SET) && (g.flags & (OPT_ADD|OPT_REM)))
-		bb_error_msg_and_die("= is incompatible with - and +");
+		bb_simple_error_msg_and_die("= is incompatible with - and +");
 	if (g.rf & g.af)
-		bb_error_msg_and_die("can't set and unset a flag");
+		bb_simple_error_msg_and_die("can't set and unset a flag");
 	if (!g.flags)
-		bb_error_msg_and_die("must use '-v', =, - or +");
+		bb_simple_error_msg_and_die("must use '-v', =, - or +");
 
 	/* now run chattr on all the files passed to us */
 	do change_attributes(*argv, &g); while (*++argv);
diff -urpN busybox-1.31.1/e2fsprogs/fsck.c busybox-1.32.0/e2fsprogs/fsck.c
--- busybox-1.31.1/e2fsprogs/fsck.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/e2fsprogs/fsck.c	2020-06-26 22:47:44.000000000 +0400
@@ -431,10 +431,10 @@ static int wait_one(int flags)
 			if (errno == EINTR)
 				continue;
 			if (errno == ECHILD) { /* paranoia */
-				bb_error_msg("wait: no more children");
+				bb_simple_error_msg("wait: no more children");
 				return -1;
 			}
-			bb_perror_msg("wait");
+			bb_simple_perror_msg("wait");
 			continue;
 		}
 		prev = NULL;
@@ -919,7 +919,7 @@ static void compile_fs_type(char *fs_typ
 			if (G.fs_type_negated == -1)
 				G.fs_type_negated = negate;
 			if (G.fs_type_negated != negate)
-				bb_error_msg_and_die(
+				bb_simple_error_msg_and_die(
 "either all or none of the filesystem types passed to -t must be prefixed "
 "with 'no' or '!'");
 		}
diff -urpN busybox-1.31.1/editors/awk.c busybox-1.32.0/editors/awk.c
--- busybox-1.31.1/editors/awk.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/editors/awk.c	2020-06-26 22:47:44.000000000 +0400
@@ -272,7 +272,8 @@ typedef struct tsplitter_s {
 /* if previous token class is CONCAT1 and next is CONCAT2, concatenation */
 /* operator is inserted between them */
 #define	TC_CONCAT1 (TC_VARIABLE | TC_ARRTERM | TC_SEQTERM \
-                   | TC_STRING | TC_NUMBER | TC_UOPPOST)
+                   | TC_STRING | TC_NUMBER | TC_UOPPOST \
+                   | TC_LENGTH)
 #define	TC_CONCAT2 (TC_OPERAND | TC_UOPPRE)
 
 #define	OF_RES1     0x010000
@@ -1070,8 +1071,10 @@ static uint32_t next_token(uint32_t expe
 	const uint32_t *ti;
 
 	if (t_rollback) {
+		debug_printf_parse("%s: using rolled-back token\n", __func__);
 		t_rollback = FALSE;
 	} else if (concat_inserted) {
+		debug_printf_parse("%s: using concat-inserted token\n", __func__);
 		concat_inserted = FALSE;
 		t_tclass = save_tclass;
 		t_info = save_info;
@@ -1200,7 +1203,11 @@ static uint32_t next_token(uint32_t expe
 			goto readnext;
 
 		/* insert concatenation operator when needed */
-		if ((ltclass & TC_CONCAT1) && (tc & TC_CONCAT2) && (expected & TC_BINOP)) {
+		debug_printf_parse("%s: %x %x %x concat_inserted?\n", __func__,
+			(ltclass & TC_CONCAT1), (tc & TC_CONCAT2), (expected & TC_BINOP));
+		if ((ltclass & TC_CONCAT1) && (tc & TC_CONCAT2) && (expected & TC_BINOP)
+		 && !(ltclass == TC_LENGTH && tc == TC_SEQSTART) /* but not for "length(..." */
+		) {
 			concat_inserted = TRUE;
 			save_tclass = tc;
 			save_info = t_info;
@@ -1208,6 +1215,7 @@ static uint32_t next_token(uint32_t expe
 			t_info = OC_CONCAT | SS | P(35);
 		}
 
+		debug_printf_parse("%s: t_tclass=tc=%x\n", __func__, t_tclass);
 		t_tclass = tc;
 	}
 	ltclass = t_tclass;
@@ -1218,6 +1226,7 @@ static uint32_t next_token(uint32_t expe
 				EMSG_UNEXP_EOS : EMSG_UNEXP_TOKEN);
 	}
 
+	debug_printf_parse("%s: returning, ltclass:%x t_double:%f\n", __func__, ltclass, t_double);
 	return ltclass;
 #undef concat_inserted
 #undef save_tclass
@@ -1282,7 +1291,7 @@ static node *parse_expr(uint32_t iexp)
 			glptr = NULL;
 
 		} else if (tc & (TC_BINOP | TC_UOPPOST)) {
-			debug_printf_parse("%s: TC_BINOP | TC_UOPPOST\n", __func__);
+			debug_printf_parse("%s: TC_BINOP | TC_UOPPOST tc:%x\n", __func__, tc);
 			/* for binary and postfix-unary operators, jump back over
 			 * previous operators with higher priority */
 			vn = cn;
@@ -1350,8 +1359,10 @@ static node *parse_expr(uint32_t iexp)
 					v = cn->l.v = xzalloc(sizeof(var));
 					if (tc & TC_NUMBER)
 						setvar_i(v, t_double);
-					else
+					else {
 						setvar_s(v, t_string);
+						xtc &= ~TC_UOPPOST; /* "str"++ is not allowed */
+					}
 					break;
 
 				case TC_REGEXP:
@@ -1387,7 +1398,12 @@ static node *parse_expr(uint32_t iexp)
 
 				case TC_LENGTH:
 					debug_printf_parse("%s: TC_LENGTH\n", __func__);
-					next_token(TC_SEQSTART | TC_OPTERM | TC_GRPTERM);
+					next_token(TC_SEQSTART /* length(...) */
+						| TC_OPTERM    /* length; (or newline)*/
+						| TC_GRPTERM   /* length } */
+						| TC_BINOPX    /* length <op> NUM */
+						| TC_COMMA     /* print length, 1 */
+					);
 					rollback_token();
 					if (t_tclass & TC_SEQSTART) {
 						/* It was a "(" token. Handle just like TC_BUILTIN */
@@ -2633,7 +2649,7 @@ static var *evaluate(node *op, var *res)
 					if (opn == '|') {
 						rsm->F = popen(R.s, "w");
 						if (rsm->F == NULL)
-							bb_perror_msg_and_die("popen");
+							bb_simple_perror_msg_and_die("popen");
 						rsm->is_pipe = 1;
 					} else {
 						rsm->F = xfopen(R.s, opn=='w' ? "w" : "a");
@@ -3246,7 +3262,7 @@ int awk_main(int argc UNUSED_PARAM, char
 	argv += optind;
 	//argc -= optind;
 	if (opt & OPT_W)
-		bb_error_msg("warning: option -W is ignored");
+		bb_simple_error_msg("warning: option -W is ignored");
 	if (opt & OPT_F) {
 		unescape_string_in_place(opt_F);
 		setvar_s(intvar[FS], opt_F);
diff -urpN busybox-1.31.1/editors/diff.c busybox-1.32.0/editors/diff.c
--- busybox-1.31.1/editors/diff.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/editors/diff.c	2020-06-26 22:47:44.000000000 +0400
@@ -1006,7 +1006,7 @@ int diff_main(int argc UNUSED_PARAM, cha
 	xfunc_error_retval = 1;
 
 	if (gotstdin && (S_ISDIR(stb[0].st_mode) || S_ISDIR(stb[1].st_mode)))
-		bb_error_msg_and_die("can't compare stdin to a directory");
+		bb_simple_error_msg_and_die("can't compare stdin to a directory");
 
 	/* Compare metadata to check if the files are the same physical file.
 	 *
@@ -1037,7 +1037,7 @@ int diff_main(int argc UNUSED_PARAM, cha
 #if ENABLE_FEATURE_DIFF_DIR
 		diffdir(file, s_start);
 #else
-		bb_error_msg_and_die("no support for directory comparison");
+		bb_simple_error_msg_and_die("no support for directory comparison");
 #endif
 	} else {
 		bool dirfile = S_ISDIR(stb[0].st_mode) || S_ISDIR(stb[1].st_mode);
diff -urpN busybox-1.31.1/editors/ed.c busybox-1.32.0/editors/ed.c
--- busybox-1.31.1/editors/ed.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/editors/ed.c	2020-06-26 22:47:44.000000000 +0400
@@ -165,7 +165,7 @@ static NOINLINE int searchLines(const ch
 
 	if (*str == '\0') {
 		if (searchString[0] == '\0') {
-			bb_error_msg("no previous search string");
+			bb_simple_error_msg("no previous search string");
 			return 0;
 		}
 		str = searchString;
@@ -228,7 +228,7 @@ static const char* getNum(const char *cp
 			case '\'':
 				cp++;
 				if ((unsigned)(*cp - 'a') >= 26) {
-					bb_error_msg("bad mark name");
+					bb_simple_error_msg("bad mark name");
 					return NULL;
 				}
 				haveNum = TRUE;
@@ -314,7 +314,7 @@ static int insertLine(int num, const cha
 	LINE *newLp, *lp;
 
 	if ((num < 1) || (num > lastNum + 1)) {
-		bb_error_msg("inserting at bad line number");
+		bb_simple_error_msg("inserting at bad line number");
 		return FALSE;
 	}
 
@@ -384,7 +384,7 @@ static int readLines(const char *file, i
 	char *cp;
 
 	if ((num < 1) || (num > lastNum + 1)) {
-		bb_error_msg("bad line for read");
+		bb_simple_error_msg("bad line for read");
 		return FALSE;
 	}
 
@@ -629,7 +629,7 @@ static void subCommand(const char *cmd,
 	cp = buf;
 
 	if (isblank(*cp) || (*cp == '\0')) {
-		bb_error_msg("bad delimiter for substitute");
+		bb_simple_error_msg("bad delimiter for substitute");
 		return;
 	}
 
@@ -638,7 +638,7 @@ static void subCommand(const char *cmd,
 
 	cp = strchr(cp, delim);
 	if (cp == NULL) {
-		bb_error_msg("missing 2nd delimiter for substitute");
+		bb_simple_error_msg("missing 2nd delimiter for substitute");
 		return;
 	}
 
@@ -660,13 +660,13 @@ static void subCommand(const char *cmd,
 			printFlag = TRUE;
 			break;
 		default:
-			bb_error_msg("unknown option for substitute");
+			bb_simple_error_msg("unknown option for substitute");
 			return;
 	}
 
 	if (*oldStr == '\0') {
 		if (searchString[0] == '\0') {
-			bb_error_msg("no previous search string");
+			bb_simple_error_msg("no previous search string");
 			return;
 		}
 		oldStr = searchString;
@@ -846,7 +846,7 @@ static void doCommands(void)
 
 		case 'f':
 			if (*cp != '\0' && *cp != ' ') {
-				bb_error_msg("bad file command");
+				bb_simple_error_msg("bad file command");
 				break;
 			}
 			cp = skip_whitespace(cp);
@@ -870,7 +870,7 @@ static void doCommands(void)
 		case 'k':
 			cp = skip_whitespace(cp);
 			if ((unsigned)(*cp - 'a') >= 26 || cp[1]) {
-				bb_error_msg("bad mark name");
+				bb_simple_error_msg("bad mark name");
 				break;
 			}
 			marks[(unsigned)(*cp - 'a')] = num2;
@@ -887,7 +887,7 @@ static void doCommands(void)
 		case 'q':
 			cp = skip_whitespace(cp);
 			if (have1 || *cp) {
-				bb_error_msg("bad quit command");
+				bb_simple_error_msg("bad quit command");
 				break;
 			}
 			if (!dirty)
@@ -903,12 +903,12 @@ static void doCommands(void)
 
 		case 'r':
 			if (*cp != '\0' && *cp != ' ') {
-				bb_error_msg("bad read command");
+				bb_simple_error_msg("bad read command");
 				break;
 			}
 			cp = skip_whitespace(cp);
 			if (*cp == '\0') {
-				bb_error_msg("no file name");
+				bb_simple_error_msg("no file name");
 				break;
 			}
 			if (!have1)
@@ -925,14 +925,14 @@ static void doCommands(void)
 
 		case 'w':
 			if (*cp != '\0' && *cp != ' ') {
-				bb_error_msg("bad write command");
+				bb_simple_error_msg("bad write command");
 				break;
 			}
 			cp = skip_whitespace(cp);
 			if (*cp == '\0') {
 				cp = fileName;
 				if (!cp) {
-					bb_error_msg("no file name specified");
+					bb_simple_error_msg("no file name specified");
 					break;
 				}
 			}
@@ -960,7 +960,7 @@ static void doCommands(void)
 
 		case '.':
 			if (have1) {
-				bb_error_msg("no arguments allowed");
+				bb_simple_error_msg("no arguments allowed");
 				break;
 			}
 			printLines(curNum, curNum, FALSE);
@@ -984,7 +984,7 @@ static void doCommands(void)
 			break;
 
 		default:
-			bb_error_msg("unimplemented command");
+			bb_simple_error_msg("unimplemented command");
 			break;
 		}
 	}
diff -urpN busybox-1.31.1/editors/patch.c busybox-1.32.0/editors/patch.c
--- busybox-1.31.1/editors/patch.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/editors/patch.c	2020-06-26 22:47:44.000000000 +0400
@@ -264,7 +264,7 @@ static int apply_one_hunk(void)
 			if (!plist && matcheof) break;
 
 			if (backwarn)
-				fdprintf(2,"Possibly reversed hunk %d at %ld\n",
+				fdprintf(2, "Possibly reversed hunk %d at %ld\n",
 					TT.hunknum, TT.linenum);
 
 			// File ended before we found a place for this hunk.
@@ -593,6 +593,7 @@ int patch_main(int argc UNUSED_PARAM, ch
 					TT.linenum = 0;
 					TT.hunknum = 0;
 				}
+				fflush_all(); // make "patching file F" visible
 			}
 
 			TT.hunknum++;
diff -urpN busybox-1.31.1/editors/patch_bbox.c busybox-1.32.0/editors/patch_bbox.c
--- busybox-1.31.1/editors/patch_bbox.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/editors/patch_bbox.c	2020-06-26 22:47:44.000000000 +0400
@@ -30,7 +30,7 @@ static unsigned copy_lines(FILE *src_str
 			break;
 		}
 		if (fputs(line, dst_stream) == EOF) {
-			bb_perror_msg_and_die("error writing to new file");
+			bb_simple_perror_msg_and_die("error writing to new file");
 		}
 		free(line);
 		lines_count--;
@@ -148,7 +148,7 @@ int patch_main(int argc UNUSED_PARAM, ch
 
 		new_filename = extract_filename(patch_line, patch_level, "+++ ");
 		if (!new_filename) {
-			bb_error_msg_and_die("invalid patch");
+			bb_simple_error_msg_and_die("invalid patch");
 		}
 
 		/* Get access rights from the file to be patched */
@@ -209,7 +209,7 @@ int patch_main(int argc UNUSED_PARAM, ch
 				/* src_beg_line will be 0 if it's a new file */
 				count = src_beg_line - src_cur_line;
 				if (copy_lines(src_stream, dst_stream, count)) {
-					bb_error_msg_and_die("bad src file");
+					bb_simple_error_msg_and_die("bad src file");
 				}
 				src_cur_line += count;
 				dst_cur_line += count;
diff -urpN busybox-1.31.1/editors/patch_toybox.c busybox-1.32.0/editors/patch_toybox.c
--- busybox-1.31.1/editors/patch_toybox.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/editors/patch_toybox.c	2020-06-26 22:47:44.000000000 +0400
@@ -200,7 +200,7 @@ int copy_tempfile(int fdin, char *name,
 
 	*tempname = xasprintf("%sXXXXXX", name);
 	fd = mkstemp(*tempname);
-	if(-1 == fd) bb_perror_msg_and_die("no temp file");
+	if(-1 == fd) bb_simple_perror_msg_and_die("no temp file");
 
 	// Set permissions of output file
 	fstat(fdin, &statbuf);
diff -urpN busybox-1.31.1/editors/sed.c busybox-1.32.0/editors/sed.c
--- busybox-1.31.1/editors/sed.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/editors/sed.c	2020-06-26 22:47:44.000000000 +0400
@@ -315,7 +315,7 @@ static int parse_regex_delim(const char
 	/* verify that the 's' or 'y' is followed by something.  That something
 	 * (typically a 'slash') is now our regexp delimiter... */
 	if (*cmdstr == '\0')
-		bb_error_msg_and_die("bad format in substitution expression");
+		bb_simple_error_msg_and_die("bad format in substitution expression");
 	delimiter = *cmdstr_ptr++;
 
 	/* save the match string */
@@ -360,7 +360,7 @@ static int get_address(const char *my_st
 		} else {
 			*regex = G.previous_regex_ptr;
 			if (!G.previous_regex_ptr)
-				bb_error_msg_and_die("no previous regexp");
+				bb_simple_error_msg_and_die("no previous regexp");
 		}
 		/* Move position to next character after last delimiter */
 		pos += (next+1);
@@ -378,7 +378,7 @@ static int parse_file_cmd(/*sed_cmd_t *s
 	start = skip_whitespace(filecmdstr);
 	eol = strchrnul(start, '\n');
 	if (eol == start)
-		bb_error_msg_and_die("empty filename");
+		bb_simple_error_msg_and_die("empty filename");
 
 	if (*eol) {
 		/* If lines glued together, put backslash back. */
@@ -468,7 +468,7 @@ static int parse_subst_cmd(sed_cmd_t *se
 			goto out;
 		default:
 			dbg("s bad flags:'%s'", substr + idx);
-			bb_error_msg_and_die("bad option in substitution expression");
+			bb_simple_error_msg_and_die("bad option in substitution expression");
 		}
 	}
  out:
@@ -688,7 +688,7 @@ static void add_cmd(const char *cmdstr)
 				idx--; /* if 0, trigger error check below */
 			}
 			if (idx < 0)
-				bb_error_msg_and_die("no address after comma");
+				bb_simple_error_msg_and_die("no address after comma");
 			sed_cmd->end_line_orig = sed_cmd->end_line;
 		}
 
@@ -706,7 +706,7 @@ static void add_cmd(const char *cmdstr)
 
 		/* last part (mandatory) will be a command */
 		if (!*cmdstr)
-			bb_error_msg_and_die("missing command");
+			bb_simple_error_msg_and_die("missing command");
 		sed_cmd->cmd = *cmdstr++;
 		cmdstr = parse_cmd_args(sed_cmd, cmdstr);
 
@@ -791,7 +791,7 @@ static int do_subst_command(sed_cmd_t *s
 	if (!current_regex) {
 		current_regex = G.previous_regex_ptr;
 		if (!current_regex)
-			bb_error_msg_and_die("no previous regexp");
+			bb_simple_error_msg_and_die("no previous regexp");
 	}
 	G.previous_regex_ptr = current_regex;
 
@@ -962,7 +962,7 @@ static void puts_maybe_newline(char *s,
 
 	if (ferror(file)) {
 		xfunc_error_retval = 4;  /* It's what gnu sed exits with... */
-		bb_error_msg_and_die(bb_msg_write_error);
+		bb_simple_error_msg_and_die(bb_msg_write_error);
 	}
 	*last_puts_char = lpc;
 }
@@ -1192,7 +1192,7 @@ static void process_files(void)
 					}
 					sed_cmd = sed_cmd->next;
 					if (!sed_cmd)
-						bb_error_msg_and_die("unterminated {");
+						bb_simple_error_msg_and_die("unterminated {");
 				}
 			}
 			continue;
diff -urpN busybox-1.31.1/editors/vi.c busybox-1.32.0/editors/vi.c
--- busybox-1.31.1/editors/vi.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/editors/vi.c	2020-06-26 22:47:44.000000000 +0400
@@ -1042,7 +1042,7 @@ static int readit(void) // read (maybe c
 			goto again;
 		go_bottom_and_clear_to_eol();
 		cookmode(); // terminal to "cooked"
-		bb_error_msg_and_die("can't read user input");
+		bb_simple_error_msg_and_die("can't read user input");
 	}
 	return c;
 }
@@ -2251,7 +2251,6 @@ static char *get_one_address(char *p, in
 	int st;
 	char *q;
 	IF_FEATURE_VI_YANKMARK(char c;)
-	IF_FEATURE_VI_SEARCH(char *pat;)
 
 	*addr = -1;			// assume no addr
 	if (*p == '.') {	// the current line
@@ -2276,16 +2275,20 @@ static char *get_one_address(char *p, in
 #endif
 #if ENABLE_FEATURE_VI_SEARCH
 	else if (*p == '/') {	// a search pattern
-		q = strchrnul(++p, '/');
-		pat = xstrndup(p, q - p); // save copy of pattern
+		q = strchrnul(p + 1, '/');
+		if (p + 1 != q) {
+			// save copy of new pattern
+			free(last_search_pattern);
+			last_search_pattern = xstrndup(p, q - p);
+		}
 		p = q;
 		if (*p == '/')
 			p++;
-		q = char_search(dot, pat, (FORWARD << 1) | FULL);
+		q = char_search(next_line(dot), last_search_pattern + 1,
+						(FORWARD << 1) | FULL);
 		if (q != NULL) {
 			*addr = count_lines(text, q);
 		}
-		free(pat);
 	}
 #endif
 	else if (*p == '$') {	// the last line in file
@@ -3490,7 +3493,7 @@ static void do_cmd(int c)
 		} while (--cmdcnt > 0);
 		break;
 	case '{':			// {- move backward paragraph
-		q = char_search(dot, "\n\n", (BACK << 1) | FULL);
+		q = char_search(dot, "\n\n", ((unsigned)BACK << 1) | FULL);
 		if (q != NULL) {	// found blank line
 			dot = next_line(q);	// move to next blank line
 		}
diff -urpN busybox-1.31.1/examples/inittab busybox-1.32.0/examples/inittab
--- busybox-1.31.1/examples/inittab	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/examples/inittab	2020-06-26 22:47:44.000000000 +0400
@@ -19,30 +19,43 @@
 #
 # <runlevels>: The runlevels field is completely ignored.
 #
-# <action>: Valid actions include: sysinit, respawn, askfirst, wait, once,
-#                                  restart, ctrlaltdel, and shutdown.
+# <action>: Valid actions include: sysinit, wait, once, respawn, askfirst,
+#                                  shutdown, restart and ctrlaltdel.
 #
-#       Note: askfirst acts just like respawn, but before running the specified
-#       process it displays the line "Please press Enter to activate this
-#       console." and then waits for the user to press enter before starting
-#       the specified process.
+#	sysinit actions are started first, and init waits for them to complete.
+#	wait actions are started next, and init waits for them to complete.
+#	once actions are started next (and not waited for).
+#
+#	askfirst and respawn are started next.
+#	For askfirst, before running the specified process, init displays
+#	the line "Please press Enter to activate this console"
+#	and then waits for the user to press enter before starting it.
+#
+#	shutdown actions are run on halt/reboot/poweroff, or on SIGQUIT.
+#	Then the machine is halted/rebooted/powered off, or for SIGQUIT,
+#	restart action is exec'ed (init process is replaced by that process).
+#	If no restart action specified, SIGQUIT has no effect.
+#
+#	ctrlaltdel actions are run when SIGINT is received
+#	(this might be initiated by Ctrl-Alt-Del key combination).
+#	After they complete, normal processing of askfirst / respawn resumes.
 #
-#       Note: unrecognized actions (like initdefault) will cause init to emit
-#       an error message, and then go along with its business.
+#	Note: unrecognized actions (like initdefault) will cause init to emit
+#	an error message, and then go along with its business.
 #
 # <process>: Specifies the process to be executed and it's command line.
 #
 # Note: BusyBox init works just fine without an inittab. If no inittab is
 # found, it has the following default behavior:
-#         ::sysinit:/etc/init.d/rcS
-#         ::askfirst:/bin/sh
-#         ::ctrlaltdel:/sbin/reboot
-#         ::shutdown:/sbin/swapoff -a
-#         ::shutdown:/bin/umount -a -r
-#         ::restart:/sbin/init
-#         tty2::askfirst:/bin/sh
-#         tty3::askfirst:/bin/sh
-#         tty4::askfirst:/bin/sh
+#	::sysinit:/etc/init.d/rcS
+#	::askfirst:/bin/sh
+#	::ctrlaltdel:/sbin/reboot
+#	::shutdown:/sbin/swapoff -a
+#	::shutdown:/bin/umount -a -r
+#	::restart:/sbin/init
+#	tty2::askfirst:/bin/sh
+#	tty3::askfirst:/bin/sh
+#	tty4::askfirst:/bin/sh
 #
 # Boot-time system configuration/initialization script.
 # This is run first except when booting in single-user mode.
diff -urpN busybox-1.31.1/examples/udhcp/simple.script busybox-1.32.0/examples/udhcp/simple.script
--- busybox-1.31.1/examples/udhcp/simple.script	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/examples/udhcp/simple.script	2020-06-26 22:47:44.000000000 +0400
@@ -16,9 +16,10 @@ BROADCAST="broadcast +"
 
 case "$1" in
 	deconfig)
-		echo "Setting IP address 0.0.0.0 on $interface"
+		echo "Clearing IP addresses on $interface, upping it"
 		if command -v ip >/dev/null; then
-			ip addr flush dev $interface
+			ip -4 addr flush dev $interface
+			ip link set dev $interface up
 		else
 			ifconfig $interface 0.0.0.0
 		fi
@@ -52,7 +53,6 @@ case "$1" in
 			done
 		fi
 
-		echo "Recreating $RESOLV_CONF"
 		# If the file is a symlink somewhere (like /etc/resolv.conf
 		# pointing to /run/resolv.conf), make sure things work.
 		if test -L "$RESOLV_CONF"; then
@@ -60,6 +60,7 @@ case "$1" in
 			test -e "$RESOLV_CONF" || touch "$RESOLV_CONF"
 		fi
 		realconf=$(readlink -f "$RESOLV_CONF" 2>/dev/null || echo "$RESOLV_CONF")
+		echo "Recreating $realconf"
 		tmpfile="$realconf-$$"
 		> "$tmpfile"
 		[ -n "$domain" ] && echo "search $domain" >> "$tmpfile"
diff -urpN busybox-1.31.1/findutils/find.c busybox-1.32.0/findutils/find.c
--- busybox-1.31.1/findutils/find.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/findutils/find.c	2020-06-26 22:47:44.000000000 +0400
@@ -203,6 +203,14 @@
 //config:	WARNING: This option can do much harm if used wrong. Busybox will not
 //config:	try to protect the user from doing stupid things. Use with care.
 //config:
+//config:config FEATURE_FIND_EMPTY
+//config:	bool "Enable -empty: match empty files or directories"
+//config:	default y
+//config:	depends on FIND
+//config:	help
+//config:	Support the 'find -empty' option to find empty regular files
+//config:	or directories.
+//config:
 //config:config FEATURE_FIND_PATH
 //config:	bool "Enable -path: match pathname with shell pattern"
 //config:	default y
@@ -315,6 +323,9 @@
 //usage:	IF_FEATURE_FIND_CONTEXT(
 //usage:     "\n	-context CTX	File has specified security context"
 //usage:	)
+//usage:	IF_FEATURE_FIND_EMPTY(
+//usage:     "\n	-empty		Match empty file/directory"
+//usage:	)
 //usage:	IF_FEATURE_FIND_PRUNE(
 //usage:     "\n	-prune		If current file is directory, don't descend into it"
 //usage:	)
@@ -396,6 +407,7 @@ IF_FEATURE_FIND_PAREN(  ACTS(paren, acti
 IF_FEATURE_FIND_PRUNE(  ACTS(prune))
 IF_FEATURE_FIND_QUIT(   ACTS(quit))
 IF_FEATURE_FIND_DELETE( ACTS(delete))
+IF_FEATURE_FIND_EMPTY(  ACTS(empty))
 IF_FEATURE_FIND_EXEC(   ACTS(exec,
 				char **exec_argv; /* -exec ARGS */
 				unsigned *subst_count;
@@ -824,6 +836,30 @@ ACTF(delete)
 	return TRUE;
 }
 #endif
+#if ENABLE_FEATURE_FIND_EMPTY
+ACTF(empty)
+{
+	if (S_ISDIR(statbuf->st_mode)) {
+		DIR *dir;
+		struct dirent *dent;
+
+		dir = opendir(fileName);
+		if (!dir) {
+			bb_simple_perror_msg(fileName);
+			return FALSE;
+		}
+
+		while ((dent = readdir(dir)) != NULL
+		 && DOT_OR_DOTDOT(dent->d_name)
+		) {
+			continue;
+		}
+		closedir(dir);
+		return dent == NULL;
+	}
+	return S_ISREG(statbuf->st_mode) && statbuf->st_size == 0;
+}
+#endif
 #if ENABLE_FEATURE_FIND_CONTEXT
 ACTF(context)
 {
@@ -989,6 +1025,7 @@ static action*** parse_params(char **arg
 	IF_FEATURE_FIND_PRUNE(  PARM_prune     ,)
 	IF_FEATURE_FIND_QUIT(   PARM_quit      ,)
 	IF_FEATURE_FIND_DELETE( PARM_delete    ,)
+	IF_FEATURE_FIND_EMPTY(	PARM_empty     ,)
 	IF_FEATURE_FIND_EXEC(   PARM_exec      ,)
 	IF_FEATURE_FIND_EXECUTABLE(PARM_executable,)
 	IF_FEATURE_FIND_PAREN(  PARM_char_brace,)
@@ -1034,6 +1071,7 @@ static action*** parse_params(char **arg
 	IF_FEATURE_FIND_PRUNE(  "-prune\0"  )
 	IF_FEATURE_FIND_QUIT(   "-quit\0"  )
 	IF_FEATURE_FIND_DELETE( "-delete\0" )
+	IF_FEATURE_FIND_EMPTY(	"-empty\0"  )
 	IF_FEATURE_FIND_EXEC(   "-exec\0"   )
 	IF_FEATURE_FIND_EXECUTABLE("-executable\0")
 	IF_FEATURE_FIND_PAREN(  "(\0"       )
@@ -1203,6 +1241,12 @@ static action*** parse_params(char **arg
 			(void) ALLOC_ACTION(delete);
 		}
 #endif
+#if ENABLE_FEATURE_FIND_EMPTY
+		else if (parm == PARM_empty) {
+			dbg("%d", __LINE__);
+			(void) ALLOC_ACTION(empty);
+		}
+#endif
 #if ENABLE_FEATURE_FIND_EXEC
 		else if (parm == PARM_exec) {
 			int i;
@@ -1245,7 +1289,7 @@ static action*** parse_params(char **arg
 			 * coreutils expects {} to appear only once in "-exec +"
 			 */
 			if (all_subst != 1 && ap->filelist)
-				bb_error_msg_and_die("only one '{}' allowed for -exec +");
+				bb_simple_error_msg_and_die("only one '{}' allowed for -exec +");
 # endif
 		}
 #endif
@@ -1259,7 +1303,7 @@ static action*** parse_params(char **arg
 			endarg = argv;
 			while (1) {
 				if (!*++endarg)
-					bb_error_msg_and_die("unpaired '('");
+					bb_simple_error_msg_and_die("unpaired '('");
 				if (LONE_CHAR(*endarg, '('))
 					nested++;
 				else if (LONE_CHAR(*endarg, ')') && !--nested) {
diff -urpN busybox-1.31.1/findutils/grep.c busybox-1.32.0/findutils/grep.c
--- busybox-1.31.1/findutils/grep.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/findutils/grep.c	2020-06-26 22:47:44.000000000 +0400
@@ -60,7 +60,7 @@
 
 /* options */
 //usage:#define grep_trivial_usage
-//usage:       "[-HhnlLoqvsriwFE"
+//usage:       "[-HhnlLoqvsrRiwFE"
 //usage:	IF_EXTRA_COMPAT("z")
 //usage:       "] [-m N] "
 //usage:	IF_FEATURE_GREP_CONTEXT("[-A/B/C N] ")
@@ -78,6 +78,7 @@
 //usage:     "\n	-v	Select non-matching lines"
 //usage:     "\n	-s	Suppress open and read errors"
 //usage:     "\n	-r	Recurse"
+//usage:     "\n	-R	Recurse and dereference symlinks"
 //usage:     "\n	-i	Ignore case"
 //usage:     "\n	-w	Match whole words only"
 //usage:     "\n	-x	Match whole lines only"
@@ -108,7 +109,7 @@
 
 /* -e,-f are lists; -m,-A,-B,-C have numeric param */
 #define OPTSTR_GREP \
-	"lnqvscFiHhe:*f:*Lorm:+wx" \
+	"lnqvscFiHhe:*f:*LorRm:+wx" \
 	IF_FEATURE_GREP_CONTEXT("A:+B:+C:+") \
 	"E" \
 	IF_EXTRA_COMPAT("z") \
@@ -131,6 +132,7 @@ enum {
 	OPTBIT_L, /* list unmatched file names only */
 	OPTBIT_o, /* show only matching parts of lines */
 	OPTBIT_r, /* recurse dirs */
+	OPTBIT_R, /* recurse dirs and symlinks to dirs */
 	OPTBIT_m, /* -m MAX_MATCHES */
 	OPTBIT_w, /* -w whole word match */
 	OPTBIT_x, /* -x whole line match */
@@ -154,6 +156,7 @@ enum {
 	OPT_L = 1 << OPTBIT_L,
 	OPT_o = 1 << OPTBIT_o,
 	OPT_r = 1 << OPTBIT_r,
+	OPT_R = 1 << OPTBIT_R,
 	OPT_m = 1 << OPTBIT_m,
 	OPT_w = 1 << OPTBIT_w,
 	OPT_x = 1 << OPTBIT_x,
@@ -647,6 +650,13 @@ static void load_regexes_from_file(llist
 	}
 }
 
+static void load_pattern_list(llist_t **lst, char *pattern)
+{
+	char *p;
+	while ((p = strsep(&pattern, "\n")) != NULL)
+		llist_add_to(lst, new_grep_list_data(p, 0));
+}
+
 static int FAST_FUNC file_action_grep(const char *filename,
 			struct stat *statbuf,
 			void* matched,
@@ -687,6 +697,7 @@ static int grep_dir(const char *dir)
 	int matched = 0;
 	recursive_action(dir,
 		/* recurse=yes */ ACTION_RECURSE |
+		/* followLinks=always */ ((option_mask32 & OPT_R) ? ACTION_FOLLOWLINKS : 0) |
 		/* followLinks=command line only */ ACTION_FOLLOWLINKS_L0 |
 		/* depthFirst=yes */ ACTION_DEPTHFIRST,
 		/* fileAction= */ file_action_grep,
@@ -750,16 +761,19 @@ int grep_main(int argc UNUSED_PARAM, cha
 #endif
 	invert_search = ((option_mask32 & OPT_v) != 0); /* 0 | 1 */
 
-	{	/* convert char **argv to grep_list_data_t */
-		llist_t *cur;
+	{	/* convert char **argv to pattern_list */
+		llist_t *cur, *new = NULL;
 		for (cur = pattern_head; cur; cur = cur->link)
-			cur->data = new_grep_list_data(cur->data, 0);
+			load_pattern_list(&new, cur->data);
+		llist_free(pattern_head, NULL);
+		pattern_head = new;
 	}
 	if (option_mask32 & OPT_f) {
 		load_regexes_from_file(fopt);
 		if (!pattern_head) { /* -f EMPTY_FILE? */
-			/* GNU grep treats it as "nothing matches" */
-			llist_add_to(&pattern_head, new_grep_list_data((char*) "", 0));
+			/* GNU grep treats it as "nothing matches" except when -x */
+			const char *data = (option_mask32 & OPT_x) ? ".*" : "";
+			llist_add_to(&pattern_head, new_grep_list_data((char*)data, 0));
 			invert_search ^= 1;
 		}
 	}
@@ -801,11 +815,9 @@ int grep_main(int argc UNUSED_PARAM, cha
 	/* if we didn't get a pattern from -e and no command file was specified,
 	 * first parameter should be the pattern. no pattern, no worky */
 	if (pattern_head == NULL) {
-		char *pattern;
 		if (*argv == NULL)
 			bb_show_usage();
-		pattern = new_grep_list_data(*argv++, 0);
-		llist_add_to(&pattern_head, pattern);
+		load_pattern_list(&pattern_head, *argv++);
 	}
 
 	/* argv[0..(argc-1)] should be names of file to grep through. If
@@ -827,7 +839,7 @@ int grep_main(int argc UNUSED_PARAM, cha
 		if (!cur_file || LONE_DASH(cur_file)) {
 			cur_file = "(standard input)";
 		} else {
-			if (option_mask32 & OPT_r) {
+			if (option_mask32 & (OPT_r|OPT_R)) {
 				struct stat st;
 				if (stat(cur_file, &st) == 0 && S_ISDIR(st.st_mode)) {
 					if (!(option_mask32 & OPT_h))
diff -urpN busybox-1.31.1/findutils/xargs.c busybox-1.32.0/findutils/xargs.c
--- busybox-1.31.1/findutils/xargs.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/findutils/xargs.c	2020-06-26 22:47:44.000000000 +0400
@@ -114,17 +114,28 @@ struct globals {
 	int max_procs;
 #endif
 	smalluint xargs_exitcode;
+#if ENABLE_FEATURE_XARGS_SUPPORT_QUOTES
+#define NORM      0
+#define QUOTE     1
+#define BACKSLASH 2
+#define SPACE     4
+	smalluint process_stdin__state;
+	char process_stdin__q;
+#endif
 } FIX_ALIASING;
 #define G (*(struct globals*)bb_common_bufsiz1)
 #define INIT_G() do { \
 	setup_common_bufsiz(); \
-	G.eof_str = NULL; /* need to clear by hand because we are NOEXEC applet */ \
+	IF_FEATURE_XARGS_SUPPORT_REPL_STR(G.repl_str = "{}";) \
+	IF_FEATURE_XARGS_SUPPORT_REPL_STR(G.eol_ch = '\n';) \
+	/* Even zero values are set because we are NOEXEC applet */ \
+	G.eof_str = NULL; \
 	G.idx = 0; \
 	IF_FEATURE_XARGS_SUPPORT_PARALLEL(G.running_procs = 0;) \
 	IF_FEATURE_XARGS_SUPPORT_PARALLEL(G.max_procs = 1;) \
 	G.xargs_exitcode = 0; \
-	IF_FEATURE_XARGS_SUPPORT_REPL_STR(G.repl_str = "{}";) \
-	IF_FEATURE_XARGS_SUPPORT_REPL_STR(G.eol_ch = '\n';) \
+	IF_FEATURE_XARGS_SUPPORT_QUOTES(G.process_stdin__state = NORM;) \
+	IF_FEATURE_XARGS_SUPPORT_QUOTES(G.process_stdin__q = '\0';) \
 } while (0)
 
 
@@ -257,12 +268,8 @@ static void store_param(char *s)
 #if ENABLE_FEATURE_XARGS_SUPPORT_QUOTES
 static char* FAST_FUNC process_stdin(int n_max_chars, int n_max_arg, char *buf)
 {
-#define NORM      0
-#define QUOTE     1
-#define BACKSLASH 2
-#define SPACE     4
-	char q = '\0';             /* quote char */
-	char state = NORM;
+#define q     G.process_stdin__q
+#define state G.process_stdin__state
 	char *s = buf;             /* start of the word */
 	char *p = s + strlen(buf); /* end of the word */
 
@@ -308,6 +315,7 @@ static char* FAST_FUNC process_stdin(int
 			}
 		}
 		if (state == SPACE) {   /* word's delimiter or EOF detected */
+			state = NORM;
 			if (q) {
 				bb_error_msg_and_die("unmatched %s quote",
 					q == '\'' ? "single" : "double");
@@ -328,7 +336,6 @@ static char* FAST_FUNC process_stdin(int
 			if (n_max_arg == 0) {
 				goto ret;
 			}
-			state = NORM;
 		}
 		if (p == buf) {
 			goto ret;
@@ -339,6 +346,8 @@ static char* FAST_FUNC process_stdin(int
 	/* store_param(NULL) - caller will do it */
 	dbg_msg("return:'%s'", s);
 	return s;
+#undef q
+#undef state
 }
 #else
 /* The variant does not support single quotes, double quotes or backslash */
@@ -665,7 +674,7 @@ int xargs_main(int argc UNUSED_PARAM, ch
 	}
 	/* Sanity check */
 	if (n_max_chars <= 0) {
-		bb_error_msg_and_die("can't fit single argument within argument list size limit");
+		bb_simple_error_msg_and_die("can't fit single argument within argument list size limit");
 	}
 
 	buf = xzalloc(n_max_chars + 1);
@@ -716,7 +725,7 @@ int xargs_main(int argc UNUSED_PARAM, ch
 
 		if (!G.args[initial_idx]) { /* not even one ARG was added? */
 			if (*rem != '\0')
-				bb_error_msg_and_die("argument line too long");
+				bb_simple_error_msg_and_die("argument line too long");
 			if (opt & OPT_NO_EMPTY)
 				break;
 		}
diff -urpN busybox-1.31.1/include/libbb.h busybox-1.32.0/include/libbb.h
--- busybox-1.31.1/include/libbb.h	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/include/libbb.h	2020-06-26 22:47:44.000000000 +0400
@@ -298,6 +298,7 @@ typedef unsigned long uoff_t;
 /* scary. better ideas? (but do *test* them first!) */
 #define OFF_T_MAX  ((off_t)~((off_t)1 << (sizeof(off_t)*8-1)))
 /* Users report bionic to use 32-bit off_t even if LARGEFILE support is requested.
+ * On musl, !ENABLE_LFS on 32-bit arches thinks that off_t is 32-bit.
  * We misdetected that. Don't let it build:
  */
 struct BUG_off_t_size_is_misdetected {
@@ -1137,7 +1138,7 @@ void exec_prog_or_SHELL(char **argv) NOR
 ({ \
 	pid_t bb__xvfork_pid = vfork(); \
 	if (bb__xvfork_pid < 0) \
-		bb_perror_msg_and_die("vfork"); \
+		bb_simple_perror_msg_and_die("vfork"); \
 	bb__xvfork_pid; \
 })
 #if BB_MMU
@@ -1324,13 +1325,17 @@ extern void (*die_func)(void);
 void xfunc_die(void) NORETURN FAST_FUNC;
 void bb_show_usage(void) NORETURN FAST_FUNC;
 void bb_error_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_error_msg(const char *s) FAST_FUNC;
 void bb_error_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_error_msg_and_die(const char *s) NORETURN FAST_FUNC;
 void bb_perror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
 void bb_simple_perror_msg(const char *s) FAST_FUNC;
 void bb_perror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
 void bb_simple_perror_msg_and_die(const char *s) NORETURN FAST_FUNC;
 void bb_herror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_herror_msg(const char *s) FAST_FUNC;
 void bb_herror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_herror_msg_and_die(const char *s) NORETURN FAST_FUNC;
 void bb_perror_nomsg_and_die(void) NORETURN FAST_FUNC;
 void bb_perror_nomsg(void) FAST_FUNC;
 void bb_verror_msg(const char *s, va_list p, const char *strerr) FAST_FUNC;
@@ -1339,12 +1344,53 @@ void bb_logenv_override(void) FAST_FUNC;
 
 #if ENABLE_FEATURE_SYSLOG_INFO
 void bb_info_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_info_msg(const char *s) FAST_FUNC;
 void bb_vinfo_msg(const char *s, va_list p) FAST_FUNC;
 #else
 #define bb_info_msg bb_error_msg
+#define bb_simple_info_msg bb_simple_error_msg
 #define bb_vinfo_msg(s,p) bb_verror_msg(s,p,NULL)
 #endif
 
+#if ENABLE_WARN_SIMPLE_MSG
+/* If enabled, cause calls to bb_error_msg() et al that only take a single
+ * parameter to generate a warning.
+ */
+static inline void __attribute__ ((deprecated("use bb_simple_error_msg instead")))
+	bb_not_simple_error_msg(const char *s) { bb_simple_error_msg(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_error_msg_and_die instead"))) NORETURN
+	bb_not_simple_error_msg_and_die(const char *s) { bb_simple_error_msg_and_die(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_perror_msg instead")))
+	bb_not_simple_perror_msg(const char *s) { bb_simple_perror_msg(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_perror_msg_and_die instead"))) NORETURN
+	bb_not_simple_perror_msg_and_die(const char *s) { bb_simple_perror_msg_and_die(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_herror_msg instead")))
+	bb_not_simple_herror_msg(const char *s) { bb_simple_herror_msg(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_herror_msg_and_die instead"))) NORETURN
+	bb_not_simple_herror_msg_and_die(const char *s) { bb_simple_herror_msg_and_die(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_info_msg instead")))
+	bb_not_simple_info_msg(const char *s) { bb_simple_info_msg(s); }
+/* Override bb_error_msg() and related functions with macros that will
+ * substitute them for the equivalent bb_not_simple_error_msg() function when
+ * they are used with only a single parameter. Macro approach inspired by
+ * https://gustedt.wordpress.com/2010/06/08/detect-empty-macro-arguments and
+ * https://gustedt.wordpress.com/2010/06/03/default-arguments-for-c99
+ */
+#define _ARG18(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, ...) _17
+#define BB_MSG_KIND(...)           _ARG18(__VA_ARGS__, , , , , , , , , , , , , , , , , _not_simple)
+#define _BB_MSG(name, kind, ...)   bb##kind##name(__VA_ARGS__)
+#define BB_MSG(name, kind, ...)    _BB_MSG(name, kind, __VA_ARGS__)
+#define bb_error_msg(...)          BB_MSG(_error_msg, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_error_msg_and_die(...)  BB_MSG(_error_msg_and_die, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_perror_msg(...)         BB_MSG(_perror_msg, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_perror_msg_and_die(...) BB_MSG(_perror_msg_and_die, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_herror_msg(...)         BB_MSG(_herror_msg, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_herror_msg_and_die(...) BB_MSG(_herror_msg_and_die, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#if ENABLE_FEATURE_SYSLOG_INFO
+#define bb_info_msg(...)           BB_MSG(_info_msg, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#endif
+#endif
+
 /* We need to export XXX_main from libbusybox
  * only if we build "individual" binaries
  */
@@ -1775,10 +1821,19 @@ unsigned size_from_HISTFILESIZE(const ch
 # else
 #  define MAX_HISTORY 0
 # endif
+typedef const char *get_exe_name_t(int i) FAST_FUNC;
 typedef struct line_input_t {
 	int flags;
 	int timeout;
 	const char *path_lookup;
+# if ENABLE_FEATURE_TAB_COMPLETION \
+&& (ENABLE_ASH  || ENABLE_SH_IS_ASH  || ENABLE_BASH_IS_ASH \
+||  ENABLE_HUSH || ENABLE_SH_IS_HUSH || ENABLE_BASH_IS_HUSH \
+)
+	/* function to fetch additional application-specific names to match */
+	get_exe_name_t *get_exe_name;
+#  define EDITING_HAS_get_exe_name 1
+# endif
 # if MAX_HISTORY
 	int cnt_history;
 	int cur_history;
@@ -1825,6 +1880,10 @@ int read_line_input(const char* prompt,
 	read_line_input(prompt, command, maxsize)
 #endif
 
+#ifndef EDITING_HAS_get_exe_name
+# define EDITING_HAS_get_exe_name 0
+#endif
+
 
 #ifndef COMM_LEN
 # ifdef TASK_COMM_LEN
@@ -2110,12 +2169,32 @@ struct globals;
  * Magic prevents ptr_to_globals from going into rodata.
  * If you want to assign a value, use SET_PTR_TO_GLOBALS(x) */
 extern struct globals *const ptr_to_globals;
+
+#if defined(__clang_major__) && __clang_major__ >= 9
+/* Clang/llvm drops assignment to "constant" storage. Silently.
+ * Needs serious convincing to not eliminate the store.
+ */
+static ALWAYS_INLINE void* not_const_pp(const void *p)
+{
+	void *pp;
+	__asm__ __volatile__(
+		"# forget that p points to const"
+		: /*outputs*/ "=r" (pp)
+		: /*inputs*/ "0" (p)
+	);
+	return pp;
+}
+#else
+static ALWAYS_INLINE void* not_const_pp(const void *p) { return (void*)p; }
+#endif
+
 /* At least gcc 3.4.6 on mipsel system needs optimization barrier */
 #define barrier() __asm__ __volatile__("":::"memory")
 #define SET_PTR_TO_GLOBALS(x) do { \
-	(*(struct globals**)&ptr_to_globals) = (void*)(x); \
+	(*(struct globals**)not_const_pp(&ptr_to_globals)) = (void*)(x); \
 	barrier(); \
 } while (0)
+
 #define FREE_PTR_TO_GLOBALS() do { \
 	if (ENABLE_FEATURE_CLEAN_UP) { \
 		free(ptr_to_globals); \
diff -urpN busybox-1.31.1/include/platform.h busybox-1.32.0/include/platform.h
--- busybox-1.31.1/include/platform.h	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/include/platform.h	2020-06-26 22:47:44.000000000 +0400
@@ -30,6 +30,10 @@
 # endif
 #endif
 
+#if !__GNUC_PREREQ(5,0)
+# define deprecated(msg) deprecated
+#endif
+
 #undef inline
 #if defined(__STDC_VERSION__) && __STDC_VERSION__ > 199901L
 /* it's a keyword */
diff -urpN busybox-1.31.1/init/bootchartd.c busybox-1.32.0/init/bootchartd.c
--- busybox-1.31.1/init/bootchartd.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/init/bootchartd.c	2020-06-26 22:47:44.000000000 +0400
@@ -208,7 +208,7 @@ static char *make_tempdir(void)
 			bb_perror_msg_and_die("can't %smount tmpfs", "un");
 		}
 #else
-		bb_perror_msg_and_die("can't create temporary directory");
+		bb_simple_perror_msg_and_die("can't create temporary directory");
 #endif
 	} else {
 		xchdir(tempdir);
diff -urpN busybox-1.31.1/init/init.c busybox-1.32.0/init/init.c
--- busybox-1.31.1/init/init.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/init/init.c	2020-06-26 22:47:44.000000000 +0400
@@ -145,13 +145,6 @@
 # include <sys/ucontext.h>
 #endif
 
-/* Used only for sanitizing purposes in set_sane_term() below. On systems where
- * the baud rate is stored in a separate field, we can safely disable them. */
-#ifndef CBAUD
-# define CBAUD 0
-# define CBAUDEX 0
-#endif
-
 /* Was a CONFIG_xxx option. A lot of people were building
  * not fully functional init by switching it on! */
 #define DEBUG_INIT 0
@@ -217,6 +210,8 @@ struct globals {
 #if !ENABLE_FEATURE_INIT_SYSLOG
 	const char *log_console;
 #endif
+	sigset_t delayed_sigset;
+	struct timespec zero_ts;
 } FIX_ALIASING;
 #define G (*(struct globals*)bb_common_bufsiz1)
 #define INIT_G() do { \
@@ -347,7 +342,8 @@ static void set_sane_term(void)
 {
 	struct termios tty;
 
-	tcgetattr(STDIN_FILENO, &tty);
+	if (tcgetattr(STDIN_FILENO, &tty) != 0)
+		return;
 
 	/* set control chars */
 	tty.c_cc[VINTR] = 3;	/* C-c */
@@ -365,10 +361,15 @@ static void set_sane_term(void)
 #endif
 
 	/* Make it be sane */
+/* On systems where the baud rate is stored in a separate field, we can safely disable these. */
+#ifndef CBAUD
+# define CBAUD 0
+# define CBAUDEX 0
+#endif
+/* Added CRTSCTS to fix Debian bug 528560 */
 #ifndef CRTSCTS
 # define CRTSCTS 0
 #endif
-	/* added CRTSCTS to fix Debian bug 528560 */
 	tty.c_cflag &= CBAUD | CBAUDEX | CSIZE | CSTOPB | PARENB | PARODD | CRTSCTS;
 	tty.c_cflag |= CREAD | HUPCL | CLOCAL;
 
@@ -412,14 +413,8 @@ static int open_stdio_to_tty(const char*
 static void reset_sighandlers_and_unblock_sigs(void)
 {
 	bb_signals(0
-		+ (1 << SIGUSR1)
-		+ (1 << SIGUSR2)
-		+ (1 << SIGTERM)
-		+ (1 << SIGQUIT)
-		+ (1 << SIGINT)
-		+ (1 << SIGHUP)
-		+ (1 << SIGTSTP)
-		+ (1 << SIGSTOP)
+		| (1 << SIGTSTP)
+		| (1 << SIGSTOP)
 		, SIG_DFL);
 	sigprocmask_allsigs(SIG_UNBLOCK);
 }
@@ -485,16 +480,13 @@ static pid_t run(const struct init_actio
 {
 	pid_t pid;
 
-	/* Careful: don't be affected by a signal in vforked child */
-	sigprocmask_allsigs(SIG_BLOCK);
 	if (BB_MMU && (a->action_type & ASKFIRST))
 		pid = fork();
 	else
 		pid = vfork();
-	if (pid < 0)
-		message(L_LOG | L_CONSOLE, "can't fork");
 	if (pid) {
-		sigprocmask_allsigs(SIG_UNBLOCK);
+		if (pid < 0)
+			message(L_LOG | L_CONSOLE, "can't fork");
 		return pid; /* Parent or error */
 	}
 
@@ -588,9 +580,11 @@ static void waitfor(pid_t pid)
 	while (1) {
 		pid_t wpid = wait(NULL);
 		mark_terminated(wpid);
-		/* Unsafe. SIGTSTP handler might have wait'ed it already */
-		/*if (wpid == pid) break;*/
-		/* More reliable: */
+		if (wpid == pid) /* this was the process we waited for */
+			break;
+		/* The above is not reliable enough: SIGTSTP handler might have
+		 * wait'ed it already. Double check, exit if process is gone:
+		 */
 		if (kill(pid, 0))
 			break;
 	}
@@ -799,23 +793,17 @@ static void run_shutdown_and_kill_proces
  * Delayed handlers just set a flag variable. The variable is checked
  * in the main loop and acted upon.
  *
- * halt/poweroff/reboot and restart have immediate handlers.
- * They only traverse linked list of struct action's, never modify it,
- * this should be safe to do even in signal handler. Also they
- * never return.
- *
  * SIGSTOP and SIGTSTP have immediate handlers. They just wait
  * for SIGCONT to happen.
  *
+ * halt/poweroff/reboot and restart have delayed handlers.
+ *
  * SIGHUP has a delayed handler, because modifying linked list
  * of struct action's from a signal handler while it is manipulated
  * by the program may be disastrous.
  *
  * Ctrl-Alt-Del has a delayed handler. Not a must, but allowing
  * it to happen even somewhere inside "sysinit" would be a bit awkward.
- *
- * There is a tiny probability that SIGHUP and Ctrl-Alt-Del will collide
- * and only one will be remembered and acted upon.
  */
 
 /* The SIGPWR/SIGUSR[12]/SIGTERM handler */
@@ -899,11 +887,9 @@ static void exec_restart_action(void)
  */
 static void stop_handler(int sig UNUSED_PARAM)
 {
-	smallint saved_bb_got_signal;
-	int saved_errno;
+	int saved_errno = errno;
 
-	saved_bb_got_signal = bb_got_signal;
-	saved_errno = errno;
+	bb_got_signal = 0;
 	signal(SIGCONT, record_signo);
 
 	while (1) {
@@ -917,12 +903,12 @@ static void stop_handler(int sig UNUSED_
 		 */
 		wpid = wait_any_nohang(NULL);
 		mark_terminated(wpid);
-		sleep(1);
+		if (wpid <= 0) /* no processes exited? sleep a bit */
+			sleep(1);
 	}
 
 	signal(SIGCONT, SIG_DFL);
 	errno = saved_errno;
-	bb_got_signal = saved_bb_got_signal;
 }
 
 #if ENABLE_FEATURE_USE_INITTAB
@@ -987,43 +973,39 @@ static void reload_inittab(void)
 }
 #endif
 
-static int check_delayed_sigs(void)
+static void check_delayed_sigs(struct timespec *ts)
 {
-	int sigs_seen = 0;
+	int sig = sigtimedwait(&G.delayed_sigset, /* siginfo_t */ NULL, ts);
+	if (sig <= 0)
+		return;
 
-	while (1) {
-		smallint sig = bb_got_signal;
+	/* The signal "sig" was caught */
 
-		if (!sig)
-			return sigs_seen;
-		bb_got_signal = 0;
-		sigs_seen = 1;
 #if ENABLE_FEATURE_USE_INITTAB
-		if (sig == SIGHUP)
-			reload_inittab();
+	if (sig == SIGHUP)
+		reload_inittab();
 #endif
-		if (sig == SIGINT)
-			run_actions(CTRLALTDEL);
-		if (sig == SIGQUIT) {
-			exec_restart_action();
-			/* returns only if no restart action defined */
-		}
-		if ((1 << sig) & (0
+	if (sig == SIGINT)
+		run_actions(CTRLALTDEL);
+	if (sig == SIGQUIT) {
+		exec_restart_action();
+		/* returns only if no restart action defined */
+	}
+	if ((1 << sig) & (0
 #ifdef SIGPWR
-		    + (1 << SIGPWR)
+	    | (1 << SIGPWR)
 #endif
-		    + (1 << SIGUSR1)
-		    + (1 << SIGUSR2)
-		    + (1 << SIGTERM)
-		)) {
-			halt_reboot_pwoff(sig);
-		}
+	    | (1 << SIGUSR1)
+	    | (1 << SIGUSR2)
+	    | (1 << SIGTERM)
+	)) {
+		halt_reboot_pwoff(sig);
 	}
+	/* if (sig == SIGCHLD) do nothing */
 }
 
 #if DEBUG_SEGV_HANDLER
-static
-void handle_sigsegv(int sig, siginfo_t *info, void *ucontext)
+static void handle_sigsegv(int sig, siginfo_t *info, void *ucontext)
 {
 	long ip;
 	ucontext_t *uc;
@@ -1050,50 +1032,62 @@ void handle_sigsegv(int sig, siginfo_t *
 
 static void sleep_much(void)
 {
-        sleep(30 * 24*60*60);
+	sleep(30 * 24*60*60);
 }
 
 int init_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int init_main(int argc UNUSED_PARAM, char **argv)
 {
+	struct sigaction sa;
+
 	INIT_G();
 
+	/* Some users send poweroff signals to init VERY early.
+	 * To handle this, mask signals early.
+	 */
+	/* sigemptyset(&G.delayed_sigset); - done by INIT_G() */
+	sigaddset(&G.delayed_sigset, SIGINT);  /* Ctrl-Alt-Del */
+	sigaddset(&G.delayed_sigset, SIGQUIT); /* re-exec another init */
+#ifdef SIGPWR
+	sigaddset(&G.delayed_sigset, SIGPWR);  /* halt */
+#endif
+	sigaddset(&G.delayed_sigset, SIGUSR1); /* halt */
+	sigaddset(&G.delayed_sigset, SIGTERM); /* reboot */
+	sigaddset(&G.delayed_sigset, SIGUSR2); /* poweroff */
+#if ENABLE_FEATURE_USE_INITTAB
+	sigaddset(&G.delayed_sigset, SIGHUP);  /* reread /etc/inittab */
+#endif
+	sigaddset(&G.delayed_sigset, SIGCHLD); /* make sigtimedwait() exit on SIGCHLD */
+	sigprocmask(SIG_BLOCK, &G.delayed_sigset, NULL);
+
+#if DEBUG_SEGV_HANDLER
+	memset(&sa, 0, sizeof(sa));
+	sa.sa_sigaction = handle_sigsegv;
+	sa.sa_flags = SA_SIGINFO;
+	sigaction_set(SIGSEGV, &sa);
+	sigaction_set(SIGILL, &sa);
+	sigaction_set(SIGFPE, &sa);
+	sigaction_set(SIGBUS, &sa);
+#endif
+
 	if (argv[1] && strcmp(argv[1], "-q") == 0) {
 		return kill(1, SIGHUP);
 	}
 
-#if DEBUG_SEGV_HANDLER
-	{
-		struct sigaction sa;
-		memset(&sa, 0, sizeof(sa));
-		sa.sa_sigaction = handle_sigsegv;
-		sa.sa_flags = SA_SIGINFO;
-		sigaction(SIGSEGV, &sa, NULL);
-		sigaction(SIGILL, &sa, NULL);
-		sigaction(SIGFPE, &sa, NULL);
-		sigaction(SIGBUS, &sa, NULL);
+#if !DEBUG_INIT
+	/* Expect to be invoked as init with PID=1 or be invoked as linuxrc */
+	if (getpid() != 1
+	 && (!ENABLE_LINUXRC || applet_name[0] != 'l') /* not linuxrc? */
+	) {
+		bb_simple_error_msg_and_die("must be run as PID 1");
 	}
-#endif
 
-	if (!DEBUG_INIT) {
-		/* Some users send poweroff signals to init VERY early.
-		 * To handle this, mask signals early,
-		 * and unmask them only after signal handlers are installed.
-		 */
-		sigprocmask_allsigs(SIG_BLOCK);
-
-		/* Expect to be invoked as init with PID=1 or be invoked as linuxrc */
-		if (getpid() != 1
-		 && (!ENABLE_LINUXRC || applet_name[0] != 'l') /* not linuxrc? */
-		) {
-			bb_error_msg_and_die("must be run as PID 1");
-		}
-#ifdef RB_DISABLE_CAD
-		/* Turn off rebooting via CTL-ALT-DEL - we get a
-		 * SIGINT on CAD so we can shut things down gracefully... */
-		reboot(RB_DISABLE_CAD); /* misnomer */
+# ifdef RB_DISABLE_CAD
+	/* Turn off rebooting via CTL-ALT-DEL - we get a
+	 * SIGINT on CAD so we can shut things down gracefully... */
+	reboot(RB_DISABLE_CAD); /* misnomer */
+# endif
 #endif
-	}
 
 	/* If, say, xmalloc would ever die, we don't want to oops kernel
 	 * by exiting.
@@ -1157,106 +1151,65 @@ int init_main(int argc UNUSED_PARAM, cha
 	}
 #endif
 
-	if (ENABLE_FEATURE_INIT_MODIFY_CMDLINE) {
-		/* Make the command line just say "init"  - that's all, nothing else */
-		strncpy(argv[0], "init", strlen(argv[0]));
-		/* Wipe argv[1]-argv[N] so they don't clutter the ps listing */
-		while (*++argv)
-			nuke_str(*argv);
-	}
-
-	/* Set up signal handlers */
-	if (!DEBUG_INIT) {
-		struct sigaction sa;
-
-		/* Stop handler must allow only SIGCONT inside itself */
-		memset(&sa, 0, sizeof(sa));
-		sigfillset(&sa.sa_mask);
-		sigdelset(&sa.sa_mask, SIGCONT);
-		sa.sa_handler = stop_handler;
-		/* NB: sa_flags doesn't have SA_RESTART.
-		 * It must be able to interrupt wait().
-		 */
-		sigaction_set(SIGTSTP, &sa); /* pause */
-		/* Does not work as intended, at least in 2.6.20.
-		 * SIGSTOP is simply ignored by init:
-		 */
-		sigaction_set(SIGSTOP, &sa); /* pause */
-
-		/* These signals must interrupt wait(),
-		 * setting handler without SA_RESTART flag.
-		 */
-		bb_signals_recursive_norestart(0
-			+ (1 << SIGINT)  /* Ctrl-Alt-Del */
-			+ (1 << SIGQUIT) /* re-exec another init */
-#ifdef SIGPWR
-			+ (1 << SIGPWR)  /* halt */
-#endif
-			+ (1 << SIGUSR1) /* halt */
-			+ (1 << SIGTERM) /* reboot */
-			+ (1 << SIGUSR2) /* poweroff */
-#if ENABLE_FEATURE_USE_INITTAB
-			+ (1 << SIGHUP)  /* reread /etc/inittab */
-#endif
-			, record_signo);
-
-		sigprocmask_allsigs(SIG_UNBLOCK);
-	}
+#if ENABLE_FEATURE_INIT_MODIFY_CMDLINE
+	/* Make the command line just say "init"  - that's all, nothing else */
+	strncpy(argv[0], "init", strlen(argv[0]));
+	/* Wipe argv[1]-argv[N] so they don't clutter the ps listing */
+	while (*++argv)
+		nuke_str(*argv);
+#endif
+
+	/* Set up STOP signal handlers */
+	/* Stop handler must allow only SIGCONT inside itself */
+	memset(&sa, 0, sizeof(sa));
+	sigfillset(&sa.sa_mask);
+	sigdelset(&sa.sa_mask, SIGCONT);
+	sa.sa_handler = stop_handler;
+	sa.sa_flags = SA_RESTART;
+	sigaction_set(SIGTSTP, &sa); /* pause */
+	/* Does not work as intended, at least in 2.6.20.
+	 * SIGSTOP is simply ignored by init
+	 * (NB: behavior might differ under strace):
+	 */
+	sigaction_set(SIGSTOP, &sa); /* pause */
 
 	/* Now run everything that needs to be run */
 	/* First run the sysinit command */
 	run_actions(SYSINIT);
-	check_delayed_sigs();
+	check_delayed_sigs(&G.zero_ts);
 	/* Next run anything that wants to block */
 	run_actions(WAIT);
-	check_delayed_sigs();
+	check_delayed_sigs(&G.zero_ts);
 	/* Next run anything to be run only once */
 	run_actions(ONCE);
 
-	/* Now run the looping stuff for the rest of forever.
-	 */
+	/* Now run the looping stuff for the rest of forever */
 	while (1) {
-		int maybe_WNOHANG;
-
-		maybe_WNOHANG = check_delayed_sigs();
-
 		/* (Re)run the respawn/askfirst stuff */
 		run_actions(RESPAWN | ASKFIRST);
-		maybe_WNOHANG |= check_delayed_sigs();
 
-		/* Don't consume all CPU time - sleep a bit */
-		sleep(1);
-		maybe_WNOHANG |= check_delayed_sigs();
+		/* Wait for any signal (typically it's SIGCHLD) */
+		check_delayed_sigs(NULL); /* NULL timespec makes it wait */
 
-		/* Wait for any child process(es) to exit.
-		 *
-		 * If check_delayed_sigs above reported that a signal
-		 * was caught, wait will be nonblocking. This ensures
-		 * that if SIGHUP has reloaded inittab, respawn and askfirst
-		 * actions will not be delayed until next child death.
-		 */
-		if (maybe_WNOHANG)
-			maybe_WNOHANG = WNOHANG;
+		/* Wait for any child process(es) to exit */
 		while (1) {
 			pid_t wpid;
 			struct init_action *a;
 
-			/* If signals happen _in_ the wait, they interrupt it,
-			 * bb_signals_recursive_norestart set them up that way
-			 */
-			wpid = waitpid(-1, NULL, maybe_WNOHANG);
+			wpid = waitpid(-1, NULL, WNOHANG);
 			if (wpid <= 0)
 				break;
 
 			a = mark_terminated(wpid);
 			if (a) {
-				message(L_LOG, "process '%s' (pid %d) exited. "
+				message(L_LOG, "process '%s' (pid %u) exited. "
 						"Scheduling for restart.",
-						a->command, wpid);
+						a->command, (unsigned)wpid);
 			}
-			/* See if anyone else is waiting to be reaped */
-			maybe_WNOHANG = WNOHANG;
 		}
+
+		/* Don't consume all CPU time - sleep a bit */
+		sleep(1);
 	} /* while (1) */
 }
 
@@ -1269,11 +1222,17 @@ int init_main(int argc UNUSED_PARAM, cha
 //usage:       "Init is the first process started during boot. It never exits."
 //usage:	IF_FEATURE_USE_INITTAB(
 //usage:   "\n""It (re)spawns children according to /etc/inittab."
+//usage:   "\n""Signals:"
+//usage:   "\n""HUP: reload /etc/inittab"
 //usage:	)
 //usage:	IF_NOT_FEATURE_USE_INITTAB(
 //usage:   "\n""This version of init doesn't use /etc/inittab,"
 //usage:   "\n""has fixed set of processed to run."
+//usage:   "\n""Signals:"
 //usage:	)
+//usage:   "\n""TSTP: stop respawning until CONT"
+//usage:   "\n""QUIT: re-exec another init"
+//usage:   "\n""USR1/TERM/USR2/INT: run halt/reboot/poweroff/Ctrl-Alt-Del script"
 //usage:
 //usage:#define init_notes_usage
 //usage:	"This version of init is designed to be run only by the kernel.\n"
diff -urpN busybox-1.31.1/libbb/appletlib.c busybox-1.32.0/libbb/appletlib.c
--- busybox-1.31.1/libbb/appletlib.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/appletlib.c	2020-06-26 22:47:44.000000000 +0400
@@ -304,7 +304,7 @@ void lbb_prepare(const char *applet
 		IF_FEATURE_INDIVIDUAL(, char **argv))
 {
 #ifdef __GLIBC__
-	(*(int **)&bb_errno) = __errno_location();
+	(*(int **)not_const_pp(&bb_errno)) = __errno_location();
 	barrier();
 #endif
 	applet_name = applet;
@@ -631,7 +631,7 @@ static void check_suid(int applet_no)
 			/* same group / in group */
 			m >>= 3;
 		if (!(m & S_IXOTH)) /* is x bit not set? */
-			bb_error_msg_and_die("you have no permission to run this applet");
+			bb_simple_error_msg_and_die("you have no permission to run this applet");
 
 		/* We set effective AND saved ids. If saved-id is not set
 		 * like we do below, seteuid(0) can still later succeed! */
@@ -643,7 +643,7 @@ static void check_suid(int applet_no)
 			rgid = sct->m_ugid.gid;
 		/* else: we will set egid = rgid, thus dropping sgid effect */
 		if (setresgid(-1, rgid, rgid))
-			bb_perror_msg_and_die("setresgid");
+			bb_simple_perror_msg_and_die("setresgid");
 
 		/* Are we directed to change uid
 		 * (APPLET = s** USER.GROUP or APPLET = S** USER.GROUP)?
@@ -653,7 +653,7 @@ static void check_suid(int applet_no)
 			uid = sct->m_ugid.uid;
 		/* else: we will set euid = ruid, thus dropping suid effect */
 		if (setresuid(-1, uid, uid))
-			bb_perror_msg_and_die("setresuid");
+			bb_simple_perror_msg_and_die("setresuid");
 
 		goto ret;
 	}
@@ -663,7 +663,7 @@ static void check_suid(int applet_no)
 
 		if (!onetime) {
 			onetime = 1;
-			bb_error_msg("using fallback suid method");
+			bb_simple_error_msg("using fallback suid method");
 		}
 	}
 #   endif
@@ -673,7 +673,7 @@ static void check_suid(int applet_no)
 		/* Real uid is not 0. If euid isn't 0 too, suid bit
 		 * is most probably not set on our executable */
 		if (geteuid())
-			bb_error_msg_and_die("must be suid to work properly");
+			bb_simple_error_msg_and_die("must be suid to work properly");
 	} else if (APPLET_SUID(applet_no) == BB_SUID_DROP) {
 		/*
 		 * Drop all privileges.
@@ -754,7 +754,9 @@ static void install_links(const char *bu
 }
 # endif
 
+# if ENABLE_BUSYBOX || NUM_APPLETS > 0
 static void run_applet_and_exit(const char *name, char **argv) NORETURN;
+#endif
 
 # if NUM_SCRIPTS > 0
 static int find_script_by_name(const char *name)
@@ -775,13 +777,13 @@ int scripted_main(int argc UNUSED_PARAM,
 {
 	int script = find_script_by_name(applet_name);
 	if (script >= 0)
-#if ENABLE_ASH || ENABLE_SH_IS_ASH || ENABLE_BASH_IS_ASH
+#  if ENABLE_SHELL_ASH
 		exit(ash_main(-script - 1, argv));
-#elif ENABLE_HUSH || ENABLE_SH_IS_HUSH || ENABLE_BASH_IS_HUSH
+#  elif ENABLE_SHELL_HUSH
 		exit(hush_main(-script - 1, argv));
-#else
+#  else
 		return 1;
-#endif
+#  endif
 	return 0;
 }
 
@@ -1024,7 +1026,33 @@ static NORETURN void run_applet_and_exit
 }
 # endif
 
-#endif /* !defined(SINGLE_APPLET_MAIN) */
+#else /* defined(SINGLE_APPLET_MAIN) */
+
+# if NUM_SCRIPTS > 0
+/* if SINGLE_APPLET_MAIN, these two functions are simpler: */
+int scripted_main(int argc UNUSED_PARAM, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int scripted_main(int argc UNUSED_PARAM, char **argv)
+{
+#  if ENABLE_SHELL_ASH
+	int script = 0;
+	exit(ash_main(-script - 1, argv));
+#  elif ENABLE_SHELL_HUSH
+	int script = 0;
+	exit(hush_main(-script - 1, argv));
+#  else
+	return 1;
+#  endif
+}
+char* FAST_FUNC
+get_script_content(unsigned n UNUSED_PARAM)
+{
+	char *t = unpack_bz2_data(packed_scripts, sizeof(packed_scripts),
+					UNPACKED_SCRIPTS_LENGTH);
+	return t;
+}
+# endif /* NUM_SCRIPTS > 0 */
+
+#endif /* defined(SINGLE_APPLET_MAIN) */
 
 
 #if ENABLE_BUILD_LIBBUSYBOX
diff -urpN busybox-1.31.1/libbb/bb_getgroups.c busybox-1.32.0/libbb/bb_getgroups.c
--- busybox-1.31.1/libbb/bb_getgroups.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/bb_getgroups.c	2020-06-26 22:47:44.000000000 +0400
@@ -38,7 +38,7 @@ gid_t* FAST_FUNC bb_getgroups(int *ngrou
 			continue;
 		}
 		/* Some other error (should never happen on Linux) */
-		bb_perror_msg_and_die("getgroups");
+		bb_simple_perror_msg_and_die("getgroups");
 	}
 
 	if (ngroups)
diff -urpN busybox-1.31.1/libbb/bbunit.c busybox-1.32.0/libbb/bbunit.c
--- busybox-1.31.1/libbb/bbunit.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/bbunit.c	2020-06-26 22:47:44.000000000 +0400
@@ -60,6 +60,6 @@ int unit_main(int argc UNUSED_PARAM, cha
 		return EXIT_FAILURE;
 	}
 
-	bb_error_msg("All tests passed");
+	bb_simple_error_msg("All tests passed");
 	return EXIT_SUCCESS;
 }
diff -urpN busybox-1.31.1/libbb/capability.c busybox-1.32.0/libbb/capability.c
--- busybox-1.31.1/libbb/capability.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/capability.c	2020-06-26 22:47:44.000000000 +0400
@@ -119,7 +119,7 @@ void FAST_FUNC getcaps(void *arg)
 			caps->u32s = _LINUX_CAPABILITY_U32S_3;
 			break;
 		default:
-			bb_error_msg_and_die("unsupported capability version");
+			bb_simple_error_msg_and_die("unsupported capability version");
 	}
 
 	if (capget(&caps->header, caps->data) != 0)
diff -urpN busybox-1.31.1/libbb/change_identity.c busybox-1.32.0/libbb/change_identity.c
--- busybox-1.31.1/libbb/change_identity.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/change_identity.c	2020-06-26 22:47:44.000000000 +0400
@@ -51,7 +51,7 @@ void FAST_FUNC change_identity(const str
 			return;
 		}
 
-		bb_perror_msg_and_die("can't set groups");
+		bb_simple_perror_msg_and_die("can't set groups");
 	}
 
 	xsetgid(pw->pw_gid);
diff -urpN busybox-1.31.1/libbb/copy_file.c busybox-1.32.0/libbb/copy_file.c
--- busybox-1.31.1/libbb/copy_file.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/copy_file.c	2020-06-26 22:47:44.000000000 +0400
@@ -327,7 +327,7 @@ int FAST_FUNC copy_file(const char *sour
 		) {
 			security_context_t con;
 			if (getfscreatecon(&con) == -1) {
-				bb_perror_msg("getfscreatecon");
+				bb_simple_perror_msg("getfscreatecon");
 				return -1;
 			}
 			if (con) {
diff -urpN busybox-1.31.1/libbb/copyfd.c busybox-1.32.0/libbb/copyfd.c
--- busybox-1.31.1/libbb/copyfd.c	2019-10-21 18:54:40.000000000 +0400
+++ busybox-1.32.0/libbb/copyfd.c	2020-06-26 22:47:44.000000000 +0400
@@ -90,7 +90,7 @@ static off_t bb_full_fd_action(int src_f
 		rd = safe_read(src_fd, buffer,
 			size > buffer_size ? buffer_size : size);
 		if (rd < 0) {
-			bb_perror_msg(bb_msg_read_error);
+			bb_simple_perror_msg(bb_msg_read_error);
 			break;
 		}
  read_ok:
@@ -103,7 +103,7 @@ static off_t bb_full_fd_action(int src_f
 			ssize_t wr = full_write(dst_fd, buffer, rd);
 			if (wr < rd) {
 				if (!continue_on_write_error) {
-					bb_perror_msg(bb_msg_write_error);
+					bb_simple_perror_msg(bb_msg_write_error);
 					break;
 				}
 				dst_fd = -1;
@@ -154,7 +154,7 @@ void FAST_FUNC bb_copyfd_exact_size(int
 	if (sz == (size >= 0 ? size : -size))
 		return;
 	if (sz != -1)
-		bb_error_msg_and_die("short read");
+		bb_simple_error_msg_and_die("short read");
 	/* if sz == -1, bb_copyfd_XX already complained */
 	xfunc_die();
 }
diff -urpN busybox-1.31.1/libbb/die_if_bad_username.c busybox-1.32.0/libbb/die_if_bad_username.c
--- busybox-1.31.1/libbb/die_if_bad_username.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/die_if_bad_username.c	2020-06-26 22:47:44.000000000 +0400
@@ -57,5 +57,5 @@ void FAST_FUNC die_if_bad_username(const
 	 * including the terminating null byte.
 	 */
 	if (name - start >= LOGIN_NAME_MAX)
-		bb_error_msg_and_die("name is too long");
+		bb_simple_error_msg_and_die("name is too long");
 }
diff -urpN busybox-1.31.1/libbb/dump.c busybox-1.32.0/libbb/dump.c
--- busybox-1.31.1/libbb/dump.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/dump.c	2020-06-26 22:47:44.000000000 +0400
@@ -199,7 +199,7 @@ static NOINLINE void rewrite(priv_dumper
 				pr->bcnt = fu->bcnt;
 				if (fu->bcnt == 0) {
 					if (!prec)
-						bb_error_msg_and_die("%%s needs precision or byte count");
+						bb_simple_error_msg_and_die("%%s needs precision or byte count");
 					pr->bcnt = atoi(prec);
 				}
 			} else
@@ -266,7 +266,7 @@ static NOINLINE void rewrite(priv_dumper
 
 			/* only one conversion character if byte count */
 			if (!(pr->flags & F_ADDRESS) && fu->bcnt && nconv++) {
-				bb_error_msg_and_die("byte count with multiple conversion characters");
+				bb_simple_error_msg_and_die("byte count with multiple conversion characters");
 			}
 		}
 		/*
diff -urpN busybox-1.31.1/libbb/duration.c busybox-1.32.0/libbb/duration.c
--- busybox-1.31.1/libbb/duration.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/duration.c	2020-06-26 22:47:44.000000000 +0400
@@ -17,6 +17,7 @@
 //kbuild:lib-$(CONFIG_TIMEOUT) += duration.o
 //kbuild:lib-$(CONFIG_PING)    += duration.o
 //kbuild:lib-$(CONFIG_PING6)   += duration.o
+//kbuild:lib-$(CONFIG_WATCH)   += duration.o
 
 #include "libbb.h"
 
diff -urpN busybox-1.31.1/libbb/fflush_stdout_and_exit.c busybox-1.32.0/libbb/fflush_stdout_and_exit.c
--- busybox-1.31.1/libbb/fflush_stdout_and_exit.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/fflush_stdout_and_exit.c	2020-06-26 22:47:44.000000000 +0400
@@ -15,7 +15,7 @@ void FAST_FUNC fflush_stdout_and_exit(in
 {
 	xfunc_error_retval = retval;
 	if (fflush(stdout))
-		bb_perror_msg_and_die(bb_msg_standard_output);
+		bb_simple_perror_msg_and_die(bb_msg_standard_output);
 	/* In case we are in NOFORK applet. Do not exit() directly,
 	 * but use xfunc_die() */
 	xfunc_die();
diff -urpN busybox-1.31.1/libbb/find_pid_by_name.c busybox-1.32.0/libbb/find_pid_by_name.c
--- busybox-1.31.1/libbb/find_pid_by_name.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/find_pid_by_name.c	2020-06-26 22:47:44.000000000 +0400
@@ -90,7 +90,11 @@ pid_t* FAST_FUNC find_pid_by_name(const
 		/* or we require argv0 to match (essential for matching reexeced /proc/self/exe)*/
 		 || (p->argv0 && strcmp(bb_basename(p->argv0), procName) == 0)
 		/* or we require /proc/PID/exe link to match */
-		 || (p->exe && strcmp(bb_basename(p->exe), procName) == 0)
+		 || (p->exe && strcmp(
+					procName[0] == '/' ? p->exe /* support "pidof /path/to/binary" case too */
+							: bb_basename(p->exe),
+					procName
+					) == 0)
 		) {
 			pidList = xrealloc_vector(pidList, 2, i);
 			pidList[i++] = p->pid;
diff -urpN busybox-1.31.1/libbb/get_console.c busybox-1.32.0/libbb/get_console.c
--- busybox-1.31.1/libbb/get_console.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/get_console.c	2020-06-26 22:47:44.000000000 +0400
@@ -62,7 +62,7 @@ int FAST_FUNC get_console_fd_or_die(void
 		}
 	}
 
-	bb_error_msg_and_die("can't open console");
+	bb_simple_error_msg_and_die("can't open console");
 }
 
 /* From <linux/vt.h> */
diff -urpN busybox-1.31.1/libbb/get_volsize.c busybox-1.32.0/libbb/get_volsize.c
--- busybox-1.31.1/libbb/get_volsize.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/get_volsize.c	2020-06-26 22:47:44.000000000 +0400
@@ -18,7 +18,7 @@ uoff_t FAST_FUNC get_volume_size_in_byte
 	if (override) {
 		result = XATOOFF(override);
 		if (result >= (uoff_t)(MAXINT(off_t)) / override_units)
-			bb_error_msg_and_die("image size is too big");
+			bb_simple_error_msg_and_die("image size is too big");
 		result *= override_units;
 		/* seek past end fails on block devices but works on files */
 		if (lseek(fd, result - 1, SEEK_SET) != (off_t)-1) {
@@ -42,7 +42,7 @@ uoff_t FAST_FUNC get_volume_size_in_byte
 	 *
 	 * Picked 16k arbitrarily: */
 	if (result < 16*1024)
-		bb_error_msg_and_die("image is too small");
+		bb_simple_error_msg_and_die("image is too small");
 
 	return result;
 }
diff -urpN busybox-1.31.1/libbb/getpty.c busybox-1.32.0/libbb/getpty.c
--- busybox-1.31.1/libbb/getpty.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/getpty.c	2020-06-26 22:47:44.000000000 +0400
@@ -23,14 +23,14 @@ int FAST_FUNC xgetpty(char *line)
 			const char *name;
 			name = ptsname(p); /* find out the name of slave pty */
 			if (!name) {
-				bb_perror_msg_and_die("ptsname error (is /dev/pts mounted?)");
+				bb_simple_perror_msg_and_die("ptsname error (is /dev/pts mounted?)");
 			}
 			safe_strncpy(line, name, GETPTY_BUFSIZE);
 		}
 # else
 		/* find out the name of slave pty */
 		if (ptsname_r(p, line, GETPTY_BUFSIZE-1) != 0) {
-			bb_perror_msg_and_die("ptsname error (is /dev/pts mounted?)");
+			bb_simple_perror_msg_and_die("ptsname error (is /dev/pts mounted?)");
 		}
 		line[GETPTY_BUFSIZE-1] = '\0';
 # endif
@@ -61,5 +61,5 @@ int FAST_FUNC xgetpty(char *line)
 		}
 	}
 #endif /* FEATURE_DEVPTS */
-	bb_error_msg_and_die("can't find free pty");
+	bb_simple_error_msg_and_die("can't find free pty");
 }
diff -urpN busybox-1.31.1/libbb/herror_msg.c busybox-1.32.0/libbb/herror_msg.c
--- busybox-1.31.1/libbb/herror_msg.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/herror_msg.c	2020-06-26 22:47:44.000000000 +0400
@@ -26,3 +26,13 @@ void FAST_FUNC bb_herror_msg_and_die(con
 	va_end(p);
 	xfunc_die();
 }
+
+void FAST_FUNC bb_simple_herror_msg(const char *s)
+{
+	bb_herror_msg("%s", s);
+}
+
+void FAST_FUNC bb_simple_herror_msg_and_die(const char *s)
+{
+	bb_herror_msg_and_die("%s", s);
+}
diff -urpN busybox-1.31.1/libbb/lineedit.c busybox-1.32.0/libbb/lineedit.c
--- busybox-1.31.1/libbb/lineedit.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/lineedit.c	2020-06-26 22:47:44.000000000 +0400
@@ -99,7 +99,7 @@ static bool BB_ispunct(CHAR_T c)
 # if ENABLE_FEATURE_EDITING_VI
 static bool BB_isalnum_or_underscore(CHAR_T c)
 {
-	return ((unsigned)c < 256 && isalnum(c)) || c == '_';
+	return isalnum(c) || c == '_';
 }
 # endif
 # define BB_ispunct(c) ispunct(c)
@@ -203,7 +203,7 @@ extern struct lineedit_statics *const li
 #define delbuf           (S.delbuf          )
 
 #define INIT_S() do { \
-	(*(struct lineedit_statics**)&lineedit_ptr_to_statics) = xzalloc(sizeof(S)); \
+	(*(struct lineedit_statics**)not_const_pp(&lineedit_ptr_to_statics)) = xzalloc(sizeof(S)); \
 	barrier(); \
 	cmdedit_termw = 80; \
 	IF_USERNAME_OR_HOMEDIR(home_pwd_buf = (char*)null_str;) \
@@ -813,18 +813,29 @@ static NOINLINE unsigned complete_cmd_di
 	}
 	pf_len = strlen(pfind);
 
-# if ENABLE_FEATURE_SH_STANDALONE && NUM_APPLETS != 1
 	if (type == FIND_EXE_ONLY && !dirbuf) {
+# if ENABLE_FEATURE_SH_STANDALONE && NUM_APPLETS != 1
 		const char *p = applet_names;
-
 		while (*p) {
 			if (strncmp(pfind, p, pf_len) == 0)
 				add_match(xstrdup(p));
 			while (*p++ != '\0')
 				continue;
 		}
-	}
 # endif
+# if EDITING_HAS_get_exe_name
+		if (state->get_exe_name) {
+			i = 0;
+			for (;;) {
+				const char *b = state->get_exe_name(i++);
+				if (!b)
+					break;
+				if (strncmp(pfind, b, pf_len) == 0)
+					add_match(xstrdup(b));
+			}
+		}
+# endif
+	}
 
 	for (i = 0; i < npaths; i++) {
 		DIR *dir;
diff -urpN busybox-1.31.1/libbb/missing_syscalls.c busybox-1.32.0/libbb/missing_syscalls.c
--- busybox-1.31.1/libbb/missing_syscalls.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/missing_syscalls.c	2020-06-26 22:47:44.000000000 +0400
@@ -15,14 +15,6 @@ pid_t getsid(pid_t pid)
 	return syscall(__NR_getsid, pid);
 }
 
-int stime(const time_t *t)
-{
-	struct timeval tv;
-	tv.tv_sec = *t;
-	tv.tv_usec = 0;
-	return settimeofday(&tv, NULL);
-}
-
 int sethostname(const char *name, size_t len)
 {
 	return syscall(__NR_sethostname, name, len);
diff -urpN busybox-1.31.1/libbb/mtab.c busybox-1.32.0/libbb/mtab.c
--- busybox-1.31.1/libbb/mtab.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/mtab.c	2020-06-26 22:47:44.000000000 +0400
@@ -21,7 +21,7 @@ void FAST_FUNC erase_mtab(const char *na
 	/* Bummer. Fall back on trying the /proc filesystem */
 	if (!mountTable) mountTable = setmntent("/proc/mounts", "r");
 	if (!mountTable) {
-		bb_perror_msg(bb_path_mtab_file);
+		bb_simple_perror_msg(bb_path_mtab_file);
 		return;
 	}
 
@@ -49,6 +49,6 @@ void FAST_FUNC erase_mtab(const char *na
 		}
 		endmntent(mountTable);
 	} else if (errno != EROFS)
-		bb_perror_msg(bb_path_mtab_file);
+		bb_simple_perror_msg(bb_path_mtab_file);
 }
 #endif
diff -urpN busybox-1.31.1/libbb/perror_nomsg.c busybox-1.32.0/libbb/perror_nomsg.c
--- busybox-1.31.1/libbb/perror_nomsg.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/perror_nomsg.c	2020-06-26 22:47:44.000000000 +0400
@@ -12,11 +12,11 @@
  * instead of including libbb.h */
 //#include "libbb.h"
 #include "platform.h"
-extern void bb_perror_msg(const char *s, ...) FAST_FUNC;
+extern void bb_simple_perror_msg(const char *s) FAST_FUNC;
 
 /* suppress gcc "no previous prototype" warning */
 void FAST_FUNC bb_perror_nomsg(void);
 void FAST_FUNC bb_perror_nomsg(void)
 {
-	bb_perror_msg(0);
+	bb_simple_perror_msg(0);
 }
diff -urpN busybox-1.31.1/libbb/perror_nomsg_and_die.c busybox-1.32.0/libbb/perror_nomsg_and_die.c
--- busybox-1.31.1/libbb/perror_nomsg_and_die.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/perror_nomsg_and_die.c	2020-06-26 22:47:44.000000000 +0400
@@ -12,11 +12,11 @@
  * instead of including libbb.h */
 //#include "libbb.h"
 #include "platform.h"
-extern void bb_perror_msg_and_die(const char *s, ...) FAST_FUNC;
+extern void bb_simple_perror_msg_and_die(const char *s) FAST_FUNC;
 
 /* suppress gcc "no previous prototype" warning */
 void FAST_FUNC bb_perror_nomsg_and_die(void);
 void FAST_FUNC bb_perror_nomsg_and_die(void)
 {
-	bb_perror_msg_and_die(0);
+	bb_simple_perror_msg_and_die(0);
 }
diff -urpN busybox-1.31.1/libbb/pw_encrypt.c busybox-1.32.0/libbb/pw_encrypt.c
--- busybox-1.31.1/libbb/pw_encrypt.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/pw_encrypt.c	2020-06-26 22:47:44.000000000 +0400
@@ -6,7 +6,9 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+#if !ENABLE_USE_BB_CRYPT
 #include <crypt.h>
+#endif
 #include "libbb.h"
 
 /* static const uint8_t ascii64[] ALIGN1 =
diff -urpN busybox-1.31.1/libbb/read.c busybox-1.32.0/libbb/read.c
--- busybox-1.31.1/libbb/read.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/read.c	2020-06-26 22:47:44.000000000 +0400
@@ -12,9 +12,17 @@ ssize_t FAST_FUNC safe_read(int fd, void
 {
 	ssize_t n;
 
-	do {
+	for (;;) {
 		n = read(fd, buf, count);
-	} while (n < 0 && errno == EINTR);
+		if (n >= 0 || errno != EINTR)
+			break;
+		/* Some callers set errno=0, are upset when they see EINTR.
+		 * Returning EINTR is wrong since we retry read(),
+		 * the "error" was transient.
+		 */
+		errno = 0;
+		/* repeat the read() */
+	}
 
 	return n;
 }
diff -urpN busybox-1.31.1/libbb/read_key.c busybox-1.32.0/libbb/read_key.c
--- busybox-1.31.1/libbb/read_key.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/read_key.c	2020-06-26 22:47:44.000000000 +0400
@@ -259,7 +259,8 @@ int64_t FAST_FUNC read_key(int fd, char
 
 			buffer[-1] = 0;
 			/* Pack into "1 <row15bits> <col16bits>" 32-bit sequence */
-			col |= (((-1 << 15) | row) << 16);
+			row |= ((unsigned)(-1) << 15);
+			col |= (row << 16);
 			/* Return it in high-order word */
 			return ((int64_t) col << 32) | (uint32_t)KEYCODE_CURSOR_POS;
 		}
diff -urpN busybox-1.31.1/libbb/read_printf.c busybox-1.32.0/libbb/read_printf.c
--- busybox-1.31.1/libbb/read_printf.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/read_printf.c	2020-06-26 22:47:44.000000000 +0400
@@ -217,7 +217,7 @@ void FAST_FUNC xread(int fd, void *buf,
 	if (count) {
 		ssize_t size = full_read(fd, buf, count);
 		if ((size_t)size != count)
-			bb_error_msg_and_die("short read");
+			bb_simple_error_msg_and_die("short read");
 	}
 }
 
diff -urpN busybox-1.31.1/libbb/replace.c busybox-1.32.0/libbb/replace.c
--- busybox-1.31.1/libbb/replace.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/replace.c	2020-06-26 22:47:44.000000000 +0400
@@ -15,6 +15,10 @@ unsigned FAST_FUNC count_strstr(const ch
 	size_t sub_len = strlen(sub);
 	unsigned count = 0;
 
+	/* If sub is empty, avoid an infinite loop */
+	if (sub_len == 0)
+		return strlen(str) + 1;
+
 	while ((str = strstr(str, sub)) != NULL) {
 		count++;
 		str += sub_len;
diff -urpN busybox-1.31.1/libbb/safe_poll.c busybox-1.32.0/libbb/safe_poll.c
--- busybox-1.31.1/libbb/safe_poll.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/safe_poll.c	2020-06-26 22:47:44.000000000 +0400
@@ -27,7 +27,7 @@ int FAST_FUNC safe_poll(struct pollfd *u
 		/* I doubt many callers would handle this correctly! */
 		if (errno == ENOMEM)
 			continue;
-		bb_perror_msg("poll");
+		bb_simple_perror_msg("poll");
 		return n;
 	}
 }
diff -urpN busybox-1.31.1/libbb/selinux_common.c busybox-1.32.0/libbb/selinux_common.c
--- busybox-1.31.1/libbb/selinux_common.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/selinux_common.c	2020-06-26 22:47:44.000000000 +0400
@@ -48,7 +48,7 @@ void FAST_FUNC selinux_preserve_fcontext
 	if (fgetfilecon(fdesc, &context) < 0) {
 		if (errno == ENODATA || errno == ENOTSUP)
 			return;
-		bb_perror_msg_and_die("fgetfilecon failed");
+		bb_simple_perror_msg_and_die("fgetfilecon failed");
 	}
 	setfscreatecon_or_die(context);
 	freecon(context);
diff -urpN busybox-1.31.1/libbb/time.c busybox-1.32.0/libbb/time.c
--- busybox-1.31.1/libbb/time.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/time.c	2020-06-26 22:47:44.000000000 +0400
@@ -253,12 +253,10 @@ char* FAST_FUNC strftime_YYYYMMDDHHMMSS(
 #define CLOCK_MONOTONIC 1
 #endif
 
-/* libc has incredibly messy way of doing this,
- * typically requiring -lrt. We just skip all this mess */
 static void get_mono(struct timespec *ts)
 {
-	if (syscall(__NR_clock_gettime, CLOCK_MONOTONIC, ts))
-		bb_error_msg_and_die("clock_gettime(MONOTONIC) failed");
+	if (clock_gettime(CLOCK_MONOTONIC, ts))
+		bb_simple_error_msg_and_die("clock_gettime(MONOTONIC) failed");
 }
 unsigned long long FAST_FUNC monotonic_ns(void)
 {
diff -urpN busybox-1.31.1/libbb/unicode.c busybox-1.32.0/libbb/unicode.c
--- busybox-1.31.1/libbb/unicode.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/unicode.c	2020-06-26 22:47:44.000000000 +0400
@@ -674,14 +674,20 @@ int FAST_FUNC wcwidth(unsigned ucs)
 		(  (/*ucs >= 0x1100 &&*/ ucs <= 0x115f) /* Hangul Jamo init. consonants */
 		|| ucs == 0x2329 /* left-pointing angle bracket; also CJK punct. char */
 		|| ucs == 0x232a /* right-pointing angle bracket; also CJK punct. char */
+#   if CONFIG_LAST_SUPPORTED_WCHAR >= 0x2e80
 		|| (ucs >= 0x2e80 && ucs <= 0xa4cf && ucs != 0x303f) /* CJK ... Yi */
+#   endif
 #   if CONFIG_LAST_SUPPORTED_WCHAR >= 0xac00
 		|| (ucs >= 0xac00 && ucs <= 0xd7a3) /* Hangul Syllables */
+#   endif
+#   if CONFIG_LAST_SUPPORTED_WCHAR >= 0xf900
 		|| (ucs >= 0xf900 && ucs <= 0xfaff) /* CJK Compatibility Ideographs */
 		|| (ucs >= 0xfe10 && ucs <= 0xfe19) /* Vertical forms */
 		|| (ucs >= 0xfe30 && ucs <= 0xfe6f) /* CJK Compatibility Forms */
 		|| (ucs >= 0xff00 && ucs <= 0xff60) /* Fullwidth Forms */
 		|| (ucs >= 0xffe0 && ucs <= 0xffe6)
+#   endif
+#   if CONFIG_LAST_SUPPORTED_WCHAR >= 0x20000
 		|| ((ucs >> 17) == (2 >> 1)) /* 20000..3ffff: Supplementary and Tertiary Ideographic Planes */
 #   endif
 		);
diff -urpN busybox-1.31.1/libbb/update_passwd.c busybox-1.32.0/libbb/update_passwd.c
--- busybox-1.31.1/libbb/update_passwd.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/update_passwd.c	2020-06-26 22:47:44.000000000 +0400
@@ -25,7 +25,7 @@ static void check_selinux_update_passwd(
 		return;  /* No need to check */
 
 	if (getprevcon_raw(&context) < 0)
-		bb_perror_msg_and_die("getprevcon failed");
+		bb_simple_perror_msg_and_die("getprevcon failed");
 	seuser = strtok(context, ":");
 	if (!seuser)
 		bb_error_msg_and_die("invalid context '%s'", context);
@@ -42,7 +42,7 @@ static void check_selinux_update_passwd(
 
 		if (selinux_check_passwd_access(av) != 0)
  die:
-			bb_error_msg_and_die("SELinux: access denied");
+			bb_simple_error_msg_and_die("SELinux: access denied");
 	}
 	if (ENABLE_FEATURE_CLEAN_UP)
 		freecon(context);
diff -urpN busybox-1.31.1/libbb/uuencode.c busybox-1.32.0/libbb/uuencode.c
--- busybox-1.31.1/libbb/uuencode.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/uuencode.c	2020-06-26 22:47:44.000000000 +0400
@@ -213,7 +213,7 @@ void FAST_FUNC read_base64(FILE *src_str
 			if (*in_tail == '\0')
 				return;
 			/* No */
-			bb_error_msg_and_die("truncated base64 input");
+			bb_simple_error_msg_and_die("truncated base64 input");
 		}
 
 		/* It was partial decode */
diff -urpN busybox-1.31.1/libbb/verror_msg.c busybox-1.32.0/libbb/verror_msg.c
--- busybox-1.31.1/libbb/verror_msg.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/verror_msg.c	2020-06-26 22:47:44.000000000 +0400
@@ -197,4 +197,19 @@ void FAST_FUNC bb_info_msg(const char *s
 	bb_vinfo_msg(s, p);
 	va_end(p);
 }
+
+void FAST_FUNC bb_simple_info_msg(const char *s)
+{
+	bb_info_msg("%s", s);
+}
 #endif
+
+void FAST_FUNC bb_simple_error_msg(const char *s)
+{
+	bb_error_msg("%s", s);
+}
+
+void FAST_FUNC bb_simple_error_msg_and_die(const char *s)
+{
+	bb_error_msg_and_die("%s", s);
+}
diff -urpN busybox-1.31.1/libbb/warn_ignoring_args.c busybox-1.32.0/libbb/warn_ignoring_args.c
--- busybox-1.31.1/libbb/warn_ignoring_args.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/warn_ignoring_args.c	2020-06-26 22:47:44.000000000 +0400
@@ -12,7 +12,7 @@
 void FAST_FUNC bb_warn_ignoring_args(char *arg)
 {
 	if (arg) {
-		bb_error_msg("ignoring all arguments");
+		bb_simple_error_msg("ignoring all arguments");
 	}
 }
 #endif
diff -urpN busybox-1.31.1/libbb/xconnect.c busybox-1.32.0/libbb/xconnect.c
--- busybox-1.31.1/libbb/xconnect.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/xconnect.c	2020-06-26 22:47:44.000000000 +0400
@@ -66,7 +66,7 @@ int FAST_FUNC setsockopt_bindtodevice(in
 int FAST_FUNC setsockopt_bindtodevice(int fd UNUSED_PARAM,
 		const char *iface UNUSED_PARAM)
 {
-	bb_error_msg("SO_BINDTODEVICE is not supported on this system");
+	bb_simple_error_msg("SO_BINDTODEVICE is not supported on this system");
 	return -1;
 }
 #endif
@@ -109,7 +109,7 @@ void FAST_FUNC xconnect(int s, const str
 			bb_perror_msg_and_die("%s (%s)",
 				"can't connect to remote host",
 				inet_ntoa(((struct sockaddr_in *)s_addr)->sin_addr));
-		bb_perror_msg_and_die("can't connect to remote host");
+		bb_simple_perror_msg_and_die("can't connect to remote host");
 	}
 }
 
diff -urpN busybox-1.31.1/libbb/xfuncs.c busybox-1.32.0/libbb/xfuncs.c
--- busybox-1.31.1/libbb/xfuncs.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/xfuncs.c	2020-06-26 22:47:44.000000000 +0400
@@ -426,6 +426,6 @@ int FAST_FUNC wait_for_exitstatus(pid_t
 
 	n = safe_waitpid(pid, &exit_status, 0);
 	if (n < 0)
-		bb_perror_msg_and_die("waitpid");
+		bb_simple_perror_msg_and_die("waitpid");
 	return exit_status;
 }
diff -urpN busybox-1.31.1/libbb/xfuncs_printf.c busybox-1.32.0/libbb/xfuncs_printf.c
--- busybox-1.31.1/libbb/xfuncs_printf.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/xfuncs_printf.c	2020-06-26 22:47:44.000000000 +0400
@@ -27,7 +27,7 @@
 
 void FAST_FUNC bb_die_memory_exhausted(void)
 {
-	bb_error_msg_and_die(bb_msg_memory_exhausted);
+	bb_simple_error_msg_and_die(bb_msg_memory_exhausted);
 }
 
 #ifndef DMALLOC
@@ -40,7 +40,7 @@ void* FAST_FUNC malloc_or_warn(size_t si
 {
 	void *ptr = malloc(size);
 	if (ptr == NULL && size != 0)
-		bb_error_msg(bb_msg_memory_exhausted);
+		bb_simple_error_msg(bb_msg_memory_exhausted);
 	return ptr;
 }
 
@@ -93,26 +93,17 @@ char* FAST_FUNC xstrdup(const char *s)
 // the (possibly truncated to length n) string into it.
 char* FAST_FUNC xstrndup(const char *s, int n)
 {
-	int m;
 	char *t;
 
 	if (ENABLE_DEBUG && s == NULL)
-		bb_error_msg_and_die("xstrndup bug");
+		bb_simple_error_msg_and_die("xstrndup bug");
 
-	/* We can just xmalloc(n+1) and strncpy into it, */
-	/* but think about xstrndup("abc", 10000) wastage! */
-	m = n;
-	t = (char*) s;
-	while (m) {
-		if (!*t) break;
-		m--;
-		t++;
-	}
-	n -= m;
-	t = xmalloc(n + 1);
-	t[n] = '\0';
+	t = strndup(s, n);
 
-	return memcpy(t, s, n);
+	if (t == NULL)
+		bb_die_memory_exhausted();
+
+	return t;
 }
 
 void* FAST_FUNC xmemdup(const void *s, int n)
@@ -215,13 +206,13 @@ int FAST_FUNC rename_or_warn(const char
 void FAST_FUNC xpipe(int filedes[2])
 {
 	if (pipe(filedes))
-		bb_perror_msg_and_die("can't create pipe");
+		bb_simple_perror_msg_and_die("can't create pipe");
 }
 
 void FAST_FUNC xdup2(int from, int to)
 {
 	if (dup2(from, to) != to)
-		bb_perror_msg_and_die("can't duplicate file descriptor");
+		bb_simple_perror_msg_and_die("can't duplicate file descriptor");
 		//		" %d to %d", from, to);
 }
 
@@ -245,7 +236,7 @@ void FAST_FUNC xwrite(int fd, const void
 			 * or some writes succeeded, then we hit an error.
 			 * In either case, errno is set.
 			 */
-			bb_perror_msg_and_die(
+			bb_simple_perror_msg_and_die(
 				size >= 0 ? "short write" : "write error"
 			);
 		}
@@ -259,7 +250,7 @@ void FAST_FUNC xwrite_str(int fd, const
 void FAST_FUNC xclose(int fd)
 {
 	if (close(fd))
-		bb_perror_msg_and_die("close failed");
+		bb_simple_perror_msg_and_die("close failed");
 }
 
 // Die with an error message if we can't lseek to the right spot.
@@ -267,9 +258,7 @@ off_t FAST_FUNC xlseek(int fd, off_t off
 {
 	off_t off = lseek(fd, offset, whence);
 	if (off == (off_t)-1) {
-		if (whence == SEEK_SET)
-			bb_perror_msg_and_die("lseek(%"OFF_FMT"u)", offset);
-		bb_perror_msg_and_die("lseek");
+		bb_perror_msg_and_die("lseek(%"OFF_FMT"u, %d)", offset, whence);
 	}
 	return off;
 }
@@ -384,23 +373,23 @@ void FAST_FUNC bb_unsetenv_and_free(char
 // setgid() will fail and we'll _still_be_root_, which is bad.)
 void FAST_FUNC xsetgid(gid_t gid)
 {
-	if (setgid(gid)) bb_perror_msg_and_die("setgid");
+	if (setgid(gid)) bb_simple_perror_msg_and_die("setgid");
 }
 
 // Die with an error message if we can't set uid.  (See xsetgid() for why.)
 void FAST_FUNC xsetuid(uid_t uid)
 {
-	if (setuid(uid)) bb_perror_msg_and_die("setuid");
+	if (setuid(uid)) bb_simple_perror_msg_and_die("setuid");
 }
 
 void FAST_FUNC xsetegid(gid_t egid)
 {
-	if (setegid(egid)) bb_perror_msg_and_die("setegid");
+	if (setegid(egid)) bb_simple_perror_msg_and_die("setegid");
 }
 
 void FAST_FUNC xseteuid(uid_t euid)
 {
-	if (seteuid(euid)) bb_perror_msg_and_die("seteuid");
+	if (seteuid(euid)) bb_simple_perror_msg_and_die("seteuid");
 }
 
 // Die if we can't chdir to a new path.
@@ -413,7 +402,7 @@ void FAST_FUNC xchdir(const char *path)
 void FAST_FUNC xfchdir(int fd)
 {
 	if (fchdir(fd))
-		bb_perror_msg_and_die("fchdir");
+		bb_simple_perror_msg_and_die("fchdir");
 }
 
 void FAST_FUNC xchroot(const char *path)
@@ -463,7 +452,7 @@ int FAST_FUNC xsocket(int domain, int ty
 IF_FEATURE_IPV6(if (domain == AF_INET6) s = "INET6";)
 		bb_perror_msg_and_die("socket(AF_%s,%d,%d)", s, type, protocol);
 #else
-		bb_perror_msg_and_die("socket");
+		bb_simple_perror_msg_and_die("socket");
 #endif
 	}
 
@@ -473,13 +462,13 @@ IF_FEATURE_IPV6(if (domain == AF_INET6)
 // Die with an error message if we can't bind a socket to an address.
 void FAST_FUNC xbind(int sockfd, struct sockaddr *my_addr, socklen_t addrlen)
 {
-	if (bind(sockfd, my_addr, addrlen)) bb_perror_msg_and_die("bind");
+	if (bind(sockfd, my_addr, addrlen)) bb_simple_perror_msg_and_die("bind");
 }
 
 // Die with an error message if we can't listen for connections on a socket.
 void FAST_FUNC xlisten(int s, int backlog)
 {
-	if (listen(s, backlog)) bb_perror_msg_and_die("listen");
+	if (listen(s, backlog)) bb_simple_perror_msg_and_die("listen");
 }
 
 /* Die with an error message if sendto failed.
@@ -491,7 +480,7 @@ ssize_t FAST_FUNC xsendto(int s, const v
 	if (ret < 0) {
 		if (ENABLE_FEATURE_CLEAN_UP)
 			close(s);
-		bb_perror_msg_and_die("sendto");
+		bb_simple_perror_msg_and_die("sendto");
 	}
 	return ret;
 }
@@ -519,12 +508,12 @@ void FAST_FUNC selinux_or_die(void)
 #if ENABLE_SELINUX
 	int rc = is_selinux_enabled();
 	if (rc == 0) {
-		bb_error_msg_and_die("SELinux is disabled");
+		bb_simple_error_msg_and_die("SELinux is disabled");
 	} else if (rc < 0) {
-		bb_error_msg_and_die("is_selinux_enabled() failed");
+		bb_simple_error_msg_and_die("is_selinux_enabled() failed");
 	}
 #else
-	bb_error_msg_and_die("SELinux support is disabled");
+	bb_simple_error_msg_and_die("SELinux support is disabled");
 #endif
 }
 
@@ -675,7 +664,7 @@ pid_t FAST_FUNC xfork(void)
 	pid_t pid;
 	pid = fork();
 	if (pid < 0) /* wtf? */
-		bb_perror_msg_and_die("vfork"+1);
+		bb_simple_perror_msg_and_die("vfork"+1);
 	return pid;
 }
 #endif
diff -urpN busybox-1.31.1/libbb/xgetcwd.c busybox-1.32.0/libbb/xgetcwd.c
--- busybox-1.31.1/libbb/xgetcwd.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/xgetcwd.c	2020-06-26 22:47:44.000000000 +0400
@@ -33,7 +33,7 @@ xrealloc_getcwd_or_warn(char *cwd)
 			if (errno == ERANGE)
 				continue;
 			free(cwd);
-			bb_perror_msg("getcwd");
+			bb_simple_perror_msg("getcwd");
 			return NULL;
 		}
 		cwd = xrealloc(cwd, strlen(cwd) + 1);
diff -urpN busybox-1.31.1/libbb/xgethostbyname.c busybox-1.32.0/libbb/xgethostbyname.c
--- busybox-1.31.1/libbb/xgethostbyname.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/xgethostbyname.c	2020-06-26 22:47:44.000000000 +0400
@@ -12,6 +12,6 @@ struct hostent* FAST_FUNC xgethostbyname
 {
 	struct hostent *retval = gethostbyname(name);
 	if (!retval)
-		bb_herror_msg_and_die("%s", name);
+		bb_simple_herror_msg_and_die(name);
 	return retval;
 }
diff -urpN busybox-1.31.1/libbb/xreadlink.c busybox-1.32.0/libbb/xreadlink.c
--- busybox-1.31.1/libbb/xreadlink.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/libbb/xreadlink.c	2020-06-26 22:47:44.000000000 +0400
@@ -147,6 +147,35 @@ char* FAST_FUNC xmalloc_realpath_coreuti
 				buf[len++] = '/';
 				strcpy(buf + len, last_slash);
 			}
+		} else {
+			char *target = xmalloc_readlink(path);
+			if (target) {
+				char *cwd;
+				if (target[0] == '/') {
+					/*
+					 * $ ln -s /bin/qwe symlink  # note: /bin is a link to /usr/bin
+					 * $ readlink -f symlink
+					 * /usr/bin/qwe/target_does_not_exist
+					 * $ realpath symlink
+					 * /usr/bin/qwe/target_does_not_exist
+					 */
+					buf = xmalloc_realpath_coreutils(target);
+					free(target);
+					return buf;
+				}
+				/*
+				 * $ ln -s target_does_not_exist symlink
+				 * $ readlink -f symlink
+				 * /CURDIR/target_does_not_exist
+				 * $ realpath symlink
+				 * /CURDIR/target_does_not_exist
+				 */
+				cwd = xrealloc_getcwd_or_warn(NULL);
+				buf = concat_path_file(cwd, target);
+				free(cwd);
+				free(target);
+				return buf;
+			}
 		}
 	}
 
diff -urpN busybox-1.31.1/loginutils/addgroup.c busybox-1.32.0/loginutils/addgroup.c
--- busybox-1.31.1/loginutils/addgroup.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/loginutils/addgroup.c	2020-06-26 22:47:44.000000000 +0400
@@ -149,7 +149,7 @@ int addgroup_main(int argc UNUSED_PARAM,
 
 	/* need to be root */
 	if (geteuid()) {
-		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 	}
 	/* Syntax:
 	 *  addgroup group
diff -urpN busybox-1.31.1/loginutils/adduser.c busybox-1.32.0/loginutils/adduser.c
--- busybox-1.31.1/loginutils/adduser.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/loginutils/adduser.c	2020-06-26 22:47:44.000000000 +0400
@@ -159,7 +159,7 @@ static void passwd_wrapper(const char *l
 static void passwd_wrapper(const char *login_name)
 {
 	BB_EXECLP("passwd", "passwd", "--", login_name, NULL);
-	bb_error_msg_and_die("can't execute passwd, you must set password manually");
+	bb_simple_error_msg_and_die("can't execute passwd, you must set password manually");
 }
 
 //FIXME: upstream adduser has no short options! NOT COMPATIBLE!
@@ -193,7 +193,7 @@ int adduser_main(int argc UNUSED_PARAM,
 
 	/* got root? */
 	if (geteuid()) {
-		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 	}
 
 	pw.pw_gecos = (char *)"Linux User,,,";
diff -urpN busybox-1.31.1/loginutils/chpasswd.c busybox-1.32.0/loginutils/chpasswd.c
--- busybox-1.31.1/loginutils/chpasswd.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/loginutils/chpasswd.c	2020-06-26 22:47:44.000000000 +0400
@@ -63,7 +63,7 @@ int chpasswd_main(int argc UNUSED_PARAM,
 	int opt;
 
 	if (getuid() != 0)
-		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 
 	opt = getopt32long(argv, "^" "emc:R:" "\0" "m--ec:e--mc:c--em",
 			chpasswd_longopts,
@@ -81,7 +81,7 @@ int chpasswd_main(int argc UNUSED_PARAM,
 
 		pass = strchr(name, ':');
 		if (!pass)
-			bb_error_msg_and_die("missing new password");
+			bb_simple_error_msg_and_die("missing new password");
 		*pass++ = '\0';
 
 		xuname2uid(name); /* dies if there is no such user */
diff -urpN busybox-1.31.1/loginutils/deluser.c busybox-1.32.0/loginutils/deluser.c
--- busybox-1.31.1/loginutils/deluser.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/loginutils/deluser.c	2020-06-26 22:47:44.000000000 +0400
@@ -76,7 +76,7 @@ int deluser_main(int argc, char **argv)
 #endif
 
 	if (geteuid() != 0)
-		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 
 	name = argv[1];
 	member = NULL;
@@ -99,8 +99,14 @@ int deluser_main(int argc, char **argv)
 			pfile = bb_path_passwd_file;
 			if (ENABLE_FEATURE_SHADOWPASSWDS)
 				sfile = bb_path_shadow_file;
-			if (opt_delhome)
-				remove_file(pw->pw_dir, FILEUTILS_RECUR);
+			if (opt_delhome) {
+				struct stat st;
+
+				/* Make sure home is an actual directory before
+				 * removing it (e.g. users with /dev/null as home) */
+				if (stat(pw->pw_dir, &st) == 0 && S_ISDIR(st.st_mode))
+					remove_file(pw->pw_dir, FILEUTILS_RECUR);
+			}
 		} else {
 			struct group *gr;
  do_delgroup:
diff -urpN busybox-1.31.1/loginutils/getty.c busybox-1.32.0/loginutils/getty.c
--- busybox-1.31.1/loginutils/getty.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/loginutils/getty.c	2020-06-26 22:47:44.000000000 +0400
@@ -168,7 +168,7 @@ static void parse_speeds(char *arg)
 		/* note: arg "0" turns into speed B0 */
 		G.numspeed++;
 		if (G.numspeed > MAX_SPEED)
-			bb_error_msg_and_die("too many alternate speeds");
+			bb_simple_error_msg_and_die("too many alternate speeds");
 	}
 	debug("exiting parse_speeds\n");
 }
@@ -230,7 +230,7 @@ static void open_tty(void)
 		 * Make sure it is open for read/write.
 		 */
 		if ((fcntl(0, F_GETFL) & (O_RDWR|O_RDONLY|O_WRONLY)) != O_RDWR)
-			bb_error_msg_and_die("stdin is not open for read/write");
+			bb_simple_error_msg_and_die("stdin is not open for read/write");
 
 		/* Try to get real tty name instead of "-" */
 		n = xmalloc_ttyname(0);
@@ -243,7 +243,7 @@ static void open_tty(void)
 static void set_tty_attrs(void)
 {
 	if (tcsetattr_stdin_TCSANOW(&G.tty_attrs) < 0)
-		bb_perror_msg_and_die("tcsetattr");
+		bb_simple_perror_msg_and_die("tcsetattr");
 }
 
 /* We manipulate tty_attrs this way:
@@ -485,7 +485,7 @@ static char *get_logname(void)
 				finalize_tty_attrs();
 				if (errno == EINTR || errno == EIO)
 					exit(EXIT_SUCCESS);
-				bb_perror_msg_and_die(bb_msg_read_error);
+				bb_simple_perror_msg_and_die(bb_msg_read_error);
 			}
 
 			switch (c) {
@@ -582,7 +582,7 @@ int getty_main(int argc UNUSED_PARAM, ch
 			//	" sid %d pgid %d",
 			//	pid, getppid(),
 			//	getsid(0), getpgid(0));
-			bb_perror_msg_and_die("setsid");
+			bb_simple_perror_msg_and_die("setsid");
 			/*
 			 * When we can end up here?
 			 * Example: setsid() fails when run alone in interactive shell:
@@ -651,13 +651,13 @@ int getty_main(int argc UNUSED_PARAM, ch
 	tsid = tcgetsid(STDIN_FILENO);
 	if (tsid < 0 || pid != tsid) {
 		if (ioctl(STDIN_FILENO, TIOCSCTTY, /*force:*/ (long)1) < 0)
-			bb_perror_msg_and_die("TIOCSCTTY");
+			bb_simple_perror_msg_and_die("TIOCSCTTY");
 	}
 
 #ifdef __linux__
 	/* Make ourself a foreground process group within our session */
 	if (tcsetpgrp(STDIN_FILENO, pid) < 0)
-		bb_perror_msg_and_die("tcsetpgrp");
+		bb_simple_perror_msg_and_die("tcsetpgrp");
 #endif
 
 	/*
@@ -669,7 +669,7 @@ int getty_main(int argc UNUSED_PARAM, ch
 	 * 5 seconds seems to be a good value.
 	 */
 	if (tcgetattr(STDIN_FILENO, &G.tty_attrs) < 0)
-		bb_perror_msg_and_die("tcgetattr");
+		bb_simple_perror_msg_and_die("tcgetattr");
 
 	/* Update the utmp file. This tty is ours now! */
 	update_utmp(pid, LOGIN_PROCESS, G.tty_name, "LOGIN", G.fakehost);
diff -urpN busybox-1.31.1/loginutils/login.c busybox-1.32.0/loginutils/login.c
--- busybox-1.31.1/loginutils/login.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/loginutils/login.c	2020-06-26 22:47:44.000000000 +0400
@@ -358,7 +358,7 @@ int login_main(int argc UNUSED_PARAM, ch
 	opt = getopt32(argv, "f:h:p", &opt_user, &opt_host);
 	if (opt & LOGIN_OPT_f) {
 		if (!run_by_root)
-			bb_error_msg_and_die("-f is for root only");
+			bb_simple_error_msg_and_die("-f is for root only");
 		safe_strncpy(username, opt_user, sizeof(username));
 	}
 	argv += optind;
@@ -529,7 +529,7 @@ int login_main(int argc UNUSED_PARAM, ch
 	child_pid = vfork();
 	if (child_pid != 0) {
 		if (child_pid < 0)
-			bb_perror_msg("vfork");
+			bb_simple_perror_msg("vfork");
 		else {
 			wait_for_exitstatus(child_pid);
 			update_utmp_DEAD_PROCESS(child_pid);
diff -urpN busybox-1.31.1/loginutils/su.c busybox-1.32.0/loginutils/su.c
--- busybox-1.31.1/loginutils/su.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/loginutils/su.c	2020-06-26 22:47:44.000000000 +0400
@@ -147,7 +147,7 @@ int su_main(int argc UNUSED_PARAM, char
 			syslog(LOG_NOTICE, "%c %s %s:%s",
 				'-', tty, old_user, opt_username);
 		bb_do_delay(LOGIN_FAIL_DELAY);
-		bb_error_msg_and_die("incorrect password");
+		bb_simple_error_msg_and_die("incorrect password");
 	}
 
 	if (ENABLE_FEATURE_CLEAN_UP && ENABLE_FEATURE_SU_SYSLOG) {
@@ -165,7 +165,7 @@ int su_main(int argc UNUSED_PARAM, char
 		 * probably a uucp account or has restricted access.  Don't
 		 * compromise the account by allowing access with a standard
 		 * shell.  */
-		bb_error_msg("using restricted shell");
+		bb_simple_error_msg("using restricted shell");
 		opt_shell = NULL; /* ignore -s PROG */
 	}
 	/* else: user can run whatever he wants via "su -s PROG USER".
diff -urpN busybox-1.31.1/loginutils/sulogin.c busybox-1.32.0/loginutils/sulogin.c
--- busybox-1.31.1/loginutils/sulogin.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/loginutils/sulogin.c	2020-06-26 22:47:44.000000000 +0400
@@ -56,7 +56,7 @@ int sulogin_main(int argc UNUSED_PARAM,
 
 	pwd = getpwuid(0);
 	if (!pwd) {
-		bb_error_msg_and_die("no password entry for root");
+		bb_simple_error_msg_and_die("no password entry for root");
 	}
 
 	while (1) {
@@ -68,17 +68,17 @@ int sulogin_main(int argc UNUSED_PARAM,
 		);
 		if (r < 0) {
 			/* ^D, ^C, timeout, or read error */
-			bb_info_msg("normal startup");
+			bb_simple_info_msg("normal startup");
 			return 0;
 		}
 		if (r > 0) {
 			break;
 		}
 		bb_do_delay(LOGIN_FAIL_DELAY);
-		bb_info_msg("Login incorrect");
+		bb_simple_info_msg("Login incorrect");
 	}
 
-	bb_info_msg("starting shell for system maintenance");
+	bb_simple_info_msg("starting shell for system maintenance");
 
 	IF_SELINUX(renew_current_security_context());
 
diff -urpN busybox-1.31.1/mailutils/mail.c busybox-1.32.0/mailutils/mail.c
--- busybox-1.31.1/mailutils/mail.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/mailutils/mail.c	2020-06-26 22:47:44.000000000 +0400
@@ -15,7 +15,7 @@ static void signal_handler(int signo)
 {
 #define err signo
 	if (SIGALRM == signo) {
-		bb_error_msg_and_die("timed out");
+		bb_simple_error_msg_and_die("timed out");
 	}
 
 	// SIGCHLD. reap zombies
@@ -128,7 +128,7 @@ static void encode_n_base64(const char *
 		if (fname) {
 			size = fread((char *)src_buf, 1, SRC_BUF_SIZE, fp);
 			if ((ssize_t)size < 0)
-				bb_perror_msg_and_die(bb_msg_read_error);
+				bb_simple_perror_msg_and_die(bb_msg_read_error);
 		} else {
 			size = len;
 			if (len > SRC_BUF_SIZE)
@@ -179,5 +179,5 @@ void FAST_FUNC get_cred_or_die(int fd)
 		G.pass = xmalloc_reads(fd, /* maxsize: */ NULL);
 	}
 	if (!G.user || !*G.user || !G.pass)
-		bb_error_msg_and_die("no username or password");
+		bb_simple_error_msg_and_die("no username or password");
 }
diff -urpN busybox-1.31.1/mailutils/popmaildir.c busybox-1.32.0/mailutils/popmaildir.c
--- busybox-1.31.1/mailutils/popmaildir.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/mailutils/popmaildir.c	2020-06-26 22:47:44.000000000 +0400
@@ -222,7 +222,7 @@ int popmaildir_main(int argc UNUSED_PARA
 			fp = popen(delivery, "w");
 			unsetenv("FILENAME");
 			if (!fp) {
-				bb_perror_msg("delivery helper");
+				bb_simple_perror_msg("delivery helper");
 				break;
 			}
 		} else
diff -urpN busybox-1.31.1/mailutils/sendmail.c busybox-1.32.0/mailutils/sendmail.c
--- busybox-1.31.1/mailutils/sendmail.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/mailutils/sendmail.c	2020-06-26 22:47:44.000000000 +0400
@@ -338,7 +338,7 @@ int sendmail_main(int argc UNUSED_PARAM,
 			smtp_check(NULL, 250);
 		else
 		if (code != 250)
-			bb_error_msg_and_die("SMTP init failed");
+			bb_simple_error_msg_and_die("SMTP init failed");
 	} else {
 		// vanilla connection
 		int fd;
diff -urpN busybox-1.31.1/make_single_applets.sh busybox-1.32.0/make_single_applets.sh
--- busybox-1.31.1/make_single_applets.sh	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/make_single_applets.sh	2020-06-26 22:47:44.000000000 +0400
@@ -29,6 +29,8 @@ for app in $apps; do
 done
 # remove "busybox" as well
 allno="`echo "$allno" | sed "s/^CONFIG_BUSYBOX=y\$/# CONFIG_BUSYBOX is not set/"`"
+# disable any CONFIG_script_DEPENDENCIES as well
+allno="`echo "$allno" | sed "s/^\(CONFIG_.*_DEPENDENCIES\)=y\$/# \1 is not set/"`"
 #echo "$allno" >.config_allno
 
 trap 'test -f .config.SV && mv .config.SV .config && touch .config' EXIT
diff -urpN busybox-1.31.1/miscutils/bc.c busybox-1.32.0/miscutils/bc.c
--- busybox-1.31.1/miscutils/bc.c	2019-10-21 18:54:40.000000000 +0400
+++ busybox-1.32.0/miscutils/bc.c	2020-06-26 22:47:44.000000000 +0400
@@ -844,10 +844,10 @@ struct globals {
 # error Strange INT_MAX
 #endif
 
-#if UINT_MAX == 4294967295
+#if UINT_MAX == 4294967295U
 # define BC_MAX_SCALE_STR  "4294967295"
 # define BC_MAX_STRING_STR "4294967294"
-#elif UINT_MAX == 18446744073709551615
+#elif UINT_MAX == 18446744073709551615U
 # define BC_MAX_SCALE_STR  "18446744073709551615"
 # define BC_MAX_STRING_STR "18446744073709551614"
 #else
@@ -893,7 +893,7 @@ static void fflush_and_check(void)
 {
 	fflush_all();
 	if (ferror(stdout) || ferror(stderr))
-		bb_perror_msg_and_die("output error");
+		bb_simple_perror_msg_and_die("output error");
 }
 
 #if ENABLE_FEATURE_CLEAN_UP
@@ -908,7 +908,7 @@ static void quit(void) NORETURN;
 static void quit(void)
 {
 	if (ferror(stdin))
-		bb_perror_msg_and_die("input error");
+		bb_simple_perror_msg_and_die("input error");
 	fflush_and_check();
 	dbg_exec("quit(): exiting with exitcode SUCCESS");
 	exit(0);
@@ -1465,7 +1465,10 @@ static ssize_t bc_num_cmp(BcNum *a, BcNu
 	b_int = BC_NUM_INT(b);
 	a_int -= b_int;
 
-	if (a_int != 0) return (ssize_t) a_int;
+	if (a_int != 0) {
+		if (neg) return - (ssize_t) a_int;
+		return (ssize_t) a_int;
+	}
 
 	a_max = (a->rdx > b->rdx);
 	if (a_max) {
@@ -2519,7 +2522,9 @@ static void xc_read_line(BcVec *vec, FIL
 
 #if ENABLE_FEATURE_BC_INTERACTIVE
 	if (G_interrupt) { // ^C was pressed
+# if ENABLE_FEATURE_EDITING
  intr:
+# endif
 		if (fp != stdin) {
 			// ^C while running a script (bc SCRIPT): die.
 			// We do not return to interactive prompt:
@@ -2576,7 +2581,7 @@ static void xc_read_line(BcVec *vec, FIL
 				goto get_char;
 			if (c == EOF) {
 				if (ferror(fp))
-					bb_perror_msg_and_die("input error");
+					bb_simple_perror_msg_and_die("input error");
 				// Note: EOF does not append '\n'
 				break;
 			}
@@ -6934,9 +6939,9 @@ static BC_STATUS zxc_vm_process(const ch
 		ip = (void*)G.prog.exestack.v;
 #if SANITY_CHECKS
 		if (G.prog.exestack.len != 1) // should have only main's IP
-			bb_error_msg_and_die("BUG:call stack");
+			bb_simple_error_msg_and_die("BUG:call stack");
 		if (ip->func != BC_PROG_MAIN)
-			bb_error_msg_and_die("BUG:not MAIN");
+			bb_simple_error_msg_and_die("BUG:not MAIN");
 #endif
 		f = xc_program_func_BC_PROG_MAIN();
 		// bc discards strings, constants and code after each
@@ -6952,7 +6957,7 @@ static BC_STATUS zxc_vm_process(const ch
 		if (IS_BC) {
 #if SANITY_CHECKS
 			if (G.prog.results.len != 0) // should be empty
-				bb_error_msg_and_die("BUG:data stack");
+				bb_simple_error_msg_and_die("BUG:data stack");
 #endif
 			IF_BC(bc_vec_pop_all(&f->strs);)
 			IF_BC(bc_vec_pop_all(&f->consts);)
diff -urpN busybox-1.31.1/miscutils/chat.c busybox-1.32.0/miscutils/chat.c
--- busybox-1.31.1/miscutils/chat.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/chat.c	2020-06-26 22:47:44.000000000 +0400
@@ -307,7 +307,7 @@ int chat_main(int argc UNUSED_PARAM, cha
 			} else if (DIR_SAY == key) {
 				// just print argument verbatim
 				// TODO: should we use full_write() to avoid unistd/stdio conflict?
-				bb_error_msg("%s", arg);
+				bb_simple_error_msg(arg);
 			}
 			// next, please!
 			argv++;
diff -urpN busybox-1.31.1/miscutils/crond.c busybox-1.32.0/miscutils/crond.c
--- busybox-1.31.1/miscutils/crond.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/crond.c	2020-06-26 22:47:44.000000000 +0400
@@ -731,7 +731,7 @@ fork_job(const char *user, int mailFd, C
 	logmode = sv_logmode;
 
 	if (pid < 0) {
-		bb_perror_msg("vfork");
+		bb_simple_perror_msg("vfork");
  err:
 		pid = 0;
 	} /* else: PARENT, FORK SUCCESS */
@@ -861,7 +861,7 @@ static pid_t start_one_job(const char *u
 		bb_error_msg_and_die("can't execute '%s' for user %s", shell, user);
 	}
 	if (pid < 0) {
-		bb_perror_msg("vfork");
+		bb_simple_perror_msg("vfork");
  err:
 		pid = 0;
 	}
diff -urpN busybox-1.31.1/miscutils/crontab.c busybox-1.32.0/miscutils/crontab.c
--- busybox-1.31.1/miscutils/crontab.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/crontab.c	2020-06-26 22:47:44.000000000 +0400
@@ -107,7 +107,7 @@ int crontab_main(int argc UNUSED_PARAM,
 	if (sanitize_env_if_suid()) { /* Clears dangerous stuff, sets PATH */
 		/* Run by non-root */
 		if (opt_ler & (OPT_u|OPT_c))
-			bb_error_msg_and_die(bb_msg_you_must_be_root);
+			bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 	}
 
 	if (opt_ler & OPT_u) {
diff -urpN busybox-1.31.1/miscutils/dc.c busybox-1.32.0/miscutils/dc.c
--- busybox-1.31.1/miscutils/dc.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/dc.c	2020-06-26 22:47:44.000000000 +0400
@@ -39,14 +39,14 @@ static unsigned check_under(void)
 {
 	unsigned p = pointer;
 	if (p == 0)
-		bb_error_msg_and_die("stack underflow");
+		bb_simple_error_msg_and_die("stack underflow");
 	return p - 1;
 }
 
 static void push(double a)
 {
 	if (pointer >= STACK_SIZE)
-		bb_error_msg_and_die("stack overflow");
+		bb_simple_error_msg_and_die("stack overflow");
 	stack[pointer++] = a;
 }
 
diff -urpN busybox-1.31.1/miscutils/devfsd.c busybox-1.32.0/miscutils/devfsd.c
--- busybox-1.31.1/miscutils/devfsd.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/devfsd.c	2020-06-26 22:47:44.000000000 +0400
@@ -344,14 +344,20 @@ static const char bb_msg_variable_not_fo
 /* Busybox stuff */
 #if ENABLE_DEVFSD_VERBOSE || ENABLE_DEBUG
 #define info_logger(p, fmt, args...)                 bb_info_msg(fmt, ## args)
+#define simple_info_logger(p, msg)                   bb_simple_info_msg(msg)
 #define msg_logger(p, fmt, args...)                  bb_error_msg(fmt, ## args)
+#define simple_msg_logger(p, msg)                    bb_simple_error_msg(msg)
 #define msg_logger_and_die(p, fmt, args...)          bb_error_msg_and_die(fmt, ## args)
+#define simple_msg_logger_and_die(p, msg)            bb_simple_error_msg_and_die(msg)
 #define error_logger(p, fmt, args...)                bb_perror_msg(fmt, ## args)
 #define error_logger_and_die(p, fmt, args...)        bb_perror_msg_and_die(fmt, ## args)
 #else
 #define info_logger(p, fmt, args...)
+#define simple_info_logger(p, msg)
 #define msg_logger(p, fmt, args...)
+#define simple_msg_logger(p, msg)
 #define msg_logger_and_die(p, fmt, args...)           exit(EXIT_FAILURE)
+#define simple_msg_logger_and_die(p, msg)             exit(EXIT_FAILURE)
 #define error_logger(p, fmt, args...)
 #define error_logger_and_die(p, fmt, args...)         exit(EXIT_FAILURE)
 #endif
@@ -727,7 +733,7 @@ static int do_servicing(int fd, unsigned
 		caught_sighup = FALSE;
 		return c_sighup;
 	}
-	msg_logger_and_die(LOG_ERR, "read error on control file");
+	simple_msg_logger_and_die(LOG_ERR, "read error on control file");
 }   /*  End Function do_servicing  */
 
 static void service_name(const struct devfsd_notify_struct *info)
@@ -786,7 +792,7 @@ static void service_name(const struct de
 				action_compat(info, entry->action.what);
 				break;
 			default:
-				msg_logger_and_die(LOG_ERR, "Unknown action");
+				simple_msg_logger_and_die(LOG_ERR, "Unknown action");
 		}
 	}
 }   /*  End Function service_name  */
@@ -1691,7 +1697,7 @@ int st_expr_expand(char *output, unsigne
 	}
 	return FALSE;
 st_expr_expand_out:
-	info_logger(LOG_INFO, bb_msg_small_buffer);
+	simple_info_logger(LOG_INFO, bb_msg_small_buffer);
 	return FALSE;
 }   /*  End Function st_expr_expand  */
 
@@ -1775,7 +1781,7 @@ static const char *expand_variable(char
 		return input + len;
 	}
 	if (ch != ':' || ptr[1] != '-') {
-		info_logger(LOG_INFO, "illegal char in var name");
+		simple_info_logger(LOG_INFO, "illegal char in var name");
 		return NULL;
 	}
 	/*  It's that handy "${var:-word}" expression. Check if var is defined  */
@@ -1838,7 +1844,7 @@ static const char *expand_variable(char
 	*out_pos += len;
 	return input;
 expand_variable_out:
-	info_logger(LOG_INFO, bb_msg_small_buffer);
+	simple_info_logger(LOG_INFO, bb_msg_small_buffer);
 	return NULL;
 }   /*  End Function expand_variable  */
 
diff -urpN busybox-1.31.1/miscutils/devmem.c busybox-1.32.0/miscutils/devmem.c
--- busybox-1.31.1/miscutils/devmem.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/devmem.c	2020-06-26 22:47:44.000000000 +0400
@@ -89,7 +89,7 @@ int devmem_main(int argc UNUSED_PARAM, c
 			fd,
 			target & ~(off_t)(page_size - 1));
 	if (map_base == MAP_FAILED)
-		bb_perror_msg_and_die("mmap");
+		bb_simple_perror_msg_and_die("mmap");
 
 //	printf("Memory mapped at address %p.\n", map_base);
 
@@ -110,7 +110,7 @@ int devmem_main(int argc UNUSED_PARAM, c
 			read_result = *(volatile uint64_t*)virt_addr;
 			break;
 		default:
-			bb_error_msg_and_die("bad width");
+			bb_simple_error_msg_and_die("bad width");
 		}
 //		printf("Value at address 0x%"OFF_FMT"X (%p): 0x%llX\n",
 //			target, virt_addr,
@@ -136,7 +136,7 @@ int devmem_main(int argc UNUSED_PARAM, c
 //			read_result = *(volatile uint64_t*)virt_addr;
 			break;
 		default:
-			bb_error_msg_and_die("bad width");
+			bb_simple_error_msg_and_die("bad width");
 		}
 //		printf("Written 0x%llX; readback 0x%llX\n",
 //				(unsigned long long)writeval,
@@ -145,7 +145,7 @@ int devmem_main(int argc UNUSED_PARAM, c
 
 	if (ENABLE_FEATURE_CLEAN_UP) {
 		if (munmap(map_base, mapped_size) == -1)
-			bb_perror_msg_and_die("munmap");
+			bb_simple_perror_msg_and_die("munmap");
 		close(fd);
 	}
 
diff -urpN busybox-1.31.1/miscutils/fbsplash.c busybox-1.32.0/miscutils/fbsplash.c
--- busybox-1.31.1/miscutils/fbsplash.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/fbsplash.c	2020-06-26 22:47:44.000000000 +0400
@@ -183,7 +183,7 @@ static void fb_open(const char *strfb_de
 			(G.scr_var.yres_virtual ?: G.scr_var.yres) * G.scr_fix.line_length,
 			PROT_WRITE, MAP_SHARED, fbfd, 0);
 	if (G.addr == MAP_FAILED)
-		bb_perror_msg_and_die("mmap");
+		bb_simple_perror_msg_and_die("mmap");
 
 	// point to the start of the visible screen
 	G.addr += G.scr_var.yoffset * G.scr_fix.line_length + G.scr_var.xoffset * G.bytes_per_pixel;
diff -urpN busybox-1.31.1/miscutils/flash_eraseall.c busybox-1.32.0/miscutils/flash_eraseall.c
--- busybox-1.31.1/miscutils/flash_eraseall.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/flash_eraseall.c	2020-06-26 22:47:44.000000000 +0400
@@ -120,7 +120,7 @@ int flash_eraseall_main(int argc UNUSED_
 				if (clmlen > 8)
 					clmlen = 8;
 				if (clmlen == 0)
-					bb_error_msg_and_die("autoplacement selected and no empty space in oob");
+					bb_simple_error_msg_and_die("autoplacement selected and no empty space in oob");
 			} else {
 				/* Legacy mode */
 				switch (meminfo.oobsize) {
@@ -168,9 +168,9 @@ int flash_eraseall_main(int argc UNUSED_
 				if (errno == EOPNOTSUPP) {
 					flags |= OPTION_N;
 					if (flags & IS_NAND)
-						bb_error_msg_and_die("bad block check not available");
+						bb_simple_error_msg_and_die("bad block check not available");
 				} else {
-					bb_perror_msg_and_die("MEMGETBADBLOCK error");
+					bb_simple_perror_msg_and_die("MEMGETBADBLOCK error");
 				}
 			}
 		}
diff -urpN busybox-1.31.1/miscutils/hdparm.c busybox-1.32.0/miscutils/hdparm.c
--- busybox-1.31.1/miscutils/hdparm.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/hdparm.c	2020-06-26 22:47:44.000000000 +0400
@@ -810,7 +810,7 @@ static void identify(uint16_t *val)
 		like_std = 3;
 	} else
 		/* "Unknown device type:\n\tbits 15&14 of general configuration word 0 both set to 1.\n" */
-		bb_error_msg_and_die("unknown device type");
+		bb_simple_error_msg_and_die("unknown device type");
 
 	printf("%sremovable media\n", !(val[GEN_CONFIG] & MEDIA_REMOVABLE) ? "non-" : "");
 	/* Info from the specific configuration word says whether or not the
@@ -996,7 +996,7 @@ static void identify(uint16_t *val)
 					/* check Endian of capacity bytes */
 					nn = val[LCYLS_CUR] * val[LHEADS_CUR] * val[LSECTS_CUR];
 					oo = (uint32_t)val[CAPACITY_LSB] << 16 | val[CAPACITY_MSB];
-					if (abs(mm - nn) > abs(oo - nn))
+					if (abs((int)(mm - nn)) > abs((int)(oo - nn)))
 						mm = oo;
 				}
 				printf("\tCHS current addressable sectors:%11u\n", mm);
@@ -1440,7 +1440,7 @@ static void flush_buffer_cache(/*int fd*
 	sleep(1);
 	if (ioctl(fd, HDIO_DRIVE_CMD, NULL) && errno != EINVAL) {	/* await completion */
 		if (ENABLE_IOCTL_HEX2STR_ERROR) /* To be coherent with ioctl_or_warn */
-			bb_perror_msg("HDIO_DRIVE_CMD");
+			bb_simple_perror_msg("HDIO_DRIVE_CMD");
 		else
 			bb_perror_msg("ioctl %#x failed", HDIO_DRIVE_CMD);
 	}
@@ -1506,7 +1506,7 @@ static void do_time(int cache /*,int fd*
 	char *buf = xmalloc(TIMING_BUF_BYTES);
 
 	if (mlock(buf, TIMING_BUF_BYTES))
-		bb_perror_msg_and_die("mlock");
+		bb_simple_perror_msg_and_die("mlock");
 
 	/* Clear out the device request queues & give them time to complete.
 	 * NB: *small* delay. User is expected to have a clue and to not run
@@ -1857,7 +1857,7 @@ static void process_dev(char *devname)
 		char buf[512];
 		flush_buffer_cache();
 		if (-1 == read(fd, buf, sizeof(buf)))
-			bb_perror_msg("read of 512 bytes failed");
+			bb_simple_perror_msg("read of 512 bytes failed");
 	}
 #endif  /* HDIO_DRIVE_CMD */
 	if (getset_mult || get_identity) {
@@ -1865,7 +1865,7 @@ static void process_dev(char *devname)
 		if (ioctl(fd, HDIO_GET_MULTCOUNT, &multcount)) {
 			/* To be coherent with ioctl_or_warn. */
 			if (getset_mult && ENABLE_IOCTL_HEX2STR_ERROR)
-				bb_perror_msg("HDIO_GET_MULTCOUNT");
+				bb_simple_perror_msg("HDIO_GET_MULTCOUNT");
 			else
 				bb_perror_msg("ioctl %#x failed", HDIO_GET_MULTCOUNT);
 		} else if (getset_mult) {
@@ -1985,7 +1985,7 @@ static void process_dev(char *devname)
 		} else if (errno == -ENOMSG)
 			puts(" no identification info available");
 		else if (ENABLE_IOCTL_HEX2STR_ERROR)  /* To be coherent with ioctl_or_warn */
-			bb_perror_msg("HDIO_GET_IDENTITY");
+			bb_simple_perror_msg("HDIO_GET_IDENTITY");
 		else
 			bb_perror_msg("ioctl %#x failed", HDIO_GET_IDENTITY);
 	}
diff -urpN busybox-1.31.1/miscutils/hexedit.c busybox-1.32.0/miscutils/hexedit.c
--- busybox-1.31.1/miscutils/hexedit.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/hexedit.c	2020-06-26 22:47:44.000000000 +0400
@@ -193,7 +193,7 @@ static int remap(unsigned cur_pos)
 	);
 	if (G.baseaddr == MAP_FAILED) {
 		restore_term();
-		bb_perror_msg_and_die("mmap");
+		bb_simple_perror_msg_and_die("mmap");
 	}
 
 	G.current_byte = G.baseaddr + cur_pos;
diff -urpN busybox-1.31.1/miscutils/i2c_tools.c busybox-1.32.0/miscutils/i2c_tools.c
--- busybox-1.31.1/miscutils/i2c_tools.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/i2c_tools.c	2020-06-26 22:47:44.000000000 +0400
@@ -344,7 +344,7 @@ static void get_funcs_matrix(int fd, uns
 static void check_funcs_test_end(int funcs, int pec, const char *err)
 {
 	if (pec && !(funcs & (I2C_FUNC_SMBUS_PEC | I2C_FUNC_I2C)))
-		bb_error_msg("warning: adapter does not support PEC");
+		bb_simple_error_msg("warning: adapter does not support PEC");
 
 	if (err)
 		bb_error_msg_and_die(
@@ -392,7 +392,7 @@ static void check_read_funcs(int fd, int
 		break;
 #endif /* ENABLE_I2CDUMP */
 	default:
-		bb_error_msg_and_die("internal error");
+		bb_simple_error_msg_and_die("internal error");
 	}
 	check_funcs_test_end(funcs, pec, err);
 }
@@ -438,7 +438,7 @@ static void confirm_or_abort(void)
 {
 	fprintf(stderr, "Continue? [y/N] ");
 	if (!bb_ask_y_confirmation())
-		bb_error_msg_and_die("aborting");
+		bb_simple_error_msg_and_die("aborting");
 }
 
 /*
@@ -449,20 +449,20 @@ static void confirm_or_abort(void)
  */
 static void confirm_action(int bus_addr, int mode, int data_addr, int pec)
 {
-	bb_error_msg("WARNING! This program can confuse your I2C bus");
+	bb_simple_error_msg("WARNING! This program can confuse your I2C bus");
 
 	/* Don't let the user break his/her EEPROMs */
 	if (bus_addr >= 0x50 && bus_addr <= 0x57 && pec) {
-		bb_error_msg_and_die("this is I2C not smbus - using PEC on I2C "
+		bb_simple_error_msg_and_die("this is I2C not smbus - using PEC on I2C "
 			"devices may result in data loss, aborting");
 	}
 
 	if (mode == I2C_SMBUS_BYTE && data_addr >= 0 && pec)
-		bb_error_msg("WARNING! May interpret a write byte command "
+		bb_simple_error_msg("WARNING! May interpret a write byte command "
 			"with PEC as a write byte data command");
 
 	if (pec)
-		bb_error_msg("PEC checking enabled");
+		bb_simple_error_msg("PEC checking enabled");
 
 	confirm_or_abort();
 }
@@ -507,7 +507,7 @@ int i2cget_main(int argc UNUSED_PARAM, c
 			case 'w':	mode = I2C_SMBUS_WORD_DATA;	break;
 			case 'c':	mode = I2C_SMBUS_BYTE;		break;
 			default:
-				bb_error_msg("invalid mode");
+				bb_simple_error_msg("invalid mode");
 				bb_show_usage();
 			}
 			pec = argv[3][1] == 'p';
@@ -529,7 +529,7 @@ int i2cget_main(int argc UNUSED_PARAM, c
 		if (data_addr >= 0) {
 			status = i2c_smbus_write_byte(fd, data_addr);
 			if (status < 0)
-				bb_error_msg("warning - write failed");
+				bb_simple_error_msg("warning - write failed");
 		}
 		status = i2c_smbus_read_byte(fd);
 		break;
@@ -542,7 +542,7 @@ int i2cget_main(int argc UNUSED_PARAM, c
 	close(fd);
 
 	if (status < 0)
-		bb_perror_msg_and_die("read failed");
+		bb_simple_perror_msg_and_die("read failed");
 
 	printf("0x%0*x\n", mode == I2C_SMBUS_WORD_DATA ? 4 : 2, status);
 
@@ -611,7 +611,7 @@ int i2cset_main(int argc, char **argv)
 			case 'i': mode = I2C_SMBUS_I2C_BLOCK_DATA;
 				break;
 			default:
-				bb_error_msg("invalid mode");
+				bb_simple_error_msg("invalid mode");
 				bb_show_usage();
 			}
 
@@ -620,11 +620,11 @@ int i2cset_main(int argc, char **argv)
 			 || mode == I2C_SMBUS_I2C_BLOCK_DATA
 			) {
 				if (pec && mode == I2C_SMBUS_I2C_BLOCK_DATA)
-					bb_error_msg_and_die(
+					bb_simple_error_msg_and_die(
 						"PEC not supported for I2C "
 						"block writes");
 				if (opts & opt_m)
-					bb_error_msg_and_die(
+					bb_simple_error_msg_and_die(
 						"mask not supported for block "
 						"writes");
 			}
@@ -685,7 +685,7 @@ int i2cset_main(int argc, char **argv)
 		}
 
 		if (tmpval < 0)
-			bb_perror_msg_and_die("can't read old value");
+			bb_simple_perror_msg_and_die("can't read old value");
 
 		val = (val & mask) | (tmpval & ~mask);
 
@@ -724,7 +724,7 @@ int i2cset_main(int argc, char **argv)
 		break;
 	}
 	if (status < 0)
-		bb_perror_msg_and_die("write failed");
+		bb_simple_perror_msg_and_die("write failed");
 
 	if (pec)
 		i2c_set_pec(fd, 0); /* Clear PEC. */
@@ -978,12 +978,12 @@ int i2cdump_main(int argc UNUSED_PARAM,
 		case 's': mode = I2C_SMBUS_BLOCK_DATA;		break;
 		case 'i': mode = I2C_SMBUS_I2C_BLOCK_DATA;	break;
 		default:
-			bb_error_msg_and_die("invalid mode");
+			bb_simple_error_msg_and_die("invalid mode");
 		}
 
 		if (argv[2][1] == 'p') {
 			if (argv[2][0] == 'W' || argv[2][0] == 'i') {
-				bb_error_msg_and_die(
+				bb_simple_error_msg_and_die(
 					"pec not supported for -W and -i");
 			} else {
 				pec = 1;
@@ -994,7 +994,7 @@ int i2cdump_main(int argc UNUSED_PARAM,
 	if (opts & opt_r) {
 		first = strtol(opt_r_str, &dash, 0);
 		if (dash == opt_r_str || *dash != '-' || first > 0xff)
-			bb_error_msg_and_die("invalid range");
+			bb_simple_error_msg_and_die("invalid range");
 		last = xstrtou_range(++dash, 0, first, 0xff);
 
 		/* Range is not available for every mode. */
@@ -1007,7 +1007,7 @@ int i2cdump_main(int argc UNUSED_PARAM,
 				break;
 			/* Fall through */
 		default:
-			bb_error_msg_and_die(
+			bb_simple_error_msg_and_die(
 				"range not compatible with selected mode");
 		}
 	}
@@ -1032,7 +1032,7 @@ int i2cdump_main(int argc UNUSED_PARAM,
 		if (mode == I2C_SMBUS_BYTE) {
 			res = i2c_smbus_write_byte(fd, first);
 			if (res < 0)
-				bb_perror_msg_and_die("write start address");
+				bb_simple_perror_msg_and_die("write start address");
 		}
 
 		dump_data(fd, mode, first, last, block, blen);
@@ -1398,7 +1398,7 @@ static void check_i2c_func(int fd)
 	get_funcs_matrix(fd, &funcs);
 
 	if (!(funcs & I2C_FUNC_I2C))
-		bb_error_msg_and_die("adapter does not support I2C transfers");
+		bb_simple_error_msg_and_die("adapter does not support I2C transfers");
 }
 
 //usage:#define i2ctransfer_trivial_usage
@@ -1451,7 +1451,7 @@ int i2ctransfer_main(int argc UNUSED_PAR
 		char *end;
 
 		if (nmsgs >= I2C_RDWR_IOCTL_MAX_MSGS)
-			bb_error_msg_and_die("too many messages, max: "I2C_RDWR_IOCTL_MAX_MSGS_STR);
+			bb_simple_error_msg_and_die("too many messages, max: "I2C_RDWR_IOCTL_MAX_MSGS_STR);
 
 		flags = 0;
 		arg_ptr = *argv;
diff -urpN busybox-1.31.1/miscutils/inotifyd.c busybox-1.32.0/miscutils/inotifyd.c
--- busybox-1.31.1/miscutils/inotifyd.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/inotifyd.c	2020-06-26 22:47:44.000000000 +0400
@@ -117,7 +117,7 @@ int inotifyd_main(int argc, char **argv)
 	// open inotify
 	pfd.fd = inotify_init();
 	if (pfd.fd < 0)
-		bb_perror_msg_and_die("no kernel support");
+		bb_simple_perror_msg_and_die("no kernel support");
 
 	// setup watches
 	while (*++argv) {
diff -urpN busybox-1.31.1/miscutils/mim.c busybox-1.32.0/miscutils/mim.c
--- busybox-1.31.1/miscutils/mim.c	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/miscutils/mim.c	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,15 @@
+//config:config MIM
+//config:	bool "mim (0.5 kb)"
+//config:	default y
+//config:	depends on FEATURE_SH_EMBEDDED_SCRIPTS
+//config:	help
+//config:	Run a script from a Makefile-like specification file.
+//config:	Unlike 'make' dependencies aren't supported.
+
+//applet:IF_MIM(APPLET_SCRIPTED(mim, scripted, BB_DIR_USR_SBIN, BB_SUID_DROP, mim))
+
+//usage:#define mim_trivial_usage
+//usage:	"[-f FILE] [SHELL_OPTIONS] [TARGET] ..."
+//usage:#define mim_full_usage "\n\n"
+//usage:	"Run a script from a Makefile-like specification file\n"
+//usage:     "\n	-f FILE		Spec file (default Mimfile)"
diff -urpN busybox-1.31.1/miscutils/nandwrite.c busybox-1.32.0/miscutils/nandwrite.c
--- busybox-1.31.1/miscutils/nandwrite.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/nandwrite.c	2020-06-26 22:47:44.000000000 +0400
@@ -101,7 +101,7 @@ static unsigned next_good_eraseblock(int
 
 		if (block_offset >= meminfo->size) {
 			if (IS_NANDWRITE)
-				bb_error_msg_and_die("not enough space in MTD device");
+				bb_simple_error_msg_and_die("not enough space in MTD device");
 			return block_offset; /* let the caller exit */
 		}
 		offs = block_offset;
@@ -174,7 +174,7 @@ int nandwrite_main(int argc UNUSED_PARAM
 	meminfo_writesize = meminfo.writesize;
 
 	if (mtdoffset & (meminfo_writesize - 1))
-		bb_error_msg_and_die("start address is not page aligned");
+		bb_simple_error_msg_and_die("start address is not page aligned");
 
 	filebuf = xmalloc(meminfo_writesize);
 	oobbuf = xmalloc(meminfo.oobsize);
@@ -248,9 +248,9 @@ int nandwrite_main(int argc UNUSED_PARAM
 		}
 		if (cnt < meminfo_writesize) {
 			if (IS_NANDDUMP)
-				bb_error_msg_and_die("short read");
+				bb_simple_error_msg_and_die("short read");
 			if (!(opts & OPT_p))
-				bb_error_msg_and_die("input size is not rounded up to page size, "
+				bb_simple_error_msg_and_die("input size is not rounded up to page size, "
 						"use -p to zero pad");
 			/* zero pad to end of write block */
 			memset(filebuf + cnt, 0, meminfo_writesize - cnt);
@@ -273,7 +273,7 @@ int nandwrite_main(int argc UNUSED_PARAM
 		/* We filled entire MTD, but did we reach EOF on input? */
 		if (full_read(STDIN_FILENO, filebuf, meminfo_writesize) != 0) {
 			/* no */
-			bb_error_msg_and_die("not enough space in MTD device");
+			bb_simple_error_msg_and_die("not enough space in MTD device");
 		}
 	}
 
diff -urpN busybox-1.31.1/miscutils/rfkill.c busybox-1.32.0/miscutils/rfkill.c
--- busybox-1.31.1/miscutils/rfkill.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/rfkill.c	2020-06-26 22:47:44.000000000 +0400
@@ -88,7 +88,7 @@ int rfkill_main(int argc UNUSED_PARAM, c
 
 	rf_fd = device_open("/dev/rfkill", mode);
 	if (rf_fd < 0)
-		bb_perror_msg_and_die("/dev/rfkill");
+		bb_simple_perror_msg_and_die("/dev/rfkill");
 
 	if (rf_opt & OPT_l) {
 		while (full_read(rf_fd, &event, sizeof(event)) == RFKILL_EVENT_SIZE_V1) {
diff -urpN busybox-1.31.1/miscutils/rx.c busybox-1.32.0/miscutils/rx.c
--- busybox-1.31.1/miscutils/rx.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/rx.c	2020-06-26 22:47:44.000000000 +0400
@@ -120,7 +120,7 @@ static int receive(/*int read_fd, */int
 		/* Write previously received block */
 		errno = 0;
 		if (full_write(file_fd, blockBuf, blockLength) != blockLength) {
-			bb_perror_msg(bb_msg_write_error);
+			bb_simple_perror_msg(bb_msg_write_error);
 			goto fatal;
 		}
 
@@ -150,7 +150,7 @@ static int receive(/*int read_fd, */int
 			goto timeout;
 
 		if (blockNo != (255 - blockNoOnesCompl)) {
-			bb_error_msg("bad block ones compl");
+			bb_simple_error_msg("bad block ones compl");
 			goto error;
 		}
 
@@ -229,7 +229,7 @@ static int receive(/*int read_fd, */int
 				do_crc = 0;
 				goto timeout;
 			}
-			bb_error_msg("too many errors; giving up");
+			bb_simple_error_msg("too many errors; giving up");
  fatal:
 			/* 5 CAN followed by 5 BS. Don't try too hard... */
 			safe_write(write_fd, "\030\030\030\030\030\010\010\010\010\010", 10);
diff -urpN busybox-1.31.1/miscutils/time.c busybox-1.32.0/miscutils/time.c
--- busybox-1.31.1/miscutils/time.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/time.c	2020-06-26 22:47:44.000000000 +0400
@@ -88,7 +88,7 @@ static void resuse_end(pid_t pid, resour
 	 * returns the child process, set the time the command finished. */
 	while ((caught = wait3(&resp->waitstatus, 0, &resp->ru)) != pid) {
 		if (caught == -1 && errno != EINTR) {
-			bb_perror_msg("wait");
+			bb_simple_perror_msg("wait");
 			return;
 		}
 	}
diff -urpN busybox-1.31.1/miscutils/ubi_tools.c busybox-1.32.0/miscutils/ubi_tools.c
--- busybox-1.31.1/miscutils/ubi_tools.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/ubi_tools.c	2020-06-26 22:47:44.000000000 +0400
@@ -234,10 +234,10 @@ int ubi_tools_main(int argc UNUSED_PARAM
 			//	bb_error_msg_and_die("%s invalid maximum size calculated", "UBI");
 		} else
 		if (!(opts & OPTION_s))
-			bb_error_msg_and_die("size not specified");
+			bb_simple_error_msg_and_die("size not specified");
 
 		if (!(opts & OPTION_N))
-			bb_error_msg_and_die("name not specified");
+			bb_simple_error_msg_and_die("name not specified");
 
 		/* the structure is memset(0) above */
 		mkvol_req.vol_id = vol_id;
@@ -264,7 +264,7 @@ int ubi_tools_main(int argc UNUSED_PARAM
 //usage:     "\n	-N VOLNAME	Volume name"
 	if (do_rmvol) {
 		if (!(opts & (OPTION_n|OPTION_N)))
-			bb_error_msg_and_die("volume id not specified");
+			bb_simple_error_msg_and_die("volume id not specified");
 
 		if (opts & OPTION_N) {
 			unsigned num = ubi_devnum_from_devname(ubi_ctrl);
@@ -288,9 +288,9 @@ int ubi_tools_main(int argc UNUSED_PARAM
 //usage:     "\n	-s SIZE		Size in bytes"
 	if (do_rsvol) {
 		if (!(opts & OPTION_s))
-			bb_error_msg_and_die("size not specified");
+			bb_simple_error_msg_and_die("size not specified");
 		if (!(opts & OPTION_n))
-			bb_error_msg_and_die("volume id not specified");
+			bb_simple_error_msg_and_die("volume id not specified");
 
 		rsvol_req.bytes = size_bytes; /* signed int64_t */
 		rsvol_req.vol_id = vol_id;
diff -urpN busybox-1.31.1/miscutils/ubirename.c busybox-1.32.0/miscutils/ubirename.c
--- busybox-1.31.1/miscutils/ubirename.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/miscutils/ubirename.c	2020-06-26 22:47:44.000000000 +0400
@@ -72,7 +72,7 @@ int ubirename_main(int argc, char **argv
 	rnvol = xzalloc(sizeof(*rnvol));
 	rnvol->count = --argc;
 	if (argc > ARRAY_SIZE(rnvol->ents))
-		bb_error_msg_and_die("too many renames requested");
+		bb_simple_error_msg_and_die("too many renames requested");
 
 	ubi_devname = argv[1];
 	ubi_devnum = ubi_devnum_from_devname(ubi_devname);
diff -urpN busybox-1.31.1/modutils/modutils-24.c busybox-1.32.0/modutils/modutils-24.c
--- busybox-1.31.1/modutils/modutils-24.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/modutils/modutils-24.c	2020-06-26 22:47:44.000000000 +0400
@@ -2600,7 +2600,7 @@ static void new_get_kernel_symbols(void)
 			module_names = xrealloc(module_names, bufsize);
 			goto retry_modules_load;
 		}
-		bb_perror_msg_and_die("QM_MODULES");
+		bb_simple_perror_msg_and_die("QM_MODULES");
 	}
 
 	n_ext_modules = nmod = ret;
@@ -2661,7 +2661,7 @@ static void new_get_kernel_symbols(void)
 			syms = xrealloc(syms, bufsize);
 			goto retry_kern_sym_load;
 		}
-		bb_perror_msg_and_die("kernel: QM_SYMBOLS");
+		bb_simple_perror_msg_and_die("kernel: QM_SYMBOLS");
 	}
 	nksyms = nsyms = ret;
 	ksyms = syms;
@@ -3247,21 +3247,21 @@ static struct obj_file *obj_load(char *i
 	f->load_order_search_start = &f->load_order;
 
 	if (image_size < sizeof(f->header))
-		bb_error_msg_and_die("error while loading ELF header");
+		bb_simple_error_msg_and_die("error while loading ELF header");
 	memcpy(&f->header, image, sizeof(f->header));
 
 	if (*(aliased_uint32_t*)(&f->header.e_ident) != ELFMAG_U32) {
-		bb_error_msg_and_die("not an ELF file");
+		bb_simple_error_msg_and_die("not an ELF file");
 	}
 	if (f->header.e_ident[EI_CLASS] != ELFCLASSM
 	 || f->header.e_ident[EI_DATA] != (BB_BIG_ENDIAN ? ELFDATA2MSB : ELFDATA2LSB)
 	 || f->header.e_ident[EI_VERSION] != EV_CURRENT
 	 || !MATCH_MACHINE(f->header.e_machine)
 	) {
-		bb_error_msg_and_die("ELF file not for this architecture");
+		bb_simple_error_msg_and_die("ELF file not for this architecture");
 	}
 	if (f->header.e_type != ET_REL) {
-		bb_error_msg_and_die("ELF file not a relocatable object");
+		bb_simple_error_msg_and_die("ELF file not a relocatable object");
 	}
 
 	/* Read the section headers.  */
@@ -3280,7 +3280,7 @@ static struct obj_file *obj_load(char *i
 
 	section_headers = alloca(sizeof(ElfW(Shdr)) * shnum);
 	if (image_size < f->header.e_shoff + sizeof(ElfW(Shdr)) * shnum)
-		bb_error_msg_and_die("error while loading section headers");
+		bb_simple_error_msg_and_die("error while loading section headers");
 	memcpy(section_headers, image + f->header.e_shoff, sizeof(ElfW(Shdr)) * shnum);
 
 	/* Read the section data.  */
@@ -3317,16 +3317,16 @@ static struct obj_file *obj_load(char *i
 				if (sec->header.sh_size > 0) {
 					sec->contents = xmalloc(sec->header.sh_size);
 					if (image_size < (sec->header.sh_offset + sec->header.sh_size))
-						bb_error_msg_and_die("error while loading section data");
+						bb_simple_error_msg_and_die("error while loading section data");
 					memcpy(sec->contents, image + sec->header.sh_offset, sec->header.sh_size);
 				}
 				break;
 #if SHT_RELM == SHT_REL
 			case SHT_RELA:
-				bb_error_msg_and_die("RELA relocations not supported on this architecture");
+				bb_simple_error_msg_and_die("RELA relocations not supported on this architecture");
 #else
 			case SHT_REL:
-				bb_error_msg_and_die("REL relocations not supported on this architecture");
+				bb_simple_error_msg_and_die("REL relocations not supported on this architecture");
 #endif
 			default:
 				if (sec->header.sh_type >= SHT_LOPROC) {
@@ -3447,7 +3447,7 @@ static int obj_load_progbits(char *image
 			continue;
 		sec->contents = imagebase + (sec->header.sh_addr - base);
 		if (image_size < (sec->header.sh_offset + sec->header.sh_size)) {
-			bb_error_msg("error reading ELF section data");
+			bb_simple_error_msg("error reading ELF section data");
 			return 0; /* need to delete half-loaded module! */
 		}
 		memcpy(sec->contents, image + sec->header.sh_offset, sec->header.sh_size);
@@ -3845,7 +3845,7 @@ int FAST_FUNC bb_init_module_24(const ch
 		if (m_has_modinfo) {
 			int m_version = new_get_module_version(f, m_strversion);
 			if (m_version == -1) {
-				bb_error_msg_and_die("can't find the kernel version "
+				bb_simple_error_msg_and_die("can't find the kernel version "
 					"the module was compiled for");
 			}
 		}
@@ -3864,7 +3864,7 @@ int FAST_FUNC bb_init_module_24(const ch
 #endif
 
 	if (query_module(NULL, 0, NULL, 0, NULL))
-		bb_error_msg_and_die("old (unsupported) kernel");
+		bb_simple_error_msg_and_die("old (unsupported) kernel");
 	new_get_kernel_symbols();
 	k_crcs = new_is_kernel_checksummed();
 
diff -urpN busybox-1.31.1/modutils/rmmod.c busybox-1.32.0/modutils/rmmod.c
--- busybox-1.31.1/modutils/rmmod.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/modutils/rmmod.c	2020-06-26 22:47:44.000000000 +0400
@@ -52,7 +52,7 @@ int rmmod_main(int argc UNUSED_PARAM, ch
 		/* Unload _all_ unused modules via NULL delete_module() call */
 		err = bb_delete_module(NULL, flags);
 		if (err && err != EFAULT)
-			bb_perror_msg_and_die("rmmod");
+			bb_simple_perror_msg_and_die("rmmod");
 		return EXIT_SUCCESS;
 	}
 
diff -urpN busybox-1.31.1/networking/arp.c busybox-1.32.0/networking/arp.c
--- busybox-1.31.1/networking/arp.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/arp.c	2020-06-26 22:47:44.000000000 +0400
@@ -116,7 +116,7 @@ static int arp_del(char **args)
 	/* Resolve the host name. */
 	host = *args;
 	if (ap->input(host, &sa) < 0) {
-		bb_herror_msg_and_die("%s", host);
+		bb_simple_herror_msg_and_die(host);
 	}
 
 	/* If a host has more than one address, use the correct one! */
@@ -149,7 +149,7 @@ static int arp_del(char **args)
 #ifdef HAVE_ATF_DONTPUB
 			req.arp_flags |= ATF_DONTPUB;
 #else
-			bb_error_msg("feature ATF_DONTPUB is not supported");
+			bb_simple_error_msg("feature ATF_DONTPUB is not supported");
 #endif
 			args++;
 			break;
@@ -157,7 +157,7 @@ static int arp_del(char **args)
 #ifdef HAVE_ATF_MAGIC
 			req.arp_flags |= ATF_MAGIC;
 #else
-			bb_error_msg("feature ATF_MAGIC is not supported");
+			bb_simple_error_msg("feature ATF_MAGIC is not supported");
 #endif
 			args++;
 			break;
@@ -173,7 +173,7 @@ static int arp_del(char **args)
 			if (strcmp(*args, "255.255.255.255") != 0) {
 				host = *args;
 				if (ap->input(host, &sa) < 0) {
-					bb_herror_msg_and_die("%s", host);
+					bb_simple_herror_msg_and_die(host);
 				}
 				memcpy(&req.arp_netmask, &sa, sizeof(struct sockaddr));
 				req.arp_flags |= ATF_NETMASK;
@@ -195,7 +195,7 @@ static int arp_del(char **args)
 	/* Call the kernel. */
 	if (flags & 2) {
 		if (option_mask32 & ARP_OPT_v)
-			bb_error_msg("SIOCDARP(nopub)");
+			bb_simple_error_msg("SIOCDARP(nopub)");
 		err = ioctl(sockfd, SIOCDARP, &req);
 		if (err < 0) {
 			if (errno == ENXIO) {
@@ -204,20 +204,20 @@ static int arp_del(char **args)
 				printf("No ARP entry for %s\n", host);
 				return -1;
 			}
-			bb_perror_msg_and_die("SIOCDARP(priv)");
+			bb_simple_perror_msg_and_die("SIOCDARP(priv)");
 		}
 	}
 	if ((flags & 1) && err) {
  nopub:
 		req.arp_flags |= ATF_PUBL;
 		if (option_mask32 & ARP_OPT_v)
-			bb_error_msg("SIOCDARP(pub)");
+			bb_simple_error_msg("SIOCDARP(pub)");
 		if (ioctl(sockfd, SIOCDARP, &req) < 0) {
 			if (errno == ENXIO) {
 				printf("No ARP entry for %s\n", host);
 				return -1;
 			}
-			bb_perror_msg_and_die("SIOCDARP(pub)");
+			bb_simple_perror_msg_and_die("SIOCDARP(pub)");
 		}
 	}
 	return 0;
@@ -233,7 +233,7 @@ static void arp_getdevhw(char *ifname, s
 	ioctl_or_perror_and_die(sockfd, SIOCGIFHWADDR, &ifr,
 					"can't get HW-Address for '%s'", ifname);
 	if (hw_set && (ifr.ifr_hwaddr.sa_family != hw->type)) {
-		bb_error_msg_and_die("protocol type mismatch");
+		bb_simple_error_msg_and_die("protocol type mismatch");
 	}
 	memcpy(sa, &(ifr.ifr_hwaddr), sizeof(struct sockaddr));
 
@@ -261,20 +261,20 @@ static int arp_set(char **args)
 
 	host = *args++;
 	if (ap->input(host, &sa) < 0) {
-		bb_herror_msg_and_die("%s", host);
+		bb_simple_herror_msg_and_die(host);
 	}
 	/* If a host has more than one address, use the correct one! */
 	memcpy(&req.arp_pa, &sa, sizeof(struct sockaddr));
 
 	/* Fetch the hardware address. */
 	if (*args == NULL) {
-		bb_error_msg_and_die("need hardware address");
+		bb_simple_error_msg_and_die("need hardware address");
 	}
 	if (option_mask32 & ARP_OPT_D) {
 		arp_getdevhw(*args++, &req.arp_ha);
 	} else {
 		if (hw->input(*args++, &req.arp_ha) < 0) {
-			bb_error_msg_and_die("invalid hardware address");
+			bb_simple_error_msg_and_die("invalid hardware address");
 		}
 	}
 
@@ -302,7 +302,7 @@ static int arp_set(char **args)
 #ifdef HAVE_ATF_DONTPUB
 			flags |= ATF_DONTPUB;
 #else
-			bb_error_msg("feature ATF_DONTPUB is not supported");
+			bb_simple_error_msg("feature ATF_DONTPUB is not supported");
 #endif
 			args++;
 			break;
@@ -310,7 +310,7 @@ static int arp_set(char **args)
 #ifdef HAVE_ATF_MAGIC
 			flags |= ATF_MAGIC;
 #else
-			bb_error_msg("feature ATF_MAGIC is not supported");
+			bb_simple_error_msg("feature ATF_MAGIC is not supported");
 #endif
 			args++;
 			break;
@@ -326,7 +326,7 @@ static int arp_set(char **args)
 			if (strcmp(*args, "255.255.255.255") != 0) {
 				host = *args;
 				if (ap->input(host, &sa) < 0) {
-					bb_herror_msg_and_die("%s", host);
+					bb_simple_herror_msg_and_die(host);
 				}
 				memcpy(&req.arp_netmask, &sa, sizeof(struct sockaddr));
 				flags |= ATF_NETMASK;
@@ -346,7 +346,7 @@ static int arp_set(char **args)
 
 	/* Call the kernel. */
 	if (option_mask32 & ARP_OPT_v)
-		bb_error_msg("SIOCSARP()");
+		bb_simple_error_msg("SIOCSARP()");
 	xioctl(sockfd, SIOCSARP, &req);
 	return 0;
 }
@@ -422,7 +422,7 @@ static int arp_show(char *name)
 	if (name != NULL) {
 		/* Resolve the host name. */
 		if (ap->input(name, &sa) < 0) {
-			bb_herror_msg_and_die("%s", name);
+			bb_simple_herror_msg_and_die(name);
 		}
 		host = xstrdup(ap->sprint(&sa, 1));
 	}
@@ -530,7 +530,7 @@ int arp_main(int argc UNUSED_PARAM, char
 	/* Now see what we have to do here... */
 	if (opts & (ARP_OPT_d | ARP_OPT_s)) {
 		if (argv[0] == NULL)
-			bb_error_msg_and_die("need host name");
+			bb_simple_error_msg_and_die("need host name");
 		if (opts & ARP_OPT_s)
 			return arp_set(argv);
 		return arp_del(argv);
diff -urpN busybox-1.31.1/networking/arping.c busybox-1.32.0/networking/arping.c
--- busybox-1.31.1/networking/arping.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/arping.c	2020-06-26 22:47:44.000000000 +0400
@@ -375,7 +375,7 @@ int arping_main(int argc UNUSED_PARAM, c
 			xconnect(probe_fd, (struct sockaddr *) &G.probe_saddr, sizeof(G.probe_saddr));
 			bb_getsockname(probe_fd, (struct sockaddr *) &G.probe_saddr, sizeof(G.probe_saddr));
 			if (G.probe_saddr.sin_family != AF_INET)
-				bb_error_msg_and_die("no IP address configured");
+				bb_simple_error_msg_and_die("no IP address configured");
 			src = G.probe_saddr.sin_addr;
 		}
 		close(probe_fd);
@@ -430,7 +430,7 @@ int arping_main(int argc UNUSED_PARAM, c
 		/* Don't allow SIGALRMs while we process the reply */
 		sigprocmask(SIG_BLOCK, &G.sset, NULL);
 		if (cc < 0) {
-			bb_perror_msg("recvfrom");
+			bb_simple_perror_msg("recvfrom");
 			continue;
 		}
 		recv_pack(G.packet, cc, &from);
diff -urpN busybox-1.31.1/networking/brctl.c busybox-1.32.0/networking/brctl.c
--- busybox-1.31.1/networking/brctl.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/brctl.c	2020-06-26 22:47:44.000000000 +0400
@@ -53,7 +53,9 @@
 //usage:     "\n	addif BRIDGE IFACE	Add IFACE to BRIDGE"
 //usage:     "\n	delif BRIDGE IFACE	Delete IFACE from BRIDGE"
 //usage:	IF_FEATURE_BRCTL_FANCY(
-//usage:     "\n	stp BRIDGE 1/yes/on|0/no/off	STP on/off"
+//usage:     "\n	showmacs BRIDGE			List MAC addresses"
+//usage:     "\n	showstp	BRIDGE			Show STP info"
+//usage:     "\n	stp BRIDGE 1/yes/on|0/no/off	Set STP on/off"
 //usage:     "\n	setageing BRIDGE SECONDS	Set ageing time"
 //usage:     "\n	setfd BRIDGE SECONDS		Set bridge forward delay"
 //usage:     "\n	sethello BRIDGE SECONDS		Set hello time"
@@ -63,9 +65,7 @@
 //usage:     "\n	setpathcost BRIDGE IFACE COST	Set path cost"
 //usage:	)
 // Not yet implemented:
-//			hairpin BRIDGE IFACE on|off	Hairpin on/off
-//			showmacs BRIDGE			List mac addrs
-//			showstp	BRIDGE			Show stp info
+//			hairpin BRIDGE IFACE on|off	Set hairpin on/off
 
 #include "libbb.h"
 #include "common_bufsiz.h"
@@ -107,7 +107,7 @@ static unsigned str_to_jiffies(const cha
 
 #define filedata bb_common_bufsiz1
 
-#if ENABLE_FEATURE_BRCTL_SHOW
+#if ENABLE_FEATURE_BRCTL_SHOW || ENABLE_FEATURE_BRCTL_FANCY
 static int read_file(const char *name)
 {
 	int n = open_read_close(name, filedata, COMMON_BUFSIZE - 1);
@@ -120,7 +120,9 @@ static int read_file(const char *name)
 	}
 	return n;
 }
+#endif
 
+#if ENABLE_FEATURE_BRCTL_SHOW
 /* NB: we are in /sys/class/net
  */
 static int show_bridge(const char *name, int need_hdr)
@@ -129,7 +131,7 @@ static int show_bridge(const char *name,
  *bridge name	bridge id		STP enabled	interfaces
  *br0		8000.000000000000	no		eth0
  */
-	char pathbuf[IFNAMSIZ + sizeof("/bridge/bridge_id") + 32];
+	char pathbuf[IFNAMSIZ + sizeof("/bridge/bridge_id") + 8];
 	int tabs;
 	DIR *ifaces;
 	struct dirent *ent;
@@ -146,8 +148,7 @@ static int show_bridge(const char *name,
 
 	if (need_hdr)
 		puts("bridge name\tbridge id\t\tSTP enabled\tinterfaces");
-	printf("%s\t\t", name);
-	printf("%s\t", filedata);
+	printf("%s\t\t%s\t", name, filedata);
 
 	strcpy(sfx, "stp_state");
 	read_file(pathbuf);
@@ -158,7 +159,8 @@ static int show_bridge(const char *name,
 		strcpy(filedata, "yes");
 	fputs(filedata, stdout);
 
-	strcpy(sfx - (sizeof("bridge/")-1), "brif");
+	/* sfx points past "BR/bridge/", turn it into "BR/brif": */
+	sfx[-4] = 'f'; sfx[-3] = '\0';
 	tabs = 0;
 	ifaces = opendir(pathbuf);
 	if (ifaces) {
@@ -194,7 +196,299 @@ static void write_uint(const char *name,
 	n = sprintf(filedata, "%u\n", val);
 	if (write(fd, filedata, n) < 0)
 		bb_simple_perror_msg_and_die(name);
-	close(fd);
+	/* So far all callers exit very soon after calling us.
+	 * Do not bother closing fd (unless debugging):
+	 */
+	if (ENABLE_FEATURE_CLEAN_UP)
+		close(fd);
+}
+
+struct fdb_entry {
+	uint8_t mac_addr[6];
+	uint8_t port_no;
+	uint8_t is_local;
+	uint32_t ageing_timer_value;
+	uint8_t port_hi;
+	uint8_t pad0;
+	uint16_t unused;
+};
+
+static int compare_fdbs(const void *_f0, const void *_f1)
+{
+	const struct fdb_entry *f0 = _f0;
+	const struct fdb_entry *f1 = _f1;
+
+	return memcmp(f0->mac_addr, f1->mac_addr, 6);
+}
+
+static size_t read_bridge_forward_db(const char *name, struct fdb_entry **_fdb)
+{
+	char pathbuf[IFNAMSIZ + sizeof("/brforward") + 8];
+	struct fdb_entry *fdb;
+	size_t nentries;
+	int fd;
+	ssize_t cc;
+
+#if IFNAMSIZ == 16
+	sprintf(pathbuf, "%.16s/brforward", name);
+#else
+	sprintf(pathbuf, "%.*s/brforward", (int)IFNAMSIZ, name);
+#endif
+	fd = open(pathbuf, O_RDONLY);
+	if (fd < 0)
+		bb_error_msg_and_die("bridge %s does not exist", name);
+
+	fdb = NULL;
+	nentries = 0;
+	for (;;) {
+		fdb = xrealloc_vector(fdb, 4, nentries);
+		cc = full_read(fd, &fdb[nentries], sizeof(*fdb));
+		if (cc == 0) {
+			break;
+		}
+		if (cc != sizeof(*fdb)) {
+			bb_perror_msg_and_die("can't read bridge %s forward db", name);
+		}
+		++nentries;
+	}
+
+	if (ENABLE_FEATURE_CLEAN_UP)
+		close(fd);
+
+	qsort(fdb, nentries, sizeof(*fdb), compare_fdbs);
+
+	*_fdb = fdb;
+	return nentries;
+}
+
+static void show_bridge_macs(const char *name)
+{
+	struct fdb_entry *fdb;
+	size_t nentries;
+	size_t i;
+
+	nentries = read_bridge_forward_db(name, &fdb);
+
+	printf("port no\tmac addr\t\tis local?\tageing timer\n");
+	for (i = 0; i < nentries; ++i) {
+		const struct fdb_entry *f = &fdb[i];
+		unsigned tv_sec = f->ageing_timer_value / 100;
+		unsigned tv_csec = f->ageing_timer_value % 100;
+		printf("%3u\t"
+			"%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\t"
+			"%s\t\t"
+			"%4u.%.2u\n",
+			f->port_no,
+			f->mac_addr[0], f->mac_addr[1], f->mac_addr[2],
+			f->mac_addr[3], f->mac_addr[4], f->mac_addr[5],
+			(f->is_local ? "yes" : "no"),
+			tv_sec, tv_csec
+		);
+	}
+
+	if (ENABLE_FEATURE_CLEAN_UP)
+		free(fdb);
+}
+
+static void show_bridge_timer(const char *msg)
+{
+	unsigned long long centisec = xstrtoull(filedata, 0);
+	unsigned tv_sec = centisec / 100;
+	unsigned tv_csec = centisec % 100;
+	printf("%s%4u.%.2u", msg, tv_sec, tv_csec);
+}
+
+static const char *show_bridge_state(unsigned state)
+{
+	/* See linux/if_bridge.h, BR_STATE_ constants */
+	static const char state_names[] ALIGN1 =
+		"disabled\0"	//BR_STATE_DISABLED   0
+		"listening\0"   //BR_STATE_LISTENING  1
+		"learning\0"    //BR_STATE_LEARNING   2
+		"forwarding\0"  //BR_STATE_FORWARDING 3
+		"blocking"      //BR_STATE_BLOCKING   4
+	;
+	if (state < 5)
+		return nth_string(state_names, state);
+	return utoa(state);
+}
+
+static void printf_xstrtou(const char *fmt)
+{
+	printf(fmt, xstrtou(filedata, 0));
+}
+
+static void show_bridge_port(const char *name)
+{
+	char pathbuf[IFNAMSIZ + sizeof("/brport/forward_delay_timer") + 8];
+	char *sfx;
+
+#if IFNAMSIZ == 16
+	sfx = pathbuf + sprintf(pathbuf, "%.16s/brport/", name);
+#else
+	sfx = pathbuf + sprintf(pathbuf, "%.*s/brport/", (int)IFNAMSIZ, name);
+#endif
+
+	strcpy(sfx, "port_no");
+	read_file(pathbuf);
+	printf("%s (%u)\n", name, xstrtou(filedata, 0));
+
+	strcpy(sfx + 5, "id"); // "port_id"
+	read_file(pathbuf);
+	printf_xstrtou(" port id\t\t%.4x");
+
+	strcpy(sfx, "state");
+	read_file(pathbuf);
+	printf("\t\t\tstate\t\t%15s\n", show_bridge_state(xstrtou(filedata, 0)));
+
+	strcpy(sfx, "designated_root");
+	read_file(pathbuf);
+	printf(" designated root\t%s", filedata);
+
+	strcpy(sfx, "path_cost");
+	read_file(pathbuf);
+	printf_xstrtou("\tpath cost\t\t%4u\n");
+
+	strcpy(sfx, "designated_bridge");
+	read_file(pathbuf);
+	printf(" designated bridge\t%s", filedata);
+
+	strcpy(sfx, "message_age_timer");
+	read_file(pathbuf);
+	show_bridge_timer("\tmessage age timer\t");
+
+	strcpy(sfx, "designated_port");
+	read_file(pathbuf);
+	printf_xstrtou("\n designated port\t%.4x");
+
+	strcpy(sfx, "forward_delay_timer");
+	read_file(pathbuf);
+	show_bridge_timer("\t\t\tforward delay timer\t");
+
+	strcpy(sfx, "designated_cost");
+	read_file(pathbuf);
+	printf_xstrtou("\n designated cost\t%4u");
+
+	strcpy(sfx, "hold_timer");
+	read_file(pathbuf);
+	show_bridge_timer("\t\t\thold timer\t\t");
+
+	printf("\n flags\t\t\t");
+
+	strcpy(sfx, "config_pending");
+	read_file(pathbuf);
+	if (!LONE_CHAR(filedata, '0'))
+		printf("CONFIG_PENDING ");
+
+	strcpy(sfx, "change_ack");
+	read_file(pathbuf);
+	if (!LONE_CHAR(filedata, '0'))
+		printf("TOPOLOGY_CHANGE_ACK ");
+
+	strcpy(sfx, "hairpin_mode");
+	read_file(pathbuf);
+	if (!LONE_CHAR(filedata, '0'))
+		printf_xstrtou("\n hairpin mode\t\t%4u");
+
+	printf("\n\n");
+}
+
+static void show_bridge_stp(const char *name)
+{
+	char pathbuf[IFNAMSIZ + sizeof("/bridge/topology_change_timer") + 8];
+	char *sfx;
+
+#if IFNAMSIZ == 16
+	sfx = pathbuf + sprintf(pathbuf, "%.16s/bridge/", name);
+#else
+	sfx = pathbuf + sprintf(pathbuf, "%.*s/bridge/", (int)IFNAMSIZ, name);
+#endif
+
+	strcpy(sfx, "bridge_id");
+	if (read_file(pathbuf) < 0)
+		bb_error_msg_and_die("bridge %s does not exist", name);
+
+	printf("%s\n"
+		" bridge id\t\t%s", name, filedata);
+
+	strcpy(sfx, "root_id");
+	read_file(pathbuf);
+	printf("\n designated root\t%s", filedata);
+
+	strcpy(sfx + 5, "port"); // "root_port"
+	read_file(pathbuf);
+	printf_xstrtou("\n root port\t\t%4u\t\t\t");
+
+	strcpy(sfx + 6, "ath_cost"); // "root_path_cost"
+	read_file(pathbuf);
+	printf_xstrtou("path cost\t\t%4u\n");
+
+	strcpy(sfx, "max_age");
+	read_file(pathbuf);
+	show_bridge_timer(" max age\t\t");
+	show_bridge_timer("\t\t\tbridge max age\t\t");
+
+	strcpy(sfx, "hello_time");
+	read_file(pathbuf);
+	show_bridge_timer("\n hello time\t\t");
+	show_bridge_timer("\t\t\tbridge hello time\t");
+
+	strcpy(sfx, "forward_delay");
+	read_file(pathbuf);
+	show_bridge_timer("\n forward delay\t\t");
+	show_bridge_timer("\t\t\tbridge forward delay\t");
+
+	strcpy(sfx, "ageing_time");
+	read_file(pathbuf);
+	show_bridge_timer("\n ageing time\t\t");
+
+	strcpy(sfx, "hello_timer");
+	read_file(pathbuf);
+	show_bridge_timer("\n hello timer\t\t");
+
+	strcpy(sfx, "tcn_timer");
+	read_file(pathbuf);
+	show_bridge_timer("\t\t\ttcn timer\t\t");
+
+	strcpy(sfx, "topology_change_timer");
+	read_file(pathbuf);
+	show_bridge_timer("\n topology change timer\t");
+
+	strcpy(sfx, "gc_timer");
+	read_file(pathbuf);
+	show_bridge_timer("\t\t\tgc timer\t\t");
+
+	printf("\n flags\t\t\t");
+
+	strcpy(sfx, "topology_change");
+	read_file(pathbuf);
+	if (!LONE_CHAR(filedata, '0'))
+		printf("TOPOLOGY_CHANGE ");
+
+	strcpy(sfx, "topology_change_detected");
+	read_file(pathbuf);
+	if (!LONE_CHAR(filedata, '0'))
+		printf("TOPOLOGY_CHANGE_DETECTED ");
+	printf("\n\n\n");
+
+	/* Show bridge ports */
+	{
+		DIR *ifaces;
+
+		/* sfx points past "BR/bridge/", turn it into "BR/brif": */
+		sfx[-4] = 'f'; sfx[-3] = '\0';
+		ifaces = opendir(pathbuf);
+		if (ifaces) {
+			struct dirent *ent;
+			while ((ent = readdir(ifaces)) != NULL) {
+				if (DOT_OR_DOTDOT(ent->d_name))
+					continue; /* . or .. */
+				show_bridge_port(ent->d_name);
+			}
+			if (ENABLE_FEATURE_CLEAN_UP)
+				closedir(ifaces);
+		}
+	}
 }
 #endif
 
@@ -205,20 +499,26 @@ int brctl_main(int argc UNUSED_PARAM, ch
 		"addbr\0" "delbr\0" "addif\0" "delif\0"
 	IF_FEATURE_BRCTL_FANCY(
 		"stp\0"
+		"showstp\0"
 		"setageing\0" "setfd\0" "sethello\0" "setmaxage\0"
 		"setpathcost\0" "setportprio\0"
 		"setbridgeprio\0"
+		"showmacs\0"
 	)
 	IF_FEATURE_BRCTL_SHOW("show\0");
 	enum { ARG_addbr = 0, ARG_delbr, ARG_addif, ARG_delif
 		IF_FEATURE_BRCTL_FANCY(,
 			ARG_stp,
+			ARG_showstp,
 			ARG_setageing, ARG_setfd, ARG_sethello, ARG_setmaxage,
 			ARG_setpathcost, ARG_setportprio,
-			ARG_setbridgeprio
+			ARG_setbridgeprio,
+			ARG_showmacs
 		)
 		IF_FEATURE_BRCTL_SHOW(, ARG_show)
 	};
+	int key;
+	char *br;
 
 	argv++;
 	if (!*argv) {
@@ -228,185 +528,159 @@ int brctl_main(int argc UNUSED_PARAM, ch
 
 	xchdir("/sys/class/net");
 
-//	while (*argv)
-	{
-		smallint key;
-		char *br;
-
-		key = index_in_strings(keywords, *argv);
-		if (key == -1) /* no match found in keywords array, bail out. */
-			bb_error_msg_and_die(bb_msg_invalid_arg_to, *argv, applet_name);
-		argv++;
+	key = index_in_strings(keywords, *argv);
+	if (key == -1) /* no match found in keywords array, bail out. */
+		bb_error_msg_and_die(bb_msg_invalid_arg_to, *argv, applet_name);
+	argv++;
 
 #if ENABLE_FEATURE_BRCTL_SHOW
-		if (key == ARG_show) { /* show [BR]... */
-			DIR *net;
-			struct dirent *ent;
-			int need_hdr = 1;
-			int exitcode = EXIT_SUCCESS;
-
-			if (*argv) {
-				/* "show BR1 BR2 BR3" */
-				do {
-					if (show_bridge(*argv, need_hdr) >= 0) {
-						need_hdr = 0;
-					} else {
-						bb_error_msg("bridge %s does not exist", *argv);
+	if (key == ARG_show) { /* show [BR]... */
+		DIR *net;
+		struct dirent *ent;
+		int need_hdr = 1;
+		int exitcode = EXIT_SUCCESS;
+
+		if (*argv) {
+			/* "show BR1 BR2 BR3" */
+			do {
+				if (show_bridge(*argv, need_hdr) >= 0) {
+					need_hdr = 0;
+				} else {
+					bb_error_msg("bridge %s does not exist", *argv);
 //TODO: if device exists, but is not a BR, brctl from bridge-utils 1.6
 //says this instead: "device eth0 is not a bridge"
-						exitcode = EXIT_FAILURE;
-					}
-				} while (*++argv != NULL);
-				return exitcode;
-			}
-
-			/* "show" (if no ifaces, shows nothing, not even header) */
-			net = xopendir(".");
-			while ((ent = readdir(net)) != NULL) {
-				if (DOT_OR_DOTDOT(ent->d_name))
-					continue; /* . or .. */
-				if (show_bridge(ent->d_name, need_hdr) >= 0)
-					need_hdr = 0;
-			}
-			if (ENABLE_FEATURE_CLEAN_UP)
-				closedir(net);
+					exitcode = EXIT_FAILURE;
+				}
+			} while (*++argv != NULL);
 			return exitcode;
 		}
-#endif
 
-		if (!*argv) /* all but 'show' need at least one argument */
-			bb_show_usage();
+		/* "show" (if no ifaces, shows nothing, not even header) */
+		net = xopendir(".");
+		while ((ent = readdir(net)) != NULL) {
+			if (DOT_OR_DOTDOT(ent->d_name))
+				continue; /* . or .. */
+			if (show_bridge(ent->d_name, need_hdr) >= 0)
+				need_hdr = 0;
+		}
+		if (ENABLE_FEATURE_CLEAN_UP)
+			closedir(net);
+		return exitcode;
+	}
+#endif
 
-		br = *argv++;
+	if (!*argv) /* All of the below need at least one argument */
+		bb_show_usage();
 
-		if (key == ARG_addbr || key == ARG_delbr) {
-			/* addbr or delbr */
-			/* brctl from bridge-utils 1.6 still uses ioctl
-			 * for SIOCBRADDBR / SIOCBRDELBR, not /sys accesses
-			 */
-			int fd = xsocket(AF_INET, SOCK_STREAM, 0);
-			ioctl_or_perror_and_die(fd,
-				key == ARG_addbr ? SIOCBRADDBR : SIOCBRDELBR,
-				br, "bridge %s", br
-			);
-			//close(fd);
-			//goto done;
-			/* bridge-utils 1.6 simply ignores trailing args:
-			 * "brctl addbr BR1 ARGS" ignores ARGS
-			 */
-			if (ENABLE_FEATURE_CLEAN_UP)
-				close(fd);
-			return EXIT_SUCCESS;
-		}
+	br = *argv++;
 
-		if (!*argv) /* all but 'addbr/delbr' need at least two arguments */
-			bb_show_usage();
+	if (key == ARG_addbr || key == ARG_delbr) {
+		/* brctl from bridge-utils 1.6 still uses ioctl
+		 * for SIOCBRADDBR / SIOCBRDELBR, not /sys accesses
+		 */
+		int fd = xsocket(AF_INET, SOCK_STREAM, 0);
+		ioctl_or_perror_and_die(fd,
+			key == ARG_addbr ? SIOCBRADDBR : SIOCBRDELBR,
+			br, "bridge %s", br
+		);
+		//close(fd);
+		//goto done;
+		/* bridge-utils 1.6 simply ignores trailing args:
+		 * "brctl addbr BR1 ARGS" ignores ARGS
+		 */
+		if (ENABLE_FEATURE_CLEAN_UP)
+			close(fd);
+		return EXIT_SUCCESS;
+	}
 
 #if ENABLE_FEATURE_BRCTL_FANCY
-		if (key == ARG_stp) { /* stp */
-			static const char no_yes[] ALIGN1 =
-				"0\0" "off\0" "n\0" "no\0"   /* 0 .. 3 */
-				"1\0" "on\0"  "y\0" "yes\0"; /* 4 .. 7 */
-			int onoff = index_in_strings(no_yes, *argv);
-			if (onoff < 0)
-				bb_error_msg_and_die(bb_msg_invalid_arg_to, *argv, applet_name);
-			onoff = (unsigned)onoff / 4;
-			write_uint(br, "bridge/stp_state", onoff);
-			//goto done_next_argv;
-			return EXIT_SUCCESS;
-		}
+	if (key == ARG_showmacs) {
+		show_bridge_macs(br);
+		return EXIT_SUCCESS;
+	}
+	if (key == ARG_showstp) {
+		show_bridge_stp(br);
+		return EXIT_SUCCESS;
+	}
+#endif
 
-		if ((unsigned)(key - ARG_setageing) < 4) { /* time related ops */
-			/* setageing BR N: "N*100\n" to /sys/class/net/BR/bridge/ageing_time
-			 * setfd BR N:     "N*100\n" to /sys/class/net/BR/bridge/forward_delay
-			 * sethello BR N:  "N*100\n" to /sys/class/net/BR/bridge/hello_time
-			 * setmaxage BR N: "N*100\n" to /sys/class/net/BR/bridge/max_age
-			 */
-			write_uint(br,
-				nth_string(
-					"bridge/ageing_time"  "\0" /* ARG_setageing */
-					"bridge/forward_delay""\0" /* ARG_setfd     */
-					"bridge/hello_time"   "\0" /* ARG_sethello  */
-					"bridge/max_age",          /* ARG_setmaxage */
-					key - ARG_setageing
-				),
-				str_to_jiffies(*argv)
-			);
-			//goto done_next_argv;
-			return EXIT_SUCCESS;
-		}
+	if (!*argv) /* All of the below need at least two arguments */
+		bb_show_usage();
 
-		if (key == ARG_setbridgeprio) {
-			write_uint(br, "bridge/priority", xatoi_positive(*argv));
-			//goto done_next_argv;
-			return EXIT_SUCCESS;
-		}
+#if ENABLE_FEATURE_BRCTL_FANCY
+	if (key == ARG_stp) {
+		static const char no_yes[] ALIGN1 =
+			"0\0" "off\0" "n\0" "no\0"   /* 0 .. 3 */
+			"1\0" "on\0"  "y\0" "yes\0"; /* 4 .. 7 */
+		int onoff = index_in_strings(no_yes, *argv);
+		if (onoff < 0)
+			bb_error_msg_and_die(bb_msg_invalid_arg_to, *argv, applet_name);
+		onoff = (unsigned)onoff / 4;
+		write_uint(br, "bridge/stp_state", onoff);
+		return EXIT_SUCCESS;
+	}
 
-		if (key == ARG_setpathcost
-		 || key == ARG_setportprio
-		) {
-			if (!argv[1])
-				bb_show_usage();
-			/* BR is not used (and ignored!) for these commands:
-			 * "setpathcost BR PORT N" writes "N\n" to
-			 * /sys/class/net/PORT/brport/path_cost
-			 * "setportprio BR PORT N" writes "N\n" to
-			 * /sys/class/net/PORT/brport/priority
-			 */
-			write_uint(argv[0],
-				nth_string(
-					"brport/path_cost" "\0" /* ARG_setpathcost */
-					"brport/priority",      /* ARG_setportprio */
-					key - ARG_setpathcost
-				),
-				xatoi_positive(argv[1])
-			);
-			//argv++;
-			//goto done_next_argv;
-			return EXIT_SUCCESS;
-		}
+	if ((unsigned)(key - ARG_setageing) < 4) { /* time related ops */
+		/* setageing BR N: "N*100\n" to /sys/class/net/BR/bridge/ageing_time
+		 * setfd BR N:     "N*100\n" to /sys/class/net/BR/bridge/forward_delay
+		 * sethello BR N:  "N*100\n" to /sys/class/net/BR/bridge/hello_time
+		 * setmaxage BR N: "N*100\n" to /sys/class/net/BR/bridge/max_age
+		 */
+		write_uint(br,
+			nth_string(
+				"bridge/ageing_time"  "\0" /* ARG_setageing */
+				"bridge/forward_delay""\0" /* ARG_setfd     */
+				"bridge/hello_time"   "\0" /* ARG_sethello  */
+				"bridge/max_age",          /* ARG_setmaxage */
+				key - ARG_setageing
+			),
+			str_to_jiffies(*argv)
+		);
+		return EXIT_SUCCESS;
+	}
 
-/* TODO: "showmacs BR"
- *	port no\tmac addr\t\tis local?\tageing timer
- *	<sp><sp>1\txx:xx:xx:xx:xx:xx\tno\t\t<sp><sp><sp>1.31
- *	port no	mac addr		is local?	ageing timer
- *	  1	xx:xx:xx:xx:xx:xx	no		   1.31
- * Read fixed-sized records from /sys/class/net/BR/brforward:
- *	struct __fdb_entry {
- *		uint8_t  mac_addr[ETH_ALEN];
- *		uint8_t  port_no; //lsb
- *		uint8_t  is_local;
- *		uint32_t ageing_timer_value;
- *		uint8_t  port_hi;
- *		uint8_t  pad0;
- *		uint16_t unused;
- *	};
- */
+	if (key == ARG_setbridgeprio) {
+		write_uint(br, "bridge/priority", xatoi_positive(*argv));
+		return EXIT_SUCCESS;
+	}
+
+	if (key == ARG_setpathcost
+	 || key == ARG_setportprio
+	) {
+		if (!argv[1])
+			bb_show_usage();
+		/* BR is not used (and ignored!) for these commands:
+		 * "setpathcost BR PORT N" writes "N\n" to
+		 * /sys/class/net/PORT/brport/path_cost
+		 * "setportprio BR PORT N" writes "N\n" to
+		 * /sys/class/net/PORT/brport/priority
+		 */
+		write_uint(argv[0],
+			nth_string(
+				"brport/path_cost" "\0" /* ARG_setpathcost */
+				"brport/priority",      /* ARG_setportprio */
+				key - ARG_setpathcost
+			),
+			xatoi_positive(argv[1])
+		);
+		return EXIT_SUCCESS;
+	}
 #endif
-		/* always true: if (key == ARG_addif || key == ARG_delif) */ {
-			/* addif or delif */
-			struct ifreq ifr;
-			int fd = xsocket(AF_INET, SOCK_STREAM, 0);
-
-			strncpy_IFNAMSIZ(ifr.ifr_name, br);
-			ifr.ifr_ifindex = if_nametoindex(*argv);
-			if (ifr.ifr_ifindex == 0) {
-				bb_perror_msg_and_die("iface %s", *argv);
-			}
-			ioctl_or_perror_and_die(fd,
-				key == ARG_addif ? SIOCBRADDIF : SIOCBRDELIF,
-				&ifr, "bridge %s", br
-			);
-			//close(fd);
-			//goto done_next_argv;
-			if (ENABLE_FEATURE_CLEAN_UP)
-				close(fd);
-			return EXIT_SUCCESS;
+	/* always true: if (key == ARG_addif || key == ARG_delif) */ {
+		struct ifreq ifr;
+		int fd = xsocket(AF_INET, SOCK_STREAM, 0);
+
+		strncpy_IFNAMSIZ(ifr.ifr_name, br);
+		ifr.ifr_ifindex = if_nametoindex(*argv);
+		if (ifr.ifr_ifindex == 0) {
+			bb_perror_msg_and_die("iface %s", *argv);
 		}
-
-// done_next_argv:
-//		argv++;
-// done:
+		ioctl_or_perror_and_die(fd,
+			key == ARG_addif ? SIOCBRADDIF : SIOCBRDELIF,
+			&ifr, "bridge %s", br
+		);
+		if (ENABLE_FEATURE_CLEAN_UP)
+			close(fd);
 	}
 
 	return EXIT_SUCCESS;
diff -urpN busybox-1.31.1/networking/dnsd.c busybox-1.32.0/networking/dnsd.c
--- busybox-1.31.1/networking/dnsd.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/dnsd.c	2020-06-26 22:47:44.000000000 +0400
@@ -395,11 +395,11 @@ static int process_packet(struct dns_ent
 
 	head = (struct dns_head *)buf;
 	if (head->nquer == 0) {
-		bb_error_msg("packet has 0 queries, ignored");
+		bb_simple_error_msg("packet has 0 queries, ignored");
 		return 0; /* don't reply */
 	}
 	if (head->flags & htons(0x8000)) { /* QR bit */
-		bb_error_msg("response packet, ignored");
+		bb_simple_error_msg("response packet, ignored");
 		return 0; /* don't reply */
 	}
 	/* QR = 1 "response", RCODE = 4 "Not Implemented" */
@@ -474,7 +474,7 @@ static int process_packet(struct dns_ent
 	 * RCODE = 0 "success"
 	 */
 	if (OPT_verbose)
-		bb_info_msg("returning positive reply");
+		bb_simple_info_msg("returning positive reply");
 	outr_flags = htons(0x8000 | 0x0400 | 0);
 	/* we have one answer */
 	head->nansw = htons(1);
@@ -557,7 +557,7 @@ int dnsd_main(int argc UNUSED_PARAM, cha
 			continue;
 		}
 		if (OPT_verbose)
-			bb_info_msg("got UDP packet");
+			bb_simple_info_msg("got UDP packet");
 		buf[r] = '\0'; /* paranoia */
 		r = process_packet(conf_data, conf_ttl, buf);
 		if (r <= 0)
diff -urpN busybox-1.31.1/networking/ether-wake.c busybox-1.32.0/networking/ether-wake.c
--- busybox-1.31.1/networking/ether-wake.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/ether-wake.c	2020-06-26 22:47:44.000000000 +0400
@@ -182,7 +182,7 @@ static int get_wol_pw(const char *ethopt
 		byte_cnt = sscanf(ethoptarg, "%u.%u.%u.%u",
 		                  &passwd[0], &passwd[1], &passwd[2], &passwd[3]);
 	if (byte_cnt < 4) {
-		bb_error_msg("can't read Wake-On-LAN pass");
+		bb_simple_error_msg("can't read Wake-On-LAN pass");
 		return 0;
 	}
 // TODO: check invalid numbers >255??
@@ -266,7 +266,7 @@ int ether_wake_main(int argc UNUSED_PARA
 	/* This is necessary for broadcasts to work */
 	if (flags /* & 1 OPT_BROADCAST */) {
 		if (setsockopt_broadcast(s) != 0)
-			bb_perror_msg("SO_BROADCAST");
+			bb_simple_perror_msg("SO_BROADCAST");
 	}
 
 #if defined(PF_PACKET)
diff -urpN busybox-1.31.1/networking/ftpgetput.c busybox-1.32.0/networking/ftpgetput.c
--- busybox-1.31.1/networking/ftpgetput.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/ftpgetput.c	2020-06-26 22:47:44.000000000 +0400
@@ -214,7 +214,7 @@ int ftp_receive(const char *local_path,
 		struct stat sbuf;
 		/* lstat would be wrong here! */
 		if (stat(local_path, &sbuf) < 0) {
-			bb_perror_msg_and_die("stat");
+			bb_simple_perror_msg_and_die("stat");
 		}
 		if (sbuf.st_size > 0) {
 			beg_range = sbuf.st_size;
diff -urpN busybox-1.31.1/networking/hostname.c busybox-1.32.0/networking/hostname.c
--- busybox-1.31.1/networking/hostname.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/hostname.c	2020-06-26 22:47:44.000000000 +0400
@@ -61,7 +61,7 @@ static void do_sethostname(char *s, int
 	} else if (sethostname(s, strlen(s))) {
 //		if (errno == EPERM)
 //			bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
-		bb_perror_msg_and_die("sethostname");
+		bb_simple_perror_msg_and_die("sethostname");
 	}
 }
 
diff -urpN busybox-1.31.1/networking/httpd.c busybox-1.32.0/networking/httpd.c
--- busybox-1.31.1/networking/httpd.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/httpd.c	2020-06-26 22:47:44.000000000 +0400
@@ -1025,7 +1025,7 @@ static void log_and_exit(void)
 	*/
 
 	if (verbose > 2)
-		bb_error_msg("closed");
+		bb_simple_error_msg("closed");
 	_exit(xfunc_error_retval);
 }
 
@@ -1220,7 +1220,7 @@ static void send_headers(unsigned respon
 	}
 	if (full_write(STDOUT_FILENO, iobuf, len) != len) {
 		if (verbose > 1)
-			bb_perror_msg("error");
+			bb_simple_perror_msg("error");
 		log_and_exit();
 	}
 }
@@ -1838,7 +1838,7 @@ static NOINLINE void send_file_and_exit(
 	if (count < 0) {
  IF_FEATURE_USE_SENDFILE(fin:)
 		if (verbose > 1)
-			bb_perror_msg("error");
+			bb_simple_perror_msg("error");
 	}
 	log_and_exit();
 }
@@ -2149,7 +2149,7 @@ static void handle_incoming_and_exit(con
 		if (rmt_ip_str)
 			applet_name = rmt_ip_str;
 		if (verbose > 2)
-			bb_error_msg("connected");
+			bb_simple_error_msg("connected");
 	}
 	if_ip_denied_send_HTTP_FORBIDDEN_and_exit(remote_ip);
 
@@ -2734,10 +2734,15 @@ int httpd_main(int argc UNUSED_PARAM, ch
 #if !BB_MMU
 	if (!(opt & OPT_FOREGROUND)) {
 		bb_daemonize_or_rexec(0, argv); /* don't change current directory */
+		re_execed = 0; /* for the following chdir to work */
 	}
 #endif
+	/* Chdir to home (unless we were re_exec()ed for NOMMU case
+	 * in mini_httpd_nommu(): we are already in the home dir then).
+	 */
+	if (!re_execed)
+		xchdir(home_httpd);
 
-	xchdir(home_httpd);
 	if (!(opt & OPT_INETD)) {
 		signal(SIGCHLD, SIG_IGN);
 		server_socket = openServer();
@@ -2746,7 +2751,7 @@ int httpd_main(int argc UNUSED_PARAM, ch
 		if (opt & OPT_SETUID) {
 			if (ugid.gid != (gid_t)-1) {
 				if (setgroups(1, &ugid.gid) == -1)
-					bb_perror_msg_and_die("setgroups");
+					bb_simple_perror_msg_and_die("setgroups");
 				xsetgid(ugid.gid);
 			}
 			xsetuid(ugid.uid);
diff -urpN busybox-1.31.1/networking/ifconfig.c busybox-1.32.0/networking/ifconfig.c
--- busybox-1.31.1/networking/ifconfig.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/ifconfig.c	2020-06-26 22:47:44.000000000 +0400
@@ -361,7 +361,7 @@ int ifconfig_main(int argc UNUSED_PARAM,
 #if ENABLE_FEATURE_IFCONFIG_STATUS
 		return display_interfaces(argv[0] ? argv[0] : show_all_param);
 #else
-		bb_error_msg_and_die("no support for status display");
+		bb_simple_error_msg_and_die("no support for status display");
 #endif
 	}
 
diff -urpN busybox-1.31.1/networking/ifplugd.c busybox-1.32.0/networking/ifplugd.c
--- busybox-1.31.1/networking/ifplugd.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/ifplugd.c	2020-06-26 22:47:44.000000000 +0400
@@ -365,7 +365,7 @@ static void up_iface(void)
 	if (!(ifrequest.ifr_flags & IFF_UP)) {
 		ifrequest.ifr_flags |= IFF_UP;
 		/* Let user know we mess up with interface */
-		bb_info_msg("upping interface");
+		bb_simple_info_msg("upping interface");
 		if (network_ioctl(SIOCSIFFLAGS, &ifrequest, "setting interface flags") < 0) {
 			if (errno != ENODEV && errno != EADDRNOTAVAIL)
 				xfunc_die();
@@ -461,7 +461,7 @@ static smallint detect_link(void)
 		else if (option_mask32 & FLAG_IGNORE_FAIL_POSITIVE)
 			status = IFSTATUS_UP;
 		else if (G.api_mode[0] == 'a')
-			bb_error_msg("can't detect link status");
+			bb_simple_error_msg("can't detect link status");
 	}
 
 	if (status != G.iface_last_status) {
@@ -493,14 +493,14 @@ static NOINLINE int check_existence_thro
 				goto ret;
 			if (errno == EINTR)
 				continue;
-			bb_perror_msg("netlink: recv");
+			bb_simple_perror_msg("netlink: recv");
 			return -1;
 		}
 
 		mhdr = (struct nlmsghdr*)replybuf;
 		while (bytes > 0) {
 			if (!NLMSG_OK(mhdr, bytes)) {
-				bb_error_msg("netlink packet too small or truncated");
+				bb_simple_error_msg("netlink packet too small or truncated");
 				return -1;
 			}
 
@@ -509,7 +509,7 @@ static NOINLINE int check_existence_thro
 				int attr_len;
 
 				if (mhdr->nlmsg_len < NLMSG_LENGTH(sizeof(struct ifinfomsg))) {
-					bb_error_msg("netlink packet too small or truncated");
+					bb_simple_error_msg("netlink packet too small or truncated");
 					return -1;
 				}
 
@@ -591,7 +591,7 @@ int ifplugd_main(int argc UNUSED_PARAM,
 	}
 
 	if (pid_from_pidfile > 0 && kill(pid_from_pidfile, 0) == 0)
-		bb_error_msg_and_die("daemon already running");
+		bb_simple_error_msg_and_die("daemon already running");
 #endif
 
 	api_mode_found = strchr(api_modes, G.api_mode[0]);
@@ -690,7 +690,7 @@ int ifplugd_main(int argc UNUSED_PARAM,
 		) {
 			if (errno == EINTR)
 				continue;
-			bb_perror_msg("poll");
+			bb_simple_perror_msg("poll");
 			goto exiting;
 		}
 
@@ -763,5 +763,5 @@ int ifplugd_main(int argc UNUSED_PARAM,
 
  exiting:
 	remove_pidfile(pidfile_name);
-	bb_error_msg_and_die("exiting");
+	bb_simple_error_msg_and_die("exiting");
 }
diff -urpN busybox-1.31.1/networking/ifupdown.c busybox-1.32.0/networking/ifupdown.c
--- busybox-1.31.1/networking/ifupdown.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/ifupdown.c	2020-06-26 22:47:44.000000000 +0400
@@ -665,7 +665,7 @@ static int FAST_FUNC dhcp_up(struct inte
 		if (executable_exists(ext_dhcp_clients[i].name))
 			return execute(ext_dhcp_clients[i].startcmd, ifd, exec);
 	}
-	bb_error_msg("no dhcp clients found");
+	bb_simple_error_msg("no dhcp clients found");
 	return 0;
 }
 # elif ENABLE_UDHCPC
@@ -707,7 +707,7 @@ static int FAST_FUNC dhcp_down(struct in
 	}
 
 	if (!result)
-		bb_error_msg("warning: no dhcp clients found and stopped");
+		bb_simple_error_msg("warning: no dhcp clients found and stopped");
 
 	/* Sleep a bit, otherwise static_down tries to bring down interface too soon,
 	   and it may come back up because udhcpc is still shutting down */
diff -urpN busybox-1.31.1/networking/inetd.c busybox-1.32.0/networking/inetd.c
--- busybox-1.31.1/networking/inetd.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/inetd.c	2020-06-26 22:47:44.000000000 +0400
@@ -504,7 +504,7 @@ static void register_rpc(servtab_t *sep)
 
 	if (bb_getsockname(sep->se_fd, (struct sockaddr *) &ir_sin, sizeof(ir_sin)) < 0) {
 //TODO: verify that such failure is even possible in Linux kernel
-		bb_perror_msg("getsockname");
+		bb_simple_perror_msg("getsockname");
 		return;
 	}
 
@@ -544,7 +544,7 @@ static void bump_nofile(void)
 	}
 
 	if (setrlimit(RLIMIT_NOFILE, &rl) < 0) {
-		bb_perror_msg("setrlimit");
+		bb_simple_perror_msg("setrlimit");
 		return;
 	}
 
@@ -599,7 +599,7 @@ static void prepare_socket_fd(servtab_t
 
 	fd = socket(sep->se_family, sep->se_socktype, 0);
 	if (fd < 0) {
-		bb_perror_msg("socket");
+		bb_simple_perror_msg("socket");
 		return;
 	}
 	setsockopt_reuseaddr(fd);
@@ -815,7 +815,7 @@ static NOINLINE servtab_t *parse_one_lin
 			n = bb_strtou(p, &p, 10);
 			if (n > INT_MAX) {
  bad_ver_spec:
-				bb_error_msg("bad rpc version");
+				bb_simple_error_msg("bad rpc version");
 				goto parse_err;
 			}
 			sep->se_rpcver_lo = sep->se_rpcver_hi = n;
@@ -829,7 +829,7 @@ static NOINLINE servtab_t *parse_one_lin
 			if (*p != '\0')
 				goto bad_ver_spec;
 #else
-			bb_error_msg("no support for rpc services");
+			bb_simple_error_msg("no support for rpc services");
 			goto parse_err;
 #endif
 		}
@@ -1235,7 +1235,7 @@ int inetd_main(int argc UNUSED_PARAM, ch
 	if (argv[0])
 		config_filename = argv[0];
 	if (config_filename == NULL)
-		bb_error_msg_and_die("non-root must specify config file");
+		bb_simple_error_msg_and_die("non-root must specify config file");
 	if (!(opt & 2))
 		bb_daemonize_or_rexec(0, argv - optind);
 	else
@@ -1304,7 +1304,7 @@ int inetd_main(int argc UNUSED_PARAM, ch
 		ready_fd_cnt = select(maxsock + 1, &readable, NULL, NULL, NULL);
 		if (ready_fd_cnt < 0) {
 			if (errno != EINTR) {
-				bb_perror_msg("select");
+				bb_simple_perror_msg("select");
 				sleep(1);
 			}
 			continue;
@@ -1405,7 +1405,7 @@ int inetd_main(int argc UNUSED_PARAM, ch
 					pid = vfork();
 
 				if (pid < 0) { /* fork error */
-					bb_perror_msg("vfork"+1);
+					bb_simple_perror_msg("vfork"+1);
 					sleep(1);
 					restore_sigmask(&omask);
 					maybe_close(new_udp_fd);
@@ -1488,7 +1488,7 @@ int inetd_main(int argc UNUSED_PARAM, ch
 			}
 			if (real_uid != 0 && real_uid != pwd->pw_uid) {
 				/* a user running private inetd */
-				bb_error_msg("non-root must run services as himself");
+				bb_simple_error_msg("non-root must run services as himself");
 				goto do_exit1;
 			}
 			if (pwd->pw_uid != real_uid) {
@@ -1502,7 +1502,7 @@ int inetd_main(int argc UNUSED_PARAM, ch
 			}
 			if (rlim_ofile.rlim_cur != rlim_ofile_cur)
 				if (setrlimit(RLIMIT_NOFILE, &rlim_ofile) < 0)
-					bb_perror_msg("setrlimit");
+					bb_simple_perror_msg("setrlimit");
 
 			/* closelog(); - WRONG. we are after vfork,
 			 * this may confuse syslog() internal state.
diff -urpN busybox-1.31.1/networking/ipcalc.c busybox-1.32.0/networking/ipcalc.c
--- busybox-1.31.1/networking/ipcalc.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/ipcalc.c	2020-06-26 22:47:44.000000000 +0400
@@ -183,7 +183,7 @@ int ipcalc_main(int argc UNUSED_PARAM, c
 
 	if (argv[1]) {
 		if (ENABLE_FEATURE_IPCALC_FANCY && have_netmask) {
-			bb_error_msg_and_die("use prefix or netmask, not both");
+			bb_simple_error_msg_and_die("use prefix or netmask, not both");
 		}
 		if (inet_aton(argv[1], &s_netmask) == 0) {
 			bb_error_msg_and_die("bad netmask: %s", argv[1]);
diff -urpN busybox-1.31.1/networking/isrv.c busybox-1.32.0/networking/isrv.c
--- busybox-1.31.1/networking/isrv.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/isrv.c	2020-06-26 22:47:44.000000000 +0400
@@ -185,7 +185,7 @@ static void handle_accept(isrv_state_t *
 		/* Most probably someone gave us wrong fd type
 		 * (for example, non-socket). Don't want
 		 * to loop forever. */
-		bb_perror_msg_and_die("accept");
+		bb_simple_perror_msg_and_die("accept");
 	}
 
 	DPRINTF("new_peer(%d)", newfd);
@@ -311,7 +311,7 @@ void isrv_run(
 
 		if (n < 0) {
 			if (errno != EINTR)
-				bb_perror_msg("select");
+				bb_simple_perror_msg("select");
 			continue;
 		}
 
diff -urpN busybox-1.31.1/networking/libiproute/ipaddress.c busybox-1.32.0/networking/libiproute/ipaddress.c
--- busybox-1.31.1/networking/libiproute/ipaddress.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/libiproute/ipaddress.c	2020-06-26 22:47:44.000000000 +0400
@@ -119,7 +119,7 @@ static NOINLINE int print_linkinfo(const
 	//memset(tb, 0, sizeof(tb)); - parse_rtattr does this
 	parse_rtattr(tb, IFLA_MAX, IFLA_RTA(ifi), len);
 	if (tb[IFLA_IFNAME] == NULL) {
-		bb_error_msg("nil ifname");
+		bb_simple_error_msg("nil ifname");
 		return -1;
 	}
 	if (G_filter.label
@@ -205,7 +205,7 @@ static NOINLINE int print_linkinfo(const
 static int flush_update(void)
 {
 	if (rtnl_send_check(G_filter.rth, G_filter.flushb, G_filter.flushp) < 0) {
-		bb_perror_msg("can't send flush request");
+		bb_simple_perror_msg("can't send flush request");
 		return -1;
 	}
 	G_filter.flushp = 0;
@@ -439,7 +439,7 @@ int FAST_FUNC ipaddr_list_or_flush(char
 			bb_error_msg_and_die(bb_msg_requires_arg, "flush");
 		}
 		if (G_filter.family == AF_PACKET) {
-			bb_error_msg_and_die("can't flush link addresses");
+			bb_simple_error_msg_and_die("can't flush link addresses");
 		}
 	}
 
@@ -700,7 +700,7 @@ static int ipaddr_modify(int cmd, int fl
 
 	if (!d) {
 		/* There was no "dev IFACE", but we need that */
-		bb_error_msg_and_die("need \"dev IFACE\"");
+		bb_simple_error_msg_and_die("need \"dev IFACE\"");
 	}
 	if (l && !is_prefixed_with(l, d)) {
 		bb_error_msg_and_die("\"dev\" (%s) must match \"label\" (%s)", d, l);
@@ -717,7 +717,7 @@ static int ipaddr_modify(int cmd, int fl
 		inet_prefix brd;
 		int i;
 		if (req.ifa.ifa_family != AF_INET) {
-			bb_error_msg_and_die("broadcast can be set only for IPv4 addresses");
+			bb_simple_error_msg_and_die("broadcast can be set only for IPv4 addresses");
 		}
 		brd = peer;
 		if (brd.bitlen <= 30) {
diff -urpN busybox-1.31.1/networking/libiproute/ipneigh.c busybox-1.32.0/networking/libiproute/ipneigh.c
--- busybox-1.31.1/networking/libiproute/ipneigh.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/libiproute/ipneigh.c	2020-06-26 22:47:44.000000000 +0400
@@ -49,7 +49,7 @@ typedef struct filter_t filter_t;
 static int flush_update(void)
 {
 	if (rtnl_send_check(G_filter.rth, G_filter.flushb, G_filter.flushp) < 0) {
-		bb_perror_msg("can't send flush request");
+		bb_simple_perror_msg("can't send flush request");
 		return -1;
 	}
 	G_filter.flushp = 0;
@@ -305,7 +305,7 @@ static int FAST_FUNC ipneigh_list_or_flu
 			xrtnl_wilddump_request(&rth, G_filter.family, RTM_GETNEIGH);
 			G_filter.flushed = 0;
 			if (xrtnl_dump_filter(&rth, print_neigh, NULL) < 0) {
-				bb_perror_msg_and_die("flush terminated");
+				bb_simple_perror_msg_and_die("flush terminated");
 			}
 			if (G_filter.flushed == 0) {
 				if (round == 0)
@@ -325,11 +325,11 @@ static int FAST_FUNC ipneigh_list_or_flu
 	ndm.ndm_family = G_filter.family;
 
 	if (rtnl_dump_request(&rth, RTM_GETNEIGH, &ndm, sizeof(struct ndmsg)) < 0) {
-		bb_perror_msg_and_die("can't send dump request");
+		bb_simple_perror_msg_and_die("can't send dump request");
 	}
 
 	if (xrtnl_dump_filter(&rth, print_neigh, NULL) < 0) {
-		bb_error_msg_and_die("dump terminated");
+		bb_simple_error_msg_and_die("dump terminated");
 	}
 
 	return 0;
diff -urpN busybox-1.31.1/networking/libiproute/iproute.c busybox-1.32.0/networking/libiproute/iproute.c
--- busybox-1.31.1/networking/libiproute/iproute.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/libiproute/iproute.c	2020-06-26 22:47:44.000000000 +0400
@@ -57,7 +57,7 @@ typedef struct filter_t filter_t;
 static int flush_update(void)
 {
 	if (rtnl_send_check(G_filter.rth, G_filter.flushb, G_filter.flushp) < 0) {
-		bb_perror_msg("can't send flush request");
+		bb_simple_perror_msg("can't send flush request");
 		return -1;
 	}
 	G_filter.flushp = 0;
@@ -756,7 +756,7 @@ static void iproute_flush_cache(void)
 	}
 
 	if (write(flush_fd, "-1", 2) < 2) {
-		bb_perror_msg("can't flush routing cache");
+		bb_simple_perror_msg("can't flush routing cache");
 		return;
 	}
 	close(flush_fd);
@@ -948,7 +948,7 @@ static int iproute_list_or_flush(char **
 	if (G_filter.tb != -1) {
 		xrtnl_wilddump_request(&rth, do_ipv6, RTM_GETROUTE);
 	} else if (rtnl_rtcache_request(&rth, do_ipv6) < 0) {
-		bb_perror_msg_and_die("can't send dump request");
+		bb_simple_perror_msg_and_die("can't send dump request");
 	}
 	xrtnl_dump_filter(&rth, print_route, NULL);
 
@@ -1041,7 +1041,7 @@ static int iproute_get(char **argv)
 	}
 
 	if (req.r.rtm_dst_len == 0) {
-		bb_error_msg_and_die("need at least destination address");
+		bb_simple_error_msg_and_die("need at least destination address");
 	}
 
 	xrtnl_open(&rth);
@@ -1077,7 +1077,7 @@ static int iproute_get(char **argv)
 		print_route(NULL, &req.n, NULL);
 
 		if (req.n.nlmsg_type != RTM_NEWROUTE) {
-			bb_error_msg_and_die("not a route?");
+			bb_simple_error_msg_and_die("not a route?");
 		}
 		len -= NLMSG_LENGTH(sizeof(*r));
 		if (len < 0) {
@@ -1091,7 +1091,7 @@ static int iproute_get(char **argv)
 			tb[RTA_PREFSRC]->rta_type = RTA_SRC;
 			r->rtm_src_len = 8*RTA_PAYLOAD(tb[RTA_PREFSRC]);
 		} else if (!tb[RTA_SRC]) {
-			bb_error_msg_and_die("can't connect the route");
+			bb_simple_error_msg_and_die("can't connect the route");
 		}
 		if (!odev && tb[RTA_OIF]) {
 			tb[RTA_OIF]->rta_type = 0;
diff -urpN busybox-1.31.1/networking/libiproute/iptunnel.c busybox-1.32.0/networking/libiproute/iptunnel.c
--- busybox-1.31.1/networking/libiproute/iptunnel.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/libiproute/iptunnel.c	2020-06-26 22:47:44.000000000 +0400
@@ -338,7 +338,7 @@ static void parse_args(char **argv, int
 
 	if (p->iph.protocol == IPPROTO_IPIP || p->iph.protocol == IPPROTO_IPV6) {
 		if ((p->i_flags & GRE_KEY) || (p->o_flags & GRE_KEY)) {
-			bb_error_msg_and_die("keys are not allowed with ipip and sit");
+			bb_simple_error_msg_and_die("keys are not allowed with ipip and sit");
 		}
 	}
 
@@ -355,7 +355,7 @@ static void parse_args(char **argv, int
 		p->o_flags |= GRE_KEY;
 	}
 	if (IN_MULTICAST(ntohl(p->iph.daddr)) && !p->iph.saddr) {
-		bb_error_msg_and_die("broadcast tunnel requires a source address");
+		bb_simple_error_msg_and_die("broadcast tunnel requires a source address");
 	}
 }
 
@@ -367,7 +367,7 @@ static int do_add(int cmd, char **argv)
 	parse_args(argv, cmd, &p);
 
 	if (p.iph.ttl && p.iph.frag_off == 0) {
-		bb_error_msg_and_die("ttl != 0 and noptmudisc are incompatible");
+		bb_simple_error_msg_and_die("ttl != 0 and noptmudisc are incompatible");
 	}
 
 	switch (p.iph.protocol) {
@@ -378,7 +378,7 @@ static int do_add(int cmd, char **argv)
 	case IPPROTO_IPV6:
 		return do_add_ioctl(cmd, "sit0", &p);
 	default:
-		bb_error_msg_and_die("can't determine tunnel mode (ipip, gre or sit)");
+		bb_simple_error_msg_and_die("can't determine tunnel mode (ipip, gre or sit)");
 	}
 }
 
@@ -485,7 +485,7 @@ static void do_tunnels_list(struct ip_tu
 		if (ptr == NULL ||
 		    (*ptr++ = 0, sscanf(buf, "%s", name) != 1)
 		) {
-			bb_error_msg("wrong format of /proc/net/dev");
+			bb_simple_error_msg("wrong format of /proc/net/dev");
 			return;
 		}
 		if (sscanf(ptr, "%lu%lu%lu%lu%lu%lu%lu%*d%lu%lu%lu%lu%lu%lu%lu",
diff -urpN busybox-1.31.1/networking/libiproute/libnetlink.c busybox-1.32.0/networking/libiproute/libnetlink.c
--- busybox-1.31.1/networking/libiproute/libnetlink.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/libiproute/libnetlink.c	2020-06-26 22:47:44.000000000 +0400
@@ -79,7 +79,7 @@ int FAST_FUNC rtnl_send_check(struct rtn
 		if (h->nlmsg_type == NLMSG_ERROR) {
 			struct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);
 			if (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr)))
-				bb_error_msg("ERROR truncated");
+				bb_simple_error_msg("ERROR truncated");
 			else
 				errno = -err->error;
 			return -1;
@@ -149,11 +149,11 @@ static int rtnl_dump_filter(struct rtnl_
 		if (status < 0) {
 			if (errno == EINTR)
 				continue;
-			bb_perror_msg("OVERRUN");
+			bb_simple_perror_msg("OVERRUN");
 			continue;
 		}
 		if (status == 0) {
-			bb_error_msg("EOF on netlink");
+			bb_simple_error_msg("EOF on netlink");
 			goto ret;
 		}
 		if (msg.msg_namelen != sizeof(nladdr)) {
@@ -184,10 +184,10 @@ static int rtnl_dump_filter(struct rtnl_
 			if (h->nlmsg_type == NLMSG_ERROR) {
 				struct nlmsgerr *l_err = (struct nlmsgerr*)NLMSG_DATA(h);
 				if (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr))) {
-					bb_error_msg("ERROR truncated");
+					bb_simple_error_msg("ERROR truncated");
 				} else {
 					errno = -l_err->error;
-					bb_perror_msg("RTNETLINK answers");
+					bb_simple_perror_msg("RTNETLINK answers");
 				}
 				goto ret;
 			}
@@ -201,7 +201,7 @@ static int rtnl_dump_filter(struct rtnl_
 			h = NLMSG_NEXT(h, status);
 		}
 		if (msg.msg_flags & MSG_TRUNC) {
-			bb_error_msg("message truncated");
+			bb_simple_error_msg("message truncated");
 			continue;
 		}
 		if (status) {
@@ -221,7 +221,7 @@ int FAST_FUNC xrtnl_dump_filter(struct r
 {
 	int ret = rtnl_dump_filter(rth, filter, arg1/*, NULL, NULL*/);
 	if (ret < 0)
-		bb_error_msg_and_die("dump terminated");
+		bb_simple_error_msg_and_die("dump terminated");
 	return ret;
 }
 
@@ -266,7 +266,7 @@ int FAST_FUNC rtnl_talk(struct rtnl_hand
 	status = sendmsg(rtnl->fd, &msg, 0);
 
 	if (status < 0) {
-		bb_perror_msg("can't talk to rtnetlink");
+		bb_simple_perror_msg("can't talk to rtnetlink");
 		goto ret;
 	}
 
@@ -280,11 +280,11 @@ int FAST_FUNC rtnl_talk(struct rtnl_hand
 			if (errno == EINTR) {
 				continue;
 			}
-			bb_perror_msg("OVERRUN");
+			bb_simple_perror_msg("OVERRUN");
 			continue;
 		}
 		if (status == 0) {
-			bb_error_msg("EOF on netlink");
+			bb_simple_error_msg("EOF on netlink");
 			goto ret;
 		}
 		if (msg.msg_namelen != sizeof(nladdr)) {
@@ -297,7 +297,7 @@ int FAST_FUNC rtnl_talk(struct rtnl_hand
 
 			if (l < 0 || len > status) {
 				if (msg.msg_flags & MSG_TRUNC) {
-					bb_error_msg("truncated message");
+					bb_simple_error_msg("truncated message");
 					goto ret;
 				}
 				bb_error_msg_and_die("malformed message: len=%d!", len);
@@ -320,7 +320,7 @@ int FAST_FUNC rtnl_talk(struct rtnl_hand
 			if (h->nlmsg_type == NLMSG_ERROR) {
 				struct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);
 				if (l < (int)sizeof(struct nlmsgerr)) {
-					bb_error_msg("ERROR truncated");
+					bb_simple_error_msg("ERROR truncated");
 				} else {
 					errno = - err->error;
 					if (errno == 0) {
@@ -329,7 +329,7 @@ int FAST_FUNC rtnl_talk(struct rtnl_hand
 						}
 						goto ret_0;
 					}
-					bb_perror_msg("RTNETLINK answers");
+					bb_simple_perror_msg("RTNETLINK answers");
 				}
 				goto ret;
 			}
@@ -338,13 +338,13 @@ int FAST_FUNC rtnl_talk(struct rtnl_hand
 				goto ret_0;
 			}
 
-			bb_error_msg("unexpected reply!");
+			bb_simple_error_msg("unexpected reply!");
 
 			status -= NLMSG_ALIGN(len);
 			h = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));
 		}
 		if (msg.msg_flags & MSG_TRUNC) {
-			bb_error_msg("message truncated");
+			bb_simple_error_msg("message truncated");
 			continue;
 		}
 		if (status) {
diff -urpN busybox-1.31.1/networking/libiproute/utils.c busybox-1.32.0/networking/libiproute/utils.c
--- busybox-1.31.1/networking/libiproute/utils.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/libiproute/utils.c	2020-06-26 22:47:44.000000000 +0400
@@ -230,7 +230,7 @@ uint32_t FAST_FUNC get_addr32(char *name
 char** FAST_FUNC next_arg(char **argv)
 {
 	if (!*++argv)
-		bb_error_msg_and_die("command line is not complete, try \"help\"");
+		bb_simple_error_msg_and_die("command line is not complete, try \"help\"");
 	return argv;
 }
 
diff -urpN busybox-1.31.1/networking/nbd-client.c busybox-1.32.0/networking/nbd-client.c
--- busybox-1.31.1/networking/nbd-client.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/nbd-client.c	2020-06-26 22:47:44.000000000 +0400
@@ -179,7 +179,7 @@ int nbdclient_main(int argc, char **argv
 		if (memcmp(&nbd_header.magic1, "NBDMAGIC",
 				sizeof(nbd_header.magic1)) != 0
 		) {
-			bb_error_msg_and_die("login failed");
+			bb_simple_error_msg_and_die("login failed");
 		}
 		if (memcmp(&nbd_header.magic2,
 				"\x00\x00\x42\x02\x81\x86\x12\x53",
@@ -189,7 +189,7 @@ int nbdclient_main(int argc, char **argv
 		} else if (memcmp(&nbd_header.magic2, "IHAVEOPT", 8) == 0) {
 			proto_new = 1;
 		} else {
-			bb_error_msg_and_die("login failed");
+			bb_simple_error_msg_and_die("login failed");
 		}
 
 		if (!proto_new) {
@@ -240,17 +240,17 @@ int nbdclient_main(int argc, char **argv
 		}
 
 		if (ioctl(nbd, BLKROSET, &ro) < 0) {
-			bb_perror_msg_and_die("BLKROSET");
+			bb_simple_perror_msg_and_die("BLKROSET");
 		}
 
 		if (timeout) {
 			if (ioctl(nbd, NBD_SET_TIMEOUT, (unsigned long) timeout)) {
-				bb_perror_msg_and_die("NBD_SET_TIMEOUT");
+				bb_simple_perror_msg_and_die("NBD_SET_TIMEOUT");
 			}
 		}
 
 		if (ioctl(nbd, NBD_SET_SOCK, sock)) {
-			bb_perror_msg_and_die("NBD_SET_SOCK");
+			bb_simple_perror_msg_and_die("NBD_SET_SOCK");
 		}
 
 		//if (swap) mlockall(MCL_CURRENT|MCL_FUTURE);
diff -urpN busybox-1.31.1/networking/nc.c busybox-1.32.0/networking/nc.c
--- busybox-1.31.1/networking/nc.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/nc.c	2020-06-26 22:47:44.000000000 +0400
@@ -112,7 +112,7 @@
 
 static void timeout(int signum UNUSED_PARAM)
 {
-	bb_error_msg_and_die("timed out");
+	bb_simple_error_msg_and_die("timed out");
 }
 
 int nc_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -211,7 +211,7 @@ int nc_main(int argc, char **argv)
  accept_again:
 			cfd = accept(sfd, NULL, 0);
 			if (cfd < 0)
-				bb_perror_msg_and_die("accept");
+				bb_simple_perror_msg_and_die("accept");
 			if (!execparam)
 				close(sfd);
 		} else {
@@ -260,7 +260,7 @@ int nc_main(int argc, char **argv)
 		int nread;
 
 		if (safe_poll(pfds, 2, -1) < 0)
-			bb_perror_msg_and_die("poll");
+			bb_simple_perror_msg_and_die("poll");
 
 		fdidx = 0;
 		while (1) {
diff -urpN busybox-1.31.1/networking/nc_bloaty.c busybox-1.32.0/networking/nc_bloaty.c
--- busybox-1.31.1/networking/nc_bloaty.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/nc_bloaty.c	2020-06-26 22:47:44.000000000 +0400
@@ -198,8 +198,8 @@ enum {
 #define Debug(...) do { } while (0)
 #endif
 
-#define holler_error(...)  do { if (o_verbose) bb_error_msg(__VA_ARGS__); } while (0)
-#define holler_perror(...) do { if (o_verbose) bb_perror_msg(__VA_ARGS__); } while (0)
+#define holler_error(msg)  do { if (o_verbose) bb_simple_error_msg(msg); } while (0)
+#define holler_perror(msg) do { if (o_verbose) bb_simple_perror_msg(msg); } while (0)
 
 /* catch: no-brainer interrupt handler */
 static void catch(int sig)
@@ -361,10 +361,10 @@ static void dolisten(int is_persistent,
 			rr = recv_from_to(netfd, NULL, 0, MSG_PEEK, /*was bigbuf_net, BIGSIZ*/
 				&remend.u.sa, &ouraddr->u.sa, ouraddr->len);
 			if (rr < 0)
-				bb_perror_msg_and_die("recvfrom");
+				bb_simple_perror_msg_and_die("recvfrom");
 			unarm();
 		} else
-			bb_error_msg_and_die("timeout");
+			bb_simple_error_msg_and_die("timeout");
 /* Now we learned *to which IP* peer has connected, and we want to anchor
 our socket on it, so that our outbound packets will have correct local IP.
 Unfortunately, bind() on already bound socket will fail now (EINVAL):
@@ -382,7 +382,7 @@ create new one, and bind() it. TODO */
 			remend.len = LSA_SIZEOF_SA;
 			rr = accept(netfd, &remend.u.sa, &remend.len);
 			if (rr < 0)
-				bb_perror_msg_and_die("accept");
+				bb_simple_perror_msg_and_die("accept");
 			if (themaddr) {
 				int sv_port, port, r;
 
@@ -409,7 +409,7 @@ create new one, and bind() it. TODO */
 			}
 			unarm();
 		} else
-			bb_error_msg_and_die("timeout");
+			bb_simple_error_msg_and_die("timeout");
 
 		if (is_persistent && proggie) {
 			/* -l -k -e PROG */
@@ -494,7 +494,7 @@ static int udptest(void)
 
 	rr = write(netfd, bigbuf_in, 1);
 	if (rr != 1)
-		bb_perror_msg("udptest first write");
+		bb_simple_perror_msg("udptest first write");
 
 	if (o_wait)
 		sleep(o_wait); // can be interrupted! while (t) nanosleep(&t)?
@@ -644,7 +644,7 @@ static int readwrite(void)
 			if (rr <= 0) {
 				if (rr < 0 && o_verbose > 1) {
 					/* nc 1.10 doesn't do this */
-					bb_perror_msg("net read");
+					bb_simple_perror_msg("net read");
 				}
 				pfds[1].fd = -1;                   /* don't poll for netfd anymore */
 				fds_open--;
@@ -869,7 +869,7 @@ int nc_main(int argc UNUSED_PARAM, char
 		/* apparently UDP can listen ON "port 0",
 		 but that's not useful */
 		if (!o_lport)
-			bb_error_msg_and_die("UDP listen needs nonzero -p port");
+			bb_simple_error_msg_and_die("UDP listen needs nonzero -p port");
 	}
 #endif
 
diff -urpN busybox-1.31.1/networking/netstat.c busybox-1.32.0/networking/netstat.c
--- busybox-1.31.1/networking/netstat.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/netstat.c	2020-06-26 22:47:44.000000000 +0400
@@ -172,7 +172,7 @@ struct prg_node {
 #define PRG_HASH_SIZE 211
 
 struct globals {
-	smallint flags;
+	smalluint flags;
 #if ENABLE_FEATURE_NETSTAT_PRG
 	smallint prg_cache_loaded;
 	struct prg_node *prg_hash[PRG_HASH_SIZE];
@@ -343,9 +343,9 @@ static void prg_cache_load(void)
 		return;
 
 	if (prg_cache_loaded == 1)
-		bb_error_msg("can't scan /proc - are you root?");
+		bb_simple_error_msg("can't scan /proc - are you root?");
 	else
-		bb_error_msg("showing only processes with your user ID");
+		bb_simple_error_msg("showing only processes with your user ID");
 }
 
 #else
diff -urpN busybox-1.31.1/networking/nslookup.c busybox-1.32.0/networking/nslookup.c
--- busybox-1.31.1/networking/nslookup.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/nslookup.c	2020-06-26 22:47:44.000000000 +0400
@@ -283,6 +283,7 @@ static const struct {
 	{ ns_t_cname, "CNAME" },
 	{ ns_t_mx,    "MX"    },
 	{ ns_t_txt,   "TXT"   },
+	{ ns_t_srv,   "SRV"   },
 	{ ns_t_ptr,   "PTR"   },
 	{ ns_t_any,   "ANY"   },
 };
@@ -435,6 +436,25 @@ static int parse_reply(const unsigned ch
 			}
 			break;
 
+		case ns_t_srv:
+			if (rdlen < 6) {
+				//printf("SRV record too short\n");
+				return -1;
+			}
+
+			cp = ns_rr_rdata(rr);
+			n = ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
+			                       cp + 6, dname, sizeof(dname));
+
+			if (n < 0) {
+				//printf("Unable to uncompress domain: %s\n", strerror(errno));
+				return -1;
+			}
+
+			printf("%s\tservice = %u %u %u %s\n", ns_rr_name(rr),
+				ns_get16(cp), ns_get16(cp + 2), ns_get16(cp + 4), dname);
+			break;
+
 		case ns_t_soa:
 			if (rdlen < 20) {
 				dbg("SOA record too short:%d\n", rdlen);
@@ -549,7 +569,7 @@ static int send_queries(struct ns *ns)
 
 		recvlen = read(pfd.fd, reply, sizeof(reply));
 		if (recvlen < 0) {
-			bb_perror_msg("read");
+			bb_simple_perror_msg("read");
  next:
 			tcur = monotonic_ms();
 			continue;
@@ -615,9 +635,15 @@ static int send_queries(struct ns *ns)
 					G.query[qn].name, rcodes[rcode]);
 			G.exitcode = EXIT_FAILURE;
 		} else {
-			if (parse_reply(reply, recvlen) < 0) {
+			switch (parse_reply(reply, recvlen)) {
+			case -1:
 				printf("*** Can't find %s: Parse error\n", G.query[qn].name);
 				G.exitcode = EXIT_FAILURE;
+				break;
+
+			case 0:
+				printf("*** Can't find %s: No answer\n", G.query[qn].name);
+				break;
 			}
 		}
 		bb_putchar('\n');
diff -urpN busybox-1.31.1/networking/ntpd.c busybox-1.32.0/networking/ntpd.c
--- busybox-1.31.1/networking/ntpd.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/ntpd.c	2020-06-26 22:47:44.000000000 +0400
@@ -164,7 +164,7 @@
  */
 
 #define INITIAL_SAMPLES    4    /* how many samples do we want for init */
-#define MIN_FREQHOLD      12    /* adjust offset, but not freq in this many first adjustments */
+#define MIN_FREQHOLD      10    /* adjust offset, but not freq in this many first adjustments */
 #define BAD_DELAY_GROWTH   4    /* drop packet if its delay grew by more than this factor */
 
 #define RETRY_INTERVAL    32    /* on send/recv error, retry in N secs (need to be power of 2) */
@@ -504,12 +504,14 @@ static ALWAYS_INLINE double MAXD(double
 		return a;
 	return b;
 }
+#if !USING_KERNEL_PLL_LOOP
 static ALWAYS_INLINE double MIND(double a, double b)
 {
 	if (a < b)
 		return a;
 	return b;
 }
+#endif
 static NOINLINE double my_SQRT(double X)
 {
 	union {
@@ -905,7 +907,7 @@ do_sendto(int fd,
 		ret = send_to_from(fd, msg, len, MSG_DONTWAIT, to, from, addrlen);
 	}
 	if (ret != len) {
-		bb_perror_msg("send failed");
+		bb_simple_perror_msg("send failed");
 		return -1;
 	}
 	return 0;
@@ -1121,7 +1123,7 @@ step_time(double offset)
 	dtime = tvc.tv_sec + (1.0e-6 * tvc.tv_usec) + offset;
 	d_to_tv(dtime, &tvn);
 	if (settimeofday(&tvn, NULL) == -1)
-		bb_perror_msg_and_die("settimeofday");
+		bb_simple_perror_msg_and_die("settimeofday");
 
 	VERB2 {
 		tval = tvc.tv_sec;
@@ -1494,7 +1496,7 @@ select_and_cluster(void)
 		/* Starting from 1 is ok here */
 		for (i = 1; i < num_survivors; i++) {
 			if (G.last_update_peer == survivor[i].p) {
-				VERB5 bb_error_msg("keeping old synced peer");
+				VERB5 bb_simple_error_msg("keeping old synced peer");
 				p = G.last_update_peer;
 				goto keep_old;
 			}
@@ -1702,7 +1704,7 @@ update_local_clock(peer_t *p)
 #else
 			set_new_values(STATE_SYNC, offset, recv_time);
 #endif
-			VERB4 bb_error_msg("transitioning to FREQ, datapoint ignored");
+			VERB4 bb_simple_error_msg("transitioning to FREQ, datapoint ignored");
 			return 0; /* "leave poll interval as is" */
 
 #if 0 /* this is dead code for now */
@@ -1796,7 +1798,7 @@ update_local_clock(peer_t *p)
 	VERB4 {
 		memset(&tmx, 0, sizeof(tmx));
 		if (adjtimex(&tmx) < 0)
-			bb_perror_msg_and_die("adjtimex");
+			bb_simple_perror_msg_and_die("adjtimex");
 		bb_error_msg("p adjtimex freq:%ld offset:%+ld status:0x%x tc:%ld",
 				tmx.freq, tmx.offset, tmx.status, tmx.constant);
 	}
@@ -1874,9 +1876,11 @@ update_local_clock(peer_t *p)
 //15:31:53.473 update from:<IP> offset:+0.000007 delay:0.158142 jitter:0.010922 clock drift:+9.343ppm tc:6
 //15:32:58.902 update from:<IP> offset:-0.000728 delay:0.158222 jitter:0.009454 clock drift:+9.298ppm tc:6
 			/*
-			 * This expression would choose MIN_FREQHOLD + 8 in the above example.
+			 * This expression would choose MIN_FREQHOLD + 14 in the above example
+			 * (off_032 is +1 for each 0.032768 seconds of offset).
 			 */
-			G.FREQHOLD_cnt = 1 + MIN_FREQHOLD + ((unsigned)(abs(tmx.offset)) >> 16);
+			unsigned off_032 = abs((int)(tmx.offset >> 15));
+			G.FREQHOLD_cnt = 1 + MIN_FREQHOLD + off_032;
 		}
 		G.FREQHOLD_cnt--;
 		tmx.status |= STA_FREQHOLD;
@@ -1906,7 +1910,7 @@ update_local_clock(peer_t *p)
 	//tmx.maxerror = (uint32_t)((sys_rootdelay / 2 + sys_rootdisp) * 1e6);
 	rc = adjtimex(&tmx);
 	if (rc < 0)
-		bb_perror_msg_and_die("adjtimex");
+		bb_simple_perror_msg_and_die("adjtimex");
 	/* NB: here kernel returns constant == G.poll_exp, not == G.poll_exp - 4.
 	 * Not sure why. Perhaps it is normal.
 	 */
@@ -2018,7 +2022,7 @@ recv_and_process_peer_pkt(peer_t *p)
 
 #if ENABLE_FEATURE_NTP_AUTH
 	if (size != NTP_MSGSIZE_NOAUTH && size != NTP_MSGSIZE_MD5_AUTH && size != NTP_MSGSIZE_SHA1_AUTH) {
-		bb_error_msg("malformed packet received from %s", p->p_dotted);
+		bb_error_msg("malformed packet received from %s: size %u", p->p_dotted, (int)size);
 		return;
 	}
 	if (p->key_entry && hashes_differ(p, &msg)) {
@@ -2027,7 +2031,7 @@ recv_and_process_peer_pkt(peer_t *p)
 	}
 #else
 	if (size != NTP_MSGSIZE_NOAUTH && size != NTP_MSGSIZE_MD5_AUTH) {
-		bb_error_msg("malformed packet received from %s", p->p_dotted);
+		bb_error_msg("malformed packet received from %s: size %u", p->p_dotted, (int)size);
 		return;
 	}
 #endif
@@ -2238,6 +2242,13 @@ recv_and_process_client_pkt(void /*int f
 	from = xzalloc(to->len);
 
 	size = recv_from_to(G_listen_fd, &msg, sizeof(msg), MSG_DONTWAIT, from, &to->u.sa, to->len);
+
+	/* "ntpq -p" (4.2.8p13) sends a 12-byte NTPv2 request:
+	 * m_status is 0x16: leap:0 version:2 mode:6(reserved1)
+	 *  https://docs.ntpsec.org/latest/mode6.html
+	 * We don't support this.
+	 */
+
 #if ENABLE_FEATURE_NTP_AUTH
 	if (size != NTP_MSGSIZE_NOAUTH && size != NTP_MSGSIZE_MD5_AUTH && size != NTP_MSGSIZE_SHA1_AUTH)
 #else
@@ -2248,7 +2259,7 @@ recv_and_process_client_pkt(void /*int f
 		if (size < 0) {
 			if (errno == EAGAIN)
 				goto bail;
-			bb_perror_msg_and_die("recv");
+			bb_simple_perror_msg_and_die("recv");
 		}
 		addr = xmalloc_sockaddr2dotted_noport(from);
 		bb_error_msg("malformed packet received from %s: size %u", addr, (int)size);
@@ -2415,7 +2426,7 @@ static NOINLINE void ntp_init(char **arg
 	srand(getpid());
 
 	if (getuid())
-		bb_error_msg_and_die(bb_msg_you_must_be_root);
+		bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 
 	/* Set some globals */
 	G.discipline_jitter = G_precision_sec;
@@ -2436,7 +2447,8 @@ static NOINLINE void ntp_init(char **arg
 			"d" /* compat */
 			"46aAbgL" /* compat, ignored */
 				"\0"
-				"dd:wn"  /* -d: counter; -p: list; -w implies -n */
+				"=0"      /* should have no arguments */
+				":dd:wn"  /* -d: counter; -p: list; -w implies -n */
 				IF_FEATURE_NTPD_SERVER(":Il") /* -I implies -l */
 			IF_FEATURE_NTP_AUTH(, &key_file_path)
 			, &peers, &G.script_name
@@ -2490,7 +2502,7 @@ static NOINLINE void ntp_init(char **arg
 				/* supports 'sha' and 'sha1' formats */
 				hash_type = HASH_SHA1;
 			else
-				bb_error_msg_and_die("only MD5 and SHA1 keys supported");
+				bb_simple_error_msg_and_die("only MD5 and SHA1 keys supported");
 /* man ntp.keys:
  *  MD5    The key is 1 to 16 printable characters terminated by an EOL,
  *         whitespace, or a # (which is the "start of comment" character).
@@ -2673,7 +2685,7 @@ int ntpd_main(int argc UNUSED_PARAM, cha
 				if (p->p_fd == -1) {
 					/* Time to send new req */
 					if (--cnt == 0) {
-						VERB4 bb_error_msg("disabling burst mode");
+						VERB4 bb_simple_error_msg("disabling burst mode");
 						G.polladj_count = 0;
 						G.poll_exp = MINPOLL;
 					}
diff -urpN busybox-1.31.1/networking/ping.c busybox-1.32.0/networking/ping.c
--- busybox-1.31.1/networking/ping.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/ping.c	2020-06-26 22:47:44.000000000 +0400
@@ -184,8 +184,8 @@ create_icmp_socket(void)
 		sock = socket(AF_INET, SOCK_RAW, 1); /* 1 == ICMP */
 	if (sock < 0) {
 		if (errno == EPERM)
-			bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
-		bb_perror_msg_and_die(bb_msg_can_not_create_raw_socket);
+			bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_perror_msg_and_die(bb_msg_can_not_create_raw_socket);
 	}
 
 	xmove_fd(sock, pingsock);
@@ -235,7 +235,7 @@ static void ping4(len_and_sockaddr *lsa)
 #endif
 		if (c < 0) {
 			if (errno != EINTR)
-				bb_perror_msg("recvfrom");
+				bb_simple_perror_msg("recvfrom");
 			continue;
 		}
 		if (c >= 76) {			/* ip + icmp */
@@ -280,7 +280,7 @@ static void ping6(len_and_sockaddr *lsa)
 #endif
 		if (c < 0) {
 			if (errno != EINTR)
-				bb_perror_msg("recvfrom");
+				bb_simple_perror_msg("recvfrom");
 			continue;
 		}
 		if (c >= ICMP_MINLEN) {	/* icmp6_hdr */
@@ -482,7 +482,7 @@ static void sendping_tail(void (*sp)(int
 	 * it doesn't matter */
 	sz = xsendto(pingsock, G.snd_packet, size_pkt, &pingaddr.sa, sizeof(pingaddr));
 	if (sz != size_pkt)
-		bb_error_msg_and_die(bb_msg_write_error);
+		bb_simple_error_msg_and_die(bb_msg_write_error);
 
 	if (pingcount == 0 || G.ntransmitted < pingcount) {
 		/* Didn't send all pings yet - schedule next in -i SEC interval */
@@ -723,7 +723,7 @@ static void ping4(len_and_sockaddr *lsa)
 	if (source_lsa) {
 		if (setsockopt(pingsock, IPPROTO_IP, IP_MULTICAST_IF,
 				&source_lsa->u.sa, source_lsa->len))
-			bb_error_msg_and_die("can't set multicast source interface");
+			bb_simple_error_msg_and_die("can't set multicast source interface");
 		xbind(pingsock, &source_lsa->u.sa, source_lsa->len);
 	}
 
@@ -757,7 +757,7 @@ static void ping4(len_and_sockaddr *lsa)
 				(struct sockaddr *) &from, &fromlen);
 		if (c < 0) {
 			if (errno != EINTR)
-				bb_perror_msg("recvfrom");
+				bb_simple_perror_msg("recvfrom");
 			continue;
 		}
 		c = unpack4(G.rcv_packet, c, &from);
@@ -838,7 +838,7 @@ static void ping6(len_and_sockaddr *lsa)
 		c = recvmsg(pingsock, &msg, 0);
 		if (c < 0) {
 			if (errno != EINTR)
-				bb_perror_msg("recvfrom");
+				bb_simple_perror_msg("recvfrom");
 			continue;
 		}
 		for (mp = CMSG_FIRSTHDR(&msg); mp; mp = CMSG_NXTHDR(&msg, mp)) {
diff -urpN busybox-1.31.1/networking/route.c busybox-1.32.0/networking/route.c
--- busybox-1.31.1/networking/route.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/route.c	2020-06-26 22:47:44.000000000 +0400
@@ -336,7 +336,7 @@ static NOINLINE void INET_setroute(int a
 		}
 		mask = ((struct sockaddr_in *) &rt->rt_dst)->sin_addr.s_addr;
 		if (mask & ~(uint32_t)mask_in_addr(*rt)) {
-			bb_error_msg_and_die("netmask and route address conflict");
+			bb_simple_error_msg_and_die("netmask and route address conflict");
 		}
 	}
 
@@ -532,7 +532,7 @@ void FAST_FUNC bb_displayroutes(int nore
 			if ((r < 0) && feof(fp)) { /* EOF with no (nonspace) chars read. */
 				break;
 			}
-			bb_perror_msg_and_die(bb_msg_read_error);
+			bb_simple_perror_msg_and_die(bb_msg_read_error);
 		}
 
 		if (!(flgs & RTF_UP)) { /* Skip interfaces that are down. */
@@ -598,7 +598,7 @@ static void INET6_displayroutes(void)
 				break;
 			}
  ERROR:
-			bb_perror_msg_and_die(bb_msg_read_error);
+			bb_simple_perror_msg_and_die(bb_msg_read_error);
 		}
 
 		/* Do the addr6x shift-and-insert changes to ':'-delimit addresses.
@@ -628,6 +628,7 @@ static void INET6_displayroutes(void)
 
 		r = 0;
 		while (1) {
+			memset(&snaddr6, 0, sizeof(snaddr6));
 			inet_pton(AF_INET6, addr6x + r,
 					  (struct sockaddr *) &snaddr6.sin6_addr);
 			snaddr6.sin6_family = AF_INET6;
diff -urpN busybox-1.31.1/networking/slattach.c busybox-1.32.0/networking/slattach.c
--- busybox-1.31.1/networking/slattach.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/slattach.c	2020-06-26 22:47:44.000000000 +0400
@@ -56,7 +56,7 @@ static int tcsetattr_serial_or_warn(stru
 
 	ret = tcsetattr(serial_fd, TCSANOW, state);
 	if (ret != 0) {
-		bb_perror_msg("tcsetattr");
+		bb_simple_perror_msg("tcsetattr");
 		return 1; /* used as exitcode */
 	}
 	return ret; /* 0 */
@@ -159,7 +159,7 @@ int slattach_main(int argc UNUSED_PARAM,
 
 	/* Save current tty state */
 	if (tcgetattr(serial_fd, &G.saved_state) != 0)
-		bb_perror_msg_and_die("tcgetattr");
+		bb_simple_perror_msg_and_die("tcgetattr");
 	/* Save line discipline */
 	xioctl(serial_fd, TIOCGETD, &G.saved_disc);
 
diff -urpN busybox-1.31.1/networking/tc.c busybox-1.32.0/networking/tc.c
--- busybox-1.31.1/networking/tc.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/tc.c	2020-06-26 22:47:44.000000000 +0400
@@ -215,8 +215,6 @@ static int prio_print_opt(struct rtattr
 	if (opt == NULL)
 		return 0;
 	parse_rtattr_nested_compat(tb, TCA_PRIO_MAX, opt, qopt, sizeof(*qopt));
-	if (tb == NULL)
-		return 0;
 	printf("bands %u priomap ", qopt->bands);
 	for (i=0; i<=TC_PRIO_MAX; i++)
 		printf(" %d", qopt->priomap[i]);
diff -urpN busybox-1.31.1/networking/tcpudp.c busybox-1.32.0/networking/tcpudp.c
--- busybox-1.31.1/networking/tcpudp.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/tcpudp.c	2020-06-26 22:47:44.000000000 +0400
@@ -325,7 +325,7 @@ int tcpudpsvd_main(int argc UNUSED_PARAM
 	client = 0;
 	if ((getuid() == 0) && !(opts & OPT_u)) {
 		xfunc_error_retval = 100;
-		bb_error_msg_and_die(bb_msg_you_must_be_root);
+		bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 	}
 	if (opts & OPT_u)
 		if (!uidgid_get(&sslugid, ssluser, 1)) {
@@ -419,7 +419,7 @@ int tcpudpsvd_main(int argc UNUSED_PARAM
 	sig_block(SIGCHLD);
 	if (conn < 0) {
 		if (errno != EINTR)
-			bb_perror_msg(tcp ? "accept" : "recv");
+			bb_simple_perror_msg(tcp ? "accept" : "recv");
 		goto again2;
 	}
 	xmove_fd(tcp ? conn : sock, 0);
@@ -484,7 +484,7 @@ int tcpudpsvd_main(int argc UNUSED_PARAM
 
 	pid = vfork();
 	if (pid == -1) {
-		bb_perror_msg("vfork");
+		bb_simple_perror_msg("vfork");
 		goto again;
 	}
 
diff -urpN busybox-1.31.1/networking/telnet.c busybox-1.32.0/networking/telnet.c
--- busybox-1.31.1/networking/telnet.c	2019-10-21 18:54:40.000000000 +0400
+++ busybox-1.32.0/networking/telnet.c	2020-06-26 22:47:44.000000000 +0400
@@ -238,6 +238,18 @@ static void handle_net_output(int len)
 			*dst = '\r'; /* Enter -> CR LF */
 			*++dst = '\n';
 		}
+#if 0
+/* putty's "special commands" mode does this: */
+/* Korenix 3005 switch needs at least the backspace tweak */
+		if (c == 0x08 || c == 0x7f) { /* ctrl+h || backspace */
+			*dst = IAC;
+			*++dst = EC;
+		}
+		if (c == 0x03) { /* ctrl+c */
+			*dst = IAC;
+			*++dst = IP;
+		}
+#endif
 		dst++;
 	}
 	if (dst - outbuf != 0)
diff -urpN busybox-1.31.1/networking/telnetd.c busybox-1.32.0/networking/telnetd.c
--- busybox-1.31.1/networking/telnetd.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/telnetd.c	2020-06-26 22:47:44.000000000 +0400
@@ -495,7 +495,7 @@ make_new_session(
 		free(ts);
 		close(fd);
 		/* sock will be closed by caller */
-		bb_perror_msg("vfork");
+		bb_simple_perror_msg("vfork");
 		return NULL;
 	}
 	if (pid > 0) {
diff -urpN busybox-1.31.1/networking/tftp.c busybox-1.32.0/networking/tftp.c
--- busybox-1.31.1/networking/tftp.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/tftp.c	2020-06-26 22:47:44.000000000 +0400
@@ -319,7 +319,7 @@ static int tftp_protocol(
 	uint16_t opcode;
 	uint16_t block_nr;
 	uint16_t recv_blk;
-	int open_mode, local_fd;
+	int local_fd = -1;
 	int retries, waittime_ms;
 	int io_bufsize = blksize + 4;
 	char *cp;
@@ -354,19 +354,6 @@ static int tftp_protocol(
 		}
 	}
 
-	/* Prepare open mode */
-	if (CMD_PUT(option_mask32)) {
-		open_mode = O_RDONLY;
-	} else {
-		open_mode = O_WRONLY | O_TRUNC | O_CREAT;
-#if ENABLE_TFTPD
-		if ((option_mask32 & (TFTPD_OPT+TFTPD_OPT_c)) == TFTPD_OPT) {
-			/* tftpd without -c */
-			open_mode = O_WRONLY | O_TRUNC;
-		}
-#endif
-	}
-
 	/* Examples of network traffic.
 	 * Note two cases when ACKs with block# of 0 are sent.
 	 *
@@ -400,12 +387,29 @@ static int tftp_protocol(
 
 	if (!ENABLE_TFTP || our_lsa) { /* tftpd */
 		/* Open file (must be after changing user) */
+		int open_mode = O_RDONLY;
+		if (CMD_GET(option_mask32)) {
+			open_mode = O_WRONLY | O_TRUNC | O_CREAT;
+			if ((option_mask32 & (TFTPD_OPT+TFTPD_OPT_c)) == TFTPD_OPT) {
+				/* tftpd without -c */
+				open_mode = O_WRONLY | O_TRUNC;
+			}
+		}
 		local_fd = open(local_file, open_mode, 0666);
 		if (local_fd < 0) {
+			/* sanitize name, it came from untrusted remote side */
+			unsigned char *p = (void *) local_file;
+			while (*p) {
+				if (*p < ' ')
+					*p = '?';
+				p++;
+			}
+			bb_perror_msg("can't open '%s'", local_file);
 			G_error_pkt_reason = ERR_NOFILE;
 			strcpy(G_error_pkt_str, "can't open file");
-			goto send_err_pkt;
+			goto send_err_pkt_nomsg;
 		}
+
 /* gcc 4.3.1 would NOT optimize it out as it should! */
 #if ENABLE_FEATURE_TFTP_BLOCKSIZE
 		if (blksize != TFTP_BLKSIZE_DEFAULT || want_transfer_size) {
@@ -424,10 +428,11 @@ static int tftp_protocol(
 			block_nr = 0;
 		}
 	} else { /* tftp */
-		/* Open file (must be after changing user) */
-		local_fd = CMD_GET(option_mask32) ? STDOUT_FILENO : STDIN_FILENO;
-		if (NOT_LONE_DASH(local_file))
-			local_fd = xopen(local_file, open_mode);
+		if (CMD_PUT(option_mask32)) {
+			local_fd = STDIN_FILENO;
+			if (local_file)
+				local_fd = xopen(local_file, O_RDONLY);
+		}
 /* Removing #if, or using if() statement instead of #if may lead to
  * "warning: null argument where non-null required": */
 #if ENABLE_TFTP
@@ -451,16 +456,14 @@ static int tftp_protocol(
 		}
 		/* add filename and mode */
 		/* fill in packet if the filename fits into xbuf */
-		len = strlen(remote_file) + 1;
-		if (2 + len + sizeof("octet") >= io_bufsize) {
-			bb_error_msg("remote filename is too long");
+		len = strlen(remote_file);
+		if (len + 3 + sizeof("octet") >= io_bufsize) {
+			bb_simple_error_msg("remote filename is too long");
 			goto ret;
 		}
-		strcpy(cp, remote_file);
-		cp += len;
+		cp = stpcpy(cp, remote_file) + 1;
 		/* add "mode" part of the packet */
-		strcpy(cp, "octet");
-		cp += sizeof("octet");
+		cp = stpcpy(cp, "octet") + 1;
 
 # if ENABLE_FEATURE_TFTP_BLOCKSIZE
 		if (blksize == TFTP_BLKSIZE_DEFAULT && !want_transfer_size)
@@ -468,7 +471,7 @@ static int tftp_protocol(
 
 		/* Need to add option to pkt */
 		if ((&xbuf[io_bufsize - 1] - cp) < sizeof("blksize NNNNN tsize ") + sizeof(off_t)*3) {
-			bb_error_msg("remote filename is too long");
+			bb_simple_error_msg("remote filename is too long");
 			goto ret;
 		}
 		expect_OACK = 1;
@@ -485,7 +488,7 @@ static int tftp_protocol(
 		}
 		if (want_transfer_size) {
 			/* add "tsize", <nul>, size, <nul> (see RFC2349) */
-			/* if tftp and downloading, we send "0" (since we opened local_fd with O_TRUNC)
+			/* if tftp and downloading, we send "0" (local_fd is not open yet)
 			 * and this makes server to send "tsize" option with the size */
 			/* if tftp and uploading, we send file size (maybe dont, to not confuse old servers???) */
 			/* if tftpd and downloading, we are answering to client's request */
@@ -494,7 +497,8 @@ static int tftp_protocol(
 			strcpy(cp, "tsize");
 			cp += sizeof("tsize");
 			st.st_size = 0;
-			fstat(local_fd, &st);
+			if (local_fd >= 0)
+				fstat(local_fd, &st);
 			cp += sprintf(cp, "%"OFF_FMT"u", (off_t)st.st_size) + 1;
 # if ENABLE_FEATURE_TFTP_PROGRESS_BAR
 			/* Save for progress bar. If 0 (tftp downloading),
@@ -569,7 +573,7 @@ static int tftp_protocol(
 			retries--;
 			if (retries == 0) {
 				tftp_progress_done();
-				bb_error_msg("timeout");
+				bb_simple_error_msg("timeout");
 				goto ret; /* no err packet sent */
 			}
 
@@ -674,7 +678,7 @@ static int tftp_protocol(
 			 * must be ignored by the client and server
 			 * as if it were never requested." */
 			if (blksize != TFTP_BLKSIZE_DEFAULT)
-				bb_error_msg("falling back to blocksize "TFTP_BLKSIZE_DEFAULT_STR);
+				bb_simple_error_msg("falling back to blocksize "TFTP_BLKSIZE_DEFAULT_STR);
 			blksize = TFTP_BLKSIZE_DEFAULT;
 			io_bufsize = TFTP_BLKSIZE_DEFAULT + 4;
 		}
@@ -684,7 +688,13 @@ static int tftp_protocol(
 
 		if (CMD_GET(option_mask32) && (opcode == TFTP_DATA)) {
 			if (recv_blk == block_nr) {
-				int sz = full_write(local_fd, &rbuf[4], len - 4);
+				int sz;
+				if (local_fd == -1) {
+					local_fd = STDOUT_FILENO;
+					if (local_file)
+						local_fd = xopen(local_file, O_WRONLY | O_TRUNC | O_CREAT);
+				}
+				sz = full_write(local_fd, &rbuf[4], len - 4);
 				if (sz != len - 4) {
 					strcpy(G_error_pkt_str, bb_msg_write_error);
 					G_error_pkt_reason = ERR_WRITE;
@@ -721,7 +731,7 @@ static int tftp_protocol(
 		 *  must never resend the current DATA packet on receipt
 		 *  of a duplicate ACK".
 		 * DATA pkts are resent ONLY on timeout.
-		 * Thus "goto send_again" will ba a bad mistake above.
+		 * Thus "goto send_again" will be a bad mistake above.
 		 * See:
 		 * http://en.wikipedia.org/wiki/Sorcerer's_Apprentice_Syndrome
 		 */
@@ -733,22 +743,27 @@ static int tftp_protocol(
 		free(xbuf);
 		free(rbuf);
 	}
-	return finished == 0; /* returns 1 on failure */
+	if (!finished)
+		goto err;
+	return EXIT_SUCCESS;
 
  send_read_err_pkt:
 	strcpy(G_error_pkt_str, bb_msg_read_error);
  send_err_pkt:
 	if (G_error_pkt_str[0])
-		bb_error_msg("%s", G_error_pkt_str);
+		bb_simple_error_msg(G_error_pkt_str);
+ send_err_pkt_nomsg:
 	G.error_pkt[1] = TFTP_ERROR;
 	xsendto(socket_fd, G.error_pkt, 4 + 1 + strlen(G_error_pkt_str),
 			&peer_lsa->u.sa, peer_lsa->len);
+ err:
+	if (local_fd >= 0 && CMD_GET(option_mask32) && local_file)
+		unlink(local_file);
 	return EXIT_FAILURE;
 #undef remote_file
 }
 
 #if ENABLE_TFTP
-
 int tftp_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int tftp_main(int argc UNUSED_PARAM, char **argv)
 {
@@ -761,7 +776,6 @@ int tftp_main(int argc UNUSED_PARAM, cha
 # endif
 	int result;
 	int port;
-	IF_GETPUT(int opt;)
 
 	INIT_G();
 
@@ -802,7 +816,7 @@ int tftp_main(int argc UNUSED_PARAM, cha
 		}
 	}
 
-	IF_GETPUT(opt =) getopt32(argv, "^"
+	getopt32(argv, "^"
 			IF_FEATURE_TFTP_GET("g") IF_FEATURE_TFTP_PUT("p")
 			"l:r:" IF_FEATURE_TFTP_BLOCKSIZE("b:")
 			IF_FEATURE_TFTP_HPA_COMPAT("m:")
@@ -853,18 +867,14 @@ int tftp_main(int argc UNUSED_PARAM, cha
 # endif
 	result = tftp_protocol(
 		NULL /*our_lsa*/, peer_lsa,
-		local_file, remote_file
+		(LONE_DASH(local_file) ? NULL : local_file), remote_file
 		IF_FEATURE_TFTP_BLOCKSIZE(, 1 /* want_transfer_size */)
 		IF_FEATURE_TFTP_BLOCKSIZE(, blksize)
 	);
 	tftp_progress_done();
 
-	if (result != EXIT_SUCCESS && NOT_LONE_DASH(local_file) && CMD_GET(opt)) {
-		unlink(local_file);
-	}
 	return result;
 }
-
 #endif /* ENABLE_TFTP */
 
 #if ENABLE_TFTPD
@@ -1001,7 +1011,6 @@ int tftpd_main(int argc UNUSED_PARAM, ch
 	strcpy(G_error_pkt_str, error_msg);
 	goto do_proto;
 }
-
 #endif /* ENABLE_TFTPD */
 
 #endif /* ENABLE_FEATURE_TFTP_GET || ENABLE_FEATURE_TFTP_PUT */
diff -urpN busybox-1.31.1/networking/tls.c busybox-1.32.0/networking/tls.c
--- busybox-1.31.1/networking/tls.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/tls.c	2020-06-26 22:47:44.000000000 +0400
@@ -446,7 +446,7 @@ static void hmac_begin(hmac_precomputed_
 	// than INSIZE bytes will first hash the key using H and then use the
 	// resultant OUTSIZE byte string as the actual key to HMAC."
 	if (key_size > SHA_INSIZE) {
-		bb_error_msg_and_die("HMAC key>64"); //does not happen (yet?)
+		bb_simple_error_msg_and_die("HMAC key>64"); //does not happen (yet?)
 //		md5sha_ctx_t ctx;
 //		begin(&ctx);
 //		md5sha_hash(&ctx, key, key_size);
@@ -1132,7 +1132,7 @@ static int tls_xread_record(tls_state_t
 		}
 	}
 	if (sz < 0)
-		bb_error_msg_and_die("encrypted data too short");
+		bb_simple_error_msg_and_die("encrypted data too short");
 
 	//dump_hex("<< %s\n", tls->inbuf, RECHDR_LEN + sz);
 
@@ -1411,7 +1411,7 @@ static void find_key_in_der_cert(tls_sta
 			dbg("ECDSA key\n");
 			//UNUSED: tls->flags |= GOT_CERT_ECDSA_KEY_ALG;
 		} else
-			bb_error_msg_and_die("not RSA or ECDSA cert");
+			bb_simple_error_msg_and_die("not RSA or ECDSA cert");
 	}
 
 	if (tls->flags & GOT_CERT_RSA_KEY_ALG) {
@@ -1882,7 +1882,7 @@ static void process_server_key(tls_state
 	/* So far we only support curve_x25519 */
 	move_from_unaligned32(t32, keybuf);
 	if (t32 != htonl(0x03001d20))
-		bb_error_msg_and_die("elliptic curve is not x25519");
+		bb_simple_error_msg_and_die("elliptic curve is not x25519");
 
 	memcpy(tls->hsd->ecc_pub_key32, keybuf + 4, 32);
 	tls->flags |= GOT_EC_KEY;
@@ -1929,7 +1929,7 @@ static void send_client_key_exchange(tls
 	if (!(tls->flags & NEED_EC_KEY)) {
 		/* RSA */
 		if (!(tls->flags & GOT_CERT_RSA_KEY_ALG))
-			bb_error_msg("server cert is not RSA");
+			bb_simple_error_msg("server cert is not RSA");
 
 		tls_get_random(rsa_premaster, sizeof(rsa_premaster));
 		if (TLS_DEBUG_FIXED_SECRETS)
@@ -1959,7 +1959,7 @@ static void send_client_key_exchange(tls
 		uint8_t privkey[CURVE25519_KEYSIZE]; //[32]
 
 		if (!(tls->flags & GOT_EC_KEY))
-			bb_error_msg("server did not provide EC key");
+			bb_simple_error_msg("server did not provide EC key");
 
 		/* Generate random private key, see RFC 7748 */
 		tls_get_random(privkey, sizeof(privkey));
@@ -2322,7 +2322,7 @@ void FAST_FUNC tls_run_copy_loop(tls_sta
 		int nread;
 
 		if (safe_poll(pfds, 2, -1) < 0)
-			bb_perror_msg_and_die("poll");
+			bb_simple_perror_msg_and_die("poll");
 
 		if (pfds[0].revents) {
 			void *buf;
diff -urpN busybox-1.31.1/networking/tls.h busybox-1.32.0/networking/tls.h
--- busybox-1.31.1/networking/tls.h	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/tls.h	2020-06-26 22:47:44.000000000 +0400
@@ -90,7 +90,7 @@ void xorbuf_aligned_AES_BLOCK_SIZE(void*
 #define matrixCryptoGetPrngData(buf, len, userPtr) (tls_get_random(buf, len), PS_SUCCESS)
 
 #define psFree(p, pool)    free(p)
-#define psTraceCrypto(...) bb_error_msg_and_die(__VA_ARGS__)
+#define psTraceCrypto(msg) bb_simple_error_msg_and_die(msg)
 
 /* Secure zerofill */
 #define memset_s(A,B,C,D) memset((A),(C),(D))
diff -urpN busybox-1.31.1/networking/tls_aesgcm.c busybox-1.32.0/networking/tls_aesgcm.c
--- busybox-1.31.1/networking/tls_aesgcm.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/tls_aesgcm.c	2020-06-26 22:47:44.000000000 +0400
@@ -13,6 +13,7 @@ typedef uint32_t word32;
 
 /* from wolfssl-3.15.3/wolfcrypt/src/aes.c */
 
+#ifdef UNUSED
 static ALWAYS_INLINE void FlattenSzInBits(byte* buf, word32 sz)
 {
     /* Multiply the sz by 8 */
@@ -32,6 +33,7 @@ static ALWAYS_INLINE void FlattenSzInBit
 //    buf[7] = sz & 0xff;
     *(uint32_t*)(buf + 4) = SWAP_BE32(sz);
 }
+#endif
 
 static void RIGHTSHIFTX(byte* x)
 {
diff -urpN busybox-1.31.1/networking/traceroute.c busybox-1.32.0/networking/traceroute.c
--- busybox-1.31.1/networking/traceroute.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/traceroute.c	2020-06-26 22:47:44.000000000 +0400
@@ -546,11 +546,11 @@ pr_type(unsigned char t)
 	};
 # if ENABLE_TRACEROUTE6
 	static const char *const ttab6[] = {
-[0]	"Error", "Dest Unreachable", "Packet Too Big", "Time Exceeded",
-[4]	"Param Problem",
-[8]	"Echo Request", "Echo Reply", "Membership Query", "Membership Report",
-[12]	"Membership Reduction", "Router Solicit", "Router Advert", "Neighbor Solicit",
-[16]	"Neighbor Advert", "Redirect",
+[0]	= "Error", "Dest Unreachable", "Packet Too Big", "Time Exceeded",
+[4]	= "Param Problem",
+[8]	= "Echo Request", "Echo Reply", "Membership Query", "Membership Report",
+[12]	= "Membership Reduction", "Router Solicit", "Router Advert", "Neighbor Solicit",
+[16]	= "Neighbor Advert", "Redirect",
 	};
 
 	if (dest_lsa->u.sa.sa_family == AF_INET6) {
@@ -875,7 +875,7 @@ common_traceroute_main(int op, char **ar
 		 * probe (e.g., on a multi-homed host).
 		 */
 		if (getuid() != 0)
-			bb_error_msg_and_die(bb_msg_you_must_be_root);
+			bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 	}
 	if (op & OPT_WAITTIME)
 		waittime = xatou_range(waittime_str, 1, 24 * 60 * 60);
@@ -1003,7 +1003,7 @@ common_traceroute_main(int op, char **ar
 		if (af == AF_INET)
 			if (setsockopt(sndsock, IPPROTO_IP, IP_MULTICAST_IF,
 					&source_lsa->u.sa, source_lsa->len))
-				bb_error_msg_and_die("can't set multicast source interface");
+				bb_simple_error_msg_and_die("can't set multicast source interface");
 //TODO: we can query source port we bound to,
 // and check it in replies... if we care enough
 		xbind(sndsock, &source_lsa->u.sa, source_lsa->len);
@@ -1025,7 +1025,7 @@ common_traceroute_main(int op, char **ar
 		/* read IP and port */
 		source_lsa = get_sock_lsa(probe_fd);
 		if (source_lsa == NULL)
-			bb_error_msg_and_die("can't get probe addr");
+			bb_simple_error_msg_and_die("can't get probe addr");
 
 		close(probe_fd);
 
diff -urpN busybox-1.31.1/networking/udhcp/arpping.c busybox-1.32.0/networking/udhcp/arpping.c
--- busybox-1.31.1/networking/udhcp/arpping.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/udhcp/arpping.c	2020-06-26 22:47:44.000000000 +0400
@@ -53,12 +53,12 @@ int FAST_FUNC arpping(uint32_t test_nip,
 
 	s = socket(PF_PACKET, SOCK_PACKET, htons(ETH_P_ARP));
 	if (s == -1) {
-		bb_perror_msg(bb_msg_can_not_create_raw_socket);
+		bb_simple_perror_msg(bb_msg_can_not_create_raw_socket);
 		return -1;
 	}
 
 	if (setsockopt_broadcast(s) == -1) {
-		bb_perror_msg("can't enable bcast on raw socket");
+		bb_simple_perror_msg("can't enable bcast on raw socket");
 		goto ret;
 	}
 
diff -urpN busybox-1.31.1/networking/udhcp/common.c busybox-1.32.0/networking/udhcp/common.c
--- busybox-1.31.1/networking/udhcp/common.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/udhcp/common.c	2020-06-26 22:47:44.000000000 +0400
@@ -240,7 +240,7 @@ uint8_t* FAST_FUNC udhcp_get_option(stru
 	while (1) {
 		if (rem <= 0) {
  complain:
-			bb_error_msg("bad packet, malformed option field");
+			bb_simple_error_msg("bad packet, malformed option field");
 			return NULL;
 		}
 
@@ -431,7 +431,7 @@ static NOINLINE void attach_option(
 #if ENABLE_FEATURE_UDHCP_RFC3397
 	if ((optflag->flags & OPTION_TYPE_MASK) == OPTION_DNS_STRING) {
 		/* reuse buffer and length for RFC1035-formatted string */
-		allocated = buffer = (char *)dname_enc(NULL, 0, buffer, &length);
+		allocated = buffer = (char *)dname_enc(/*NULL, 0,*/ buffer, &length);
 	}
 #endif
 
@@ -539,7 +539,7 @@ int FAST_FUNC udhcp_str2optset(const cha
 
 		if (optflag->flags == OPTION_BIN) {
 			val = strtok(NULL, ""); /* do not split "'q w e'" */
-			trim(val);
+			if (val) trim(val);
 		} else
 			val = strtok(NULL, ", \t");
 		if (!val)
diff -urpN busybox-1.31.1/networking/udhcp/common.h busybox-1.32.0/networking/udhcp/common.h
--- busybox-1.31.1/networking/udhcp/common.h	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/udhcp/common.h	2020-06-26 22:47:44.000000000 +0400
@@ -78,7 +78,7 @@ struct BUG_bad_sizeof_struct_ip_udp_dhcp
 /*** Options ***/
 
 enum {
-	OPTION_IP = 1,
+	OPTION_IP = 0,
 	OPTION_IP_PAIR,
 	OPTION_STRING,
 	/* Opts of STRING_HOST type will be sanitized before they are passed
@@ -218,7 +218,7 @@ void udhcp_add_simple_option(struct dhcp
 #endif
 #if ENABLE_FEATURE_UDHCP_RFC3397 || ENABLE_FEATURE_UDHCPC6_RFC3646 || ENABLE_FEATURE_UDHCPC6_RFC4704
 char *dname_dec(const uint8_t *cstr, int clen, const char *pre) FAST_FUNC;
-uint8_t *dname_enc(const uint8_t *cstr, int clen, const char *src, int *retlen) FAST_FUNC;
+uint8_t *dname_enc(/*const uint8_t *cstr, int clen,*/ const char *src, int *retlen) FAST_FUNC;
 #endif
 struct option_set *udhcp_find_option(struct option_set *opt_list, uint8_t code) FAST_FUNC;
 
@@ -267,26 +267,45 @@ struct option_set *udhcp_find_option(str
 # define IF_UDHCP_VERBOSE(...) __VA_ARGS__
 extern unsigned dhcp_verbose;
 # define log1(...) do { if (dhcp_verbose >= 1) bb_info_msg(__VA_ARGS__); } while (0)
+# define log1s(msg) do { if (dhcp_verbose >= 1) bb_simple_info_msg(msg); } while (0)
 # if CONFIG_UDHCP_DEBUG >= 2
 void udhcp_dump_packet(struct dhcp_packet *packet) FAST_FUNC;
 #  define log2(...) do { if (dhcp_verbose >= 2) bb_info_msg(__VA_ARGS__); } while (0)
+#  define log2s(msg) do { if (dhcp_verbose >= 2) bb_simple_info_msg(msg); } while (0)
 # else
 #  define udhcp_dump_packet(...) ((void)0)
 #  define log2(...) ((void)0)
+#  define log2s(msg) ((void)0)
 # endif
 # if CONFIG_UDHCP_DEBUG >= 3
 #  define log3(...) do { if (dhcp_verbose >= 3) bb_info_msg(__VA_ARGS__); } while (0)
+#  define log3s(msg) do { if (dhcp_verbose >= 3) bb_simple_info_msg(msg); } while (0)
 # else
 #  define log3(...) ((void)0)
+#  define log3s(msg) ((void)0)
 # endif
 #else
 # define IF_UDHCP_VERBOSE(...)
 # define udhcp_dump_packet(...) ((void)0)
 # define log1(...) ((void)0)
+# define log1s(msg) ((void)0)
 # define log2(...) ((void)0)
+# define log2s(msg) ((void)0)
 # define log3(...) ((void)0)
+# define log3s(msg) ((void)0)
 #endif
 
+#if defined(__mips__)
+/*
+ * The 'simple' message functions have a negative impact on the size of the
+ * DHCP code when compiled for MIPS, so don't use them in this case.
+ */
+#define bb_simple_info_msg bb_info_msg
+#define bb_simple_error_msg bb_error_msg
+#define bb_simple_perror_msg_and_die bb_perror_msg_and_die
+#undef log1s
+#define log1s log1
+#endif
 
 /*** Other shared functions ***/
 
diff -urpN busybox-1.31.1/networking/udhcp/d6_common.h busybox-1.32.0/networking/udhcp/d6_common.h
--- busybox-1.31.1/networking/udhcp/d6_common.h	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/udhcp/d6_common.h	2020-06-26 22:47:44.000000000 +0400
@@ -34,7 +34,7 @@ struct d6_packet {
 		uint8_t d6_msg_type;
 		uint32_t d6_xid32;
 	} d6_u;
-	uint8_t d6_options[576 - sizeof(struct iphdr) - sizeof(struct udphdr) - 4
+	uint8_t d6_options[576 - sizeof(struct ip6_hdr) - sizeof(struct udphdr) - 4
 			+ CONFIG_UDHCPC_SLACK_FOR_BUGGY_SERVERS];
 } PACKED;
 #define d6_msg_type d6_u.d6_msg_type
diff -urpN busybox-1.31.1/networking/udhcp/d6_dhcpc.c busybox-1.32.0/networking/udhcp/d6_dhcpc.c
--- busybox-1.31.1/networking/udhcp/d6_dhcpc.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/udhcp/d6_dhcpc.c	2020-06-26 22:47:44.000000000 +0400
@@ -123,6 +123,7 @@ static const char udhcpc6_longopts[] ALI
 	"request-option\0" Required_argument "O"
 	"no-default-options\0" No_argument   "o"
 	"foreground\0"     No_argument       "f"
+	"stateless\0"      No_argument       "l"
 	USE_FOR_MMU(
 	"background\0"     No_argument       "b"
 	)
@@ -147,9 +148,10 @@ enum {
 	OPT_o = 1 << 12,
 	OPT_x = 1 << 13,
 	OPT_f = 1 << 14,
-	OPT_d = 1 << 15,
+	OPT_l = 1 << 15,
+	OPT_d = 1 << 16,
 /* The rest has variable bit positions, need to be clever */
-	OPTBIT_d = 15,
+	OPTBIT_d = 16,
 	USE_FOR_MMU(             OPTBIT_b,)
 	///IF_FEATURE_UDHCPC_ARPING(OPTBIT_a,)
 	IF_FEATURE_UDHCP_PORT(   OPTBIT_P,)
@@ -235,7 +237,7 @@ static char *string_option_to_env(const
  found:
 	val_len = (option[2] << 8) | option[3];
 	if (val_len + &option[D6_OPT_DATA] > option_end) {
-		bb_error_msg("option data exceeds option length");
+		bb_simple_error_msg("option data exceeds option length");
 		return NULL;
 	}
 	return xasprintf("%s=%.*s", name, val_len, (char*)option + 4);
@@ -479,15 +481,31 @@ static ALWAYS_INLINE uint32_t random_xid
 /* Initialize the packet with the proper defaults */
 static uint8_t *init_d6_packet(struct d6_packet *packet, char type, uint32_t xid)
 {
+	uint8_t *ptr;
 	struct d6_option *clientid;
+	unsigned secs;
 
 	memset(packet, 0, sizeof(*packet));
 
 	packet->d6_xid32 = xid;
 	packet->d6_msg_type = type;
 
+	/* ELAPSED_TIME option is required to be present by the RFC,
+	 * and some servers do check for its presense. [which?]
+	 */
+	ptr = packet->d6_options; /* NB: it is 32-bit aligned */
+	*((uint32_t*)ptr) = htonl((D6_OPT_ELAPSED_TIME << 16) + 2);
+	ptr += 4;
+	client_data.last_secs = monotonic_sec();
+	if (client_data.first_secs == 0)
+		client_data.first_secs = client_data.last_secs;
+	secs = client_data.last_secs - client_data.first_secs;
+	*((uint16_t*)ptr) = (secs < 0xffff) ? htons(secs) : 0xffff;
+	ptr += 2;
+
+	/* add CLIENTID option */
 	clientid = (void*)client_data.clientid;
-	return mempcpy(packet->d6_options, clientid, clientid->len + 2+2);
+	return mempcpy(ptr, clientid, clientid->len + 2+2);
 }
 
 static uint8_t *add_d6_client_options(uint8_t *ptr)
@@ -535,15 +553,59 @@ static int d6_mcast_from_client_data_ifi
 		0xFF, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02,
 	};
+	/* IPv6 requires different multicast contents in Ethernet Frame (RFC 2464) */
+	static const uint8_t MAC_DHCP6MCAST_ADDR[6] ALIGN2 = {
+		0x33, 0x33, 0x00, 0x01, 0x00, 0x02,
+	};
 
 	return d6_send_raw_packet(
 		packet, (end - (uint8_t*) packet),
 		/*src*/ &client6_data.ll_ip6, CLIENT_PORT6,
-		/*dst*/ (struct in6_addr*)FF02__1_2, SERVER_PORT6, MAC_BCAST_ADDR,
+		/*dst*/ (struct in6_addr*)FF02__1_2, SERVER_PORT6, MAC_DHCP6MCAST_ADDR,
 		client_data.ifindex
 	);
 }
 
+/* RFC 3315 18.1.5. Creation and Transmission of Information-request Messages
+ *
+ * The client uses an Information-request message to obtain
+ * configuration information without having addresses assigned to it.
+ *
+ * The client sets the "msg-type" field to INFORMATION-REQUEST.  The
+ * client generates a transaction ID and inserts this value in the
+ * "transaction-id" field.
+ *
+ * The client SHOULD include a Client Identifier option to identify
+ * itself to the server.  If the client does not include a Client
+ * Identifier option, the server will not be able to return any client-
+ * specific options to the client, or the server may choose not to
+ * respond to the message at all.  The client MUST include a Client
+ * Identifier option if the Information-Request message will be
+ * authenticated.
+ *
+ * The client MUST include an Option Request option (see section 22.7)
+ * to indicate the options the client is interested in receiving.  The
+ * client MAY include options with data values as hints to the server
+ * about parameter values the client would like to have returned.
+ */
+/* NOINLINE: limit stack usage in caller */
+static NOINLINE int send_d6_info_request(uint32_t xid)
+{
+	struct d6_packet packet;
+	uint8_t *opt_ptr;
+
+	/* Fill in: msg type, client id */
+	opt_ptr = init_d6_packet(&packet, D6_MSG_INFORMATION_REQUEST, xid);
+
+	/* Add options:
+	 * "param req" option according to -O, options specified with -x
+	 */
+	opt_ptr = add_d6_client_options(opt_ptr);
+
+	bb_error_msg("sending %s", "info request");
+	return d6_mcast_from_client_data_ifindex(&packet, opt_ptr);
+}
+
 /* Milticast a DHCPv6 Solicit packet to the network, with an optionally requested IP.
  *
  * RFC 3315 17.1.1. Creation of Solicit Messages
@@ -643,7 +705,7 @@ static NOINLINE int send_d6_discover(uin
 		client6_data.ia_na = xzalloc(len);
 		client6_data.ia_na->code = D6_OPT_IA_NA;
 		client6_data.ia_na->len = len - 4;
-		*(uint32_t*)client6_data.ia_na->data = rand(); /* IAID */
+		*(bb__aliased_uint32_t*)client6_data.ia_na->data = rand(); /* IAID */
 		if (requested_ipv6) {
 			struct d6_option *iaaddr = (void*)(client6_data.ia_na->data + 4+4+4);
 			iaaddr->code = D6_OPT_IAADDR;
@@ -661,7 +723,7 @@ static NOINLINE int send_d6_discover(uin
 		client6_data.ia_pd = xzalloc(len);
 		client6_data.ia_pd->code = D6_OPT_IA_PD;
 		client6_data.ia_pd->len = len - 4;
-		*(uint32_t*)client6_data.ia_pd->data = rand(); /* IAID */
+		*(bb__aliased_uint32_t*)client6_data.ia_pd->data = rand(); /* IAID */
 		opt_ptr = mempcpy(opt_ptr, client6_data.ia_pd, len);
 	}
 
@@ -848,19 +910,19 @@ static NOINLINE int d6_recv_raw_packet(s
 
 	bytes = safe_read(fd, &packet, sizeof(packet));
 	if (bytes < 0) {
-		log1("packet read error, ignoring");
+		log1s("packet read error, ignoring");
 		/* NB: possible down interface, etc. Caller should pause. */
 		return bytes; /* returns -1 */
 	}
 
 	if (bytes < (int) (sizeof(packet.ip6) + sizeof(packet.udp))) {
-		log1("packet is too short, ignoring");
+		log1s("packet is too short, ignoring");
 		return -2;
 	}
 
 	if (bytes < sizeof(packet.ip6) + ntohs(packet.ip6.ip6_plen)) {
 		/* packet is bigger than sizeof(packet), we did partial read */
-		log1("oversized packet, ignoring");
+		log1s("oversized packet, ignoring");
 		return -2;
 	}
 
@@ -874,7 +936,7 @@ static NOINLINE int d6_recv_raw_packet(s
 	/* || bytes > (int) sizeof(packet) - can't happen */
 	 || packet.udp.len != packet.ip6.ip6_plen
 	) {
-		log1("unrelated/bogus packet, ignoring");
+		log1s("unrelated/bogus packet, ignoring");
 		return -2;
 	}
 
@@ -1003,7 +1065,7 @@ static int d6_raw_socket(int ifindex)
 	}
 #endif
 
-	log1("created raw socket");
+	log1s("created raw socket");
 
 	return fd;
 }
@@ -1031,7 +1093,7 @@ static void change_listen_mode(int new_m
 /* Called only on SIGUSR1 */
 static void perform_renew(void)
 {
-	bb_info_msg("performing DHCP renew");
+	bb_simple_info_msg("performing DHCP renew");
 	switch (client_data.state) {
 	case BOUND:
 		change_listen_mode(LISTEN_KERNEL);
@@ -1059,10 +1121,10 @@ static void perform_d6_release(struct in
 	 || client_data.state == REBINDING
 	 || client_data.state == RENEW_REQUESTED
 	) {
-		bb_info_msg("unicasting a release");
+		bb_simple_info_msg("unicasting a release");
 		send_d6_release(server_ipv6, our_cur_ipv6); /* unicast */
 	}
-	bb_info_msg("entering released state");
+	bb_simple_info_msg("entering released state");
 /*
  * We can be here on: SIGUSR2,
  * or on exit (SIGTERM) and -R "release on quit" is specified.
@@ -1129,6 +1191,8 @@ static void client_background(void)
 //usage:     "\n	-o		Don't request any options (unless -O is given)"
 //usage:     "\n	-r IPv6		Request this address ('no' to not request any IP)"
 //usage:     "\n	-d		Request prefix"
+//usage:     "\n	-l		Send 'information request' instead of 'solicit'"
+//usage:     "\n			(used for servers which do not assign IPv6 addresses)"
 //usage:     "\n	-x OPT:VAL	Include option OPT in sent packets (cumulative)"
 //usage:     "\n			Examples of string, numeric, and hex byte opts:"
 //usage:     "\n			-x hostname:bbox - option 12"
@@ -1181,7 +1245,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 	/* Parse command line */
 	opt = getopt32long(argv, "^"
 		/* O,x: list; -T,-t,-A take numeric param */
-		"i:np:qRr:s:T:+t:+SA:+O:*ox:*fd"
+		"i:np:qRr:s:T:+t:+SA:+O:*ox:*fld"
 		USE_FOR_MMU("b")
 		///IF_FEATURE_UDHCPC_ARPING("a")
 		IF_FEATURE_UDHCP_PORT("P:")
@@ -1198,15 +1262,20 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 	);
 	requested_ipv6 = NULL;
 	option_mask32 |= OPT_r;
-	if (opt & OPT_r) {
+	if (opt & OPT_l) {
+		/* for -l, do not require IPv6 assignment from server */
+		option_mask32 &= ~OPT_r;
+	} else if (opt & OPT_r) {
+		/* explicit "-r ARG" given */
 		if (strcmp(str_r, "no") == 0) {
-			option_mask32 -= OPT_r;
+			option_mask32 &= ~OPT_r;
 		} else {
 			if (inet_pton(AF_INET6, str_r, &ipv6_buf) <= 0)
 				bb_error_msg_and_die("bad IPv6 address '%s'", str_r);
 			requested_ipv6 = &ipv6_buf;
 		}
 	}
+
 #if ENABLE_FEATURE_UDHCP_PORT
 	if (opt & OPT_P) {
 		CLIENT_PORT6 = xatou16(str_P);
@@ -1275,7 +1344,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 	/* Create pidfile */
 	write_pidfile(client_data.pidfile);
 	/* Goes to stdout (unless NOMMU) and possibly syslog */
-	bb_info_msg("started, v"BB_VER);
+	bb_simple_info_msg("started, v"BB_VER);
 
 	client_data.state = INIT_SELECTING;
 	d6_run_script_no_option("deconfig");
@@ -1321,7 +1390,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 					continue;
 				}
 				/* Else: an error occured, panic! */
-				bb_perror_msg_and_die("poll");
+				bb_simple_perror_msg_and_die("poll");
 			}
 		}
 
@@ -1353,7 +1422,10 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 					if (packet_num == 0)
 						xid = random_xid();
 					/* multicast */
-					send_d6_discover(xid, requested_ipv6);
+					if (opt & OPT_l)
+						send_d6_info_request(xid);
+					else
+						send_d6_discover(xid, requested_ipv6);
 					timeout = discover_timeout;
 					packet_num++;
 					continue;
@@ -1362,7 +1434,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 				d6_run_script_no_option("leasefail");
 #if BB_MMU /* -b is not supported on NOMMU */
 				if (opt & OPT_b) { /* background if no lease */
-					bb_info_msg("no lease, forking to background");
+					bb_simple_info_msg("no lease, forking to background");
 					client_background();
 					/* do not background again! */
 					opt = ((opt & ~(OPT_b|OPT_n)) | OPT_f);
@@ -1375,7 +1447,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 				} else
 #endif
 				if (opt & OPT_n) { /* abort if no lease */
-					bb_info_msg("no lease, failing");
+					bb_simple_info_msg("no lease, failing");
 					retval = 1;
 					goto ret;
 				}
@@ -1403,7 +1475,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 				client_data.state = RENEWING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
 				change_listen_mode(LISTEN_KERNEL);
-				log1("entering renew state");
+				log1s("entering renew state");
 				/* fall right through */
 			case RENEW_REQUESTED: /* manual (SIGUSR1) renew */
 			case_RENEW_REQUESTED:
@@ -1418,12 +1490,15 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 			 * Anyway, it does recover by eventually failing through
 			 * into INIT_SELECTING state.
 			 */
-					send_d6_renew(xid, &srv6_buf, requested_ipv6);
+					if (opt & OPT_l)
+						send_d6_info_request(xid);
+					else
+						send_d6_renew(xid, &srv6_buf, requested_ipv6);
 					timeout >>= 1;
 					continue;
 				}
 				/* Timed out, enter rebinding state */
-				log1("entering rebinding state");
+				log1s("entering rebinding state");
 				client_data.state = REBINDING;
 				/* fall right through */
 			case REBINDING:
@@ -1432,13 +1507,15 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 				/* Lease is *really* about to run out,
 				 * try to find DHCP server using broadcast */
 				if (timeout > 0) {
-					/* send a broadcast renew request */
-					send_d6_renew(xid, /*server_ipv6:*/ NULL, requested_ipv6);
+					if (opt & OPT_l)
+						send_d6_info_request(xid);
+					else /* send a broadcast renew request */
+						send_d6_renew(xid, /*server_ipv6:*/ NULL, requested_ipv6);
 					timeout >>= 1;
 					continue;
 				}
 				/* Timed out, enter init state */
-				bb_info_msg("lease lost, entering init state");
+				bb_simple_info_msg("lease lost, entering init state");
 				d6_run_script_no_option("deconfig");
 				client_data.state = INIT_SELECTING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
@@ -1560,7 +1637,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 				}
 				option = d6_copy_option(packet.d6_options, packet_end, D6_OPT_SERVERID);
 				if (!option) {
-					bb_info_msg("no server ID, ignoring packet");
+					bb_simple_info_msg("no server ID, ignoring packet");
 					continue;
 					/* still selecting - this server looks bad */
 				}
@@ -1740,6 +1817,12 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 					prefix_timeout = address_timeout;
 				/* note: "int timeout" will not overflow even with 0xffffffff inputs here: */
 				timeout = (prefix_timeout < address_timeout ? prefix_timeout : address_timeout) / 2;
+				if (opt & OPT_l) {
+					/* TODO: request OPTION_INFORMATION_REFRESH_TIME (32)
+					 * and use its value instead of the default 1 day.
+					 */
+					timeout = 24 * 60 * 60;
+				}
 				/* paranoia: must not be too small */
 				/* timeout > 60 - ensures at least one unicast renew attempt */
 				if (timeout < 61)
diff -urpN busybox-1.31.1/networking/udhcp/d6_packet.c busybox-1.32.0/networking/udhcp/d6_packet.c
--- busybox-1.31.1/networking/udhcp/d6_packet.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/udhcp/d6_packet.c	2020-06-26 22:47:44.000000000 +0400
@@ -35,12 +35,12 @@ int FAST_FUNC d6_recv_kernel_packet(stru
 	memset(packet, 0, sizeof(*packet));
 	bytes = safe_read(fd, packet, sizeof(*packet));
 	if (bytes < 0) {
-		log1("packet read error, ignoring");
+		log1s("packet read error, ignoring");
 		return bytes; /* returns -1 */
 	}
 
 	if (bytes < offsetof(struct d6_packet, d6_options)) {
-		bb_info_msg("packet with bad magic, ignoring");
+		bb_simple_info_msg("packet with bad magic, ignoring");
 		return -2;
 	}
 	log1("received %s", "a packet");
diff -urpN busybox-1.31.1/networking/udhcp/d6_socket.c busybox-1.32.0/networking/udhcp/d6_socket.c
--- busybox-1.31.1/networking/udhcp/d6_socket.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/udhcp/d6_socket.c	2020-06-26 22:47:44.000000000 +0400
@@ -115,7 +115,7 @@ int FAST_FUNC d6_listen_socket(int port,
 
 	setsockopt_reuseaddr(fd);
 	if (setsockopt_broadcast(fd) == -1)
-		bb_perror_msg_and_die("SO_BROADCAST");
+		bb_simple_perror_msg_and_die("SO_BROADCAST");
 
 	/* NB: bug 1032 says this doesn't work on ethernet aliases (ethN:M) */
 	if (setsockopt_bindtodevice(fd, inf))
diff -urpN busybox-1.31.1/networking/udhcp/dhcpc.c busybox-1.32.0/networking/udhcp/dhcpc.c
--- busybox-1.31.1/networking/udhcp/dhcpc.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/udhcp/dhcpc.c	2020-06-26 22:47:44.000000000 +0400
@@ -159,61 +159,27 @@ static int mton(uint32_t mask)
 }
 
 #if ENABLE_FEATURE_UDHCPC_SANITIZEOPT
-/* Check if a given label represents a valid DNS label
- * Return pointer to the first character after the label
- * (NUL or dot) upon success, NULL otherwise.
- * See RFC1035, 2.3.1
- */
+/* Check if a given name represents a valid DNS name */
+/* See RFC1035, 2.3.1 */
 /* We don't need to be particularly anal. For example, allowing _, hyphen
  * at the end, or leading and trailing dots would be ok, since it
- * can't be used for attacks. (Leading hyphen can be, if someone uses
- * cmd "$hostname"
+ * can't be used for attacks. (Leading hyphen can be, if someone uses cmd "$hostname"
  * in the script: then hostname may be treated as an option)
  */
-static const char *valid_domain_label(const char *label)
-{
-	unsigned char ch;
-	//unsigned pos = 0;
-
-	if (label[0] == '-')
-		return NULL;
-	for (;;) {
-		ch = *label;
-		if ((ch|0x20) < 'a' || (ch|0x20) > 'z') {
-			if (ch < '0' || ch > '9') {
-				if (ch == '\0' || ch == '.')
-					return label;
-				/* DNS allows only '-', but we are more permissive */
-				if (ch != '-' && ch != '_')
-					return NULL;
-			}
-		}
-		label++;
-		//pos++;
-		//Do we want this?
-		//if (pos > 63) /* NS_MAXLABEL; labels must be 63 chars or less */
-		//	return NULL;
-	}
-}
-
-/* Check if a given name represents a valid DNS name */
-/* See RFC1035, 2.3.1 */
 static int good_hostname(const char *name)
 {
-	//const char *start = name;
+	if (*name == '-') /* Can't start with '-' */
+		return 0;
 
-	for (;;) {
-		name = valid_domain_label(name);
-		if (!name)
-			return 0;
-		if (!name[0])
-			return 1;
-			//Do we want this?
-			//return ((name - start) < 1025); /* NS_MAXDNAME */
-		name++;
-		if (*name == '\0')
-			return 1; // We allow trailing dot too
+	while (*name) {
+		unsigned char ch = *name++;
+		if (!isalnum(ch))
+			/* DNS allows only '-', but we are more permissive */
+			if (ch != '-' && ch != '_' && ch != '.')
+				return 0;
+		// TODO: do we want to validate lengths against NS_MAXLABEL and NS_MAXDNAME?
 	}
+	return 1;
 }
 #else
 # define good_hostname(name) 1
@@ -242,9 +208,8 @@ static NOINLINE char *xmalloc_optname_op
 		case OPTION_IP:
 		case OPTION_IP_PAIR:
 			dest += sprint_nip(dest, "", option);
-			if (type == OPTION_IP)
-				break;
-			dest += sprint_nip(dest, "/", option + 4);
+			if (type == OPTION_IP_PAIR)
+				dest += sprint_nip(dest, "/", option + 4);
 			break;
 //		case OPTION_BOOLEAN:
 //			dest += sprintf(dest, *option ? "yes" : "no");
@@ -346,7 +311,7 @@ static NOINLINE char *xmalloc_optname_op
 			 * IPv4MaskLen <= 32,
 			 * 6rdPrefixLen <= 128,
 			 * 6rdPrefixLen + (32 - IPv4MaskLen) <= 128
-			 * (2nd condition need no check - it follows from 1st and 3rd).
+			 * (2nd condition needs no check - it follows from 1st and 3rd).
 			 * Else, return envvar with empty value ("optname=")
 			 */
 			if (len >= (1 + 1 + 16 + 4)
@@ -360,17 +325,12 @@ static NOINLINE char *xmalloc_optname_op
 				/* 6rdPrefix */
 				dest += sprint_nip6(dest, /* "", */ option);
 				option += 16;
-				len -= 1 + 1 + 16 + 4;
-				/* "+ 4" above corresponds to the length of IPv4 addr
-				 * we consume in the loop below */
-				while (1) {
-					/* 6rdBRIPv4Address(es) */
-					dest += sprint_nip(dest, " ", option);
-					option += 4;
-					len -= 4; /* do we have yet another 4+ bytes? */
-					if (len < 0)
-						break; /* no */
-				}
+				len -= 1 + 1 + 16;
+				*dest++ = ' ';
+				/* 6rdBRIPv4Address(es), use common IPv4 logic to process them */
+				type = OPTION_IP;
+				optlen = 4;
+				continue;
 			}
 
 			return ret;
@@ -392,23 +352,18 @@ static NOINLINE char *xmalloc_optname_op
 			 */
 			option++;
 			len--;
+			if (option[-1] == 1) {
+				/* use common IPv4 logic to process IP addrs */
+				type = OPTION_IP;
+				optlen = 4;
+				continue;
+			}
 			if (option[-1] == 0) {
 				dest = dname_dec(option, len, ret);
 				if (dest) {
 					free(ret);
 					return dest;
 				}
-			} else
-			if (option[-1] == 1) {
-				const char *pfx = "";
-				while (1) {
-					len -= 4;
-					if (len < 0)
-						break;
-					dest += sprint_nip(dest, pfx, option);
-					pfx = " ";
-					option += 4;
-				}
 			}
 			return ret;
 #endif
@@ -449,15 +404,16 @@ static char **fill_envp(struct dhcp_pack
 
 	memset(found_opts, 0, sizeof(found_opts));
 
-	/* We need 6 elements for:
+	/* We need 7 elements for:
 	 * "interface=IFACE"
 	 * "ip=N.N.N.N" from packet->yiaddr
+	 * "giaddr=IP" from packet->gateway_nip (unless 0)
 	 * "siaddr=IP" from packet->siaddr_nip (unless 0)
 	 * "boot_file=FILE" from packet->file (unless overloaded)
 	 * "sname=SERVER_HOSTNAME" from packet->sname (unless overloaded)
 	 * terminating NULL
 	 */
-	envc = 6;
+	envc = 7;
 	/* +1 element for each option, +2 for subnet option: */
 	if (packet) {
 		/* note: do not search for "pad" (0) and "end" (255) options */
@@ -493,9 +449,7 @@ static char **fill_envp(struct dhcp_pack
 	 * uint16_t flags;  // only one flag so far: bcast. Never set by server
 	 * uint32_t ciaddr; // client IP (usually == yiaddr. can it be different
 	 *                  // if during renew server wants to give us different IP?)
-	 * uint32_t gateway_nip; // relay agent IP address
 	 * uint8_t chaddr[16]; // link-layer client hardware address (MAC)
-	 * TODO: export gateway_nip as $giaddr?
 	 */
 	/* Most important one: yiaddr as $ip */
 	*curr = xmalloc(sizeof("ip=255.255.255.255"));
@@ -507,6 +461,12 @@ static char **fill_envp(struct dhcp_pack
 		sprint_nip(*curr, "siaddr=", (uint8_t *) &packet->siaddr_nip);
 		putenv(*curr++);
 	}
+	if (packet->gateway_nip) {
+		/* IP address of DHCP relay agent */
+		*curr = xmalloc(sizeof("giaddr=255.255.255.255"));
+		sprint_nip(*curr, "giaddr=", (uint8_t *) &packet->gateway_nip);
+		putenv(*curr++);
+	}
 	if (!(overload & FILE_FIELD) && packet->file[0]) {
 		/* watch out for invalid packets */
 		*curr = xasprintf("boot_file=%."DHCP_PKT_FILE_LEN_STR"s", packet->file);
@@ -601,7 +561,7 @@ static ALWAYS_INLINE uint32_t random_xid
 /* Initialize the packet with the proper defaults */
 static void init_packet(struct dhcp_packet *packet, char type)
 {
-	uint16_t secs;
+	unsigned secs;
 
 	/* Fill in: op, htype, hlen, cookie fields; message type option: */
 	udhcp_init_header(packet, type);
@@ -612,7 +572,7 @@ static void init_packet(struct dhcp_pack
 	if (client_data.first_secs == 0)
 		client_data.first_secs = client_data.last_secs;
 	secs = client_data.last_secs - client_data.first_secs;
-	packet->secs = htons(secs);
+	packet->secs = (secs < 0xffff) ? htons(secs) : 0xffff;
 
 	memcpy(packet->chaddr, client_data.client_mac, 6);
 	if (client_data.clientid)
@@ -901,7 +861,7 @@ static NOINLINE int udhcp_recv_raw_packe
 		if (bytes < 0) {
 			if (errno == EINTR)
 				continue;
-			log1("packet read error, ignoring");
+			log1s("packet read error, ignoring");
 			/* NB: possible down interface, etc. Caller should pause. */
 			return bytes; /* returns -1 */
 		}
@@ -909,13 +869,13 @@ static NOINLINE int udhcp_recv_raw_packe
 	}
 
 	if (bytes < (int) (sizeof(packet.ip) + sizeof(packet.udp))) {
-		log1("packet is too short, ignoring");
+		log1s("packet is too short, ignoring");
 		return -2;
 	}
 
 	if (bytes < ntohs(packet.ip.tot_len)) {
 		/* packet is bigger than sizeof(packet), we did partial read */
-		log1("oversized packet, ignoring");
+		log1s("oversized packet, ignoring");
 		return -2;
 	}
 
@@ -930,7 +890,7 @@ static NOINLINE int udhcp_recv_raw_packe
 	/* || bytes > (int) sizeof(packet) - can't happen */
 	 || ntohs(packet.udp.len) != (uint16_t)(bytes - sizeof(packet.ip))
 	) {
-		log1("unrelated/bogus packet, ignoring");
+		log1s("unrelated/bogus packet, ignoring");
 		return -2;
 	}
 
@@ -938,7 +898,7 @@ static NOINLINE int udhcp_recv_raw_packe
 	check = packet.ip.check;
 	packet.ip.check = 0;
 	if (check != inet_cksum((uint16_t *)&packet.ip, sizeof(packet.ip))) {
-		log1("bad IP header checksum, ignoring");
+		log1s("bad IP header checksum, ignoring");
 		return -2;
 	}
 
@@ -963,13 +923,13 @@ static NOINLINE int udhcp_recv_raw_packe
 	check = packet.udp.check;
 	packet.udp.check = 0;
 	if (check && check != inet_cksum((uint16_t *)&packet, bytes)) {
-		log1("packet with bad UDP checksum received, ignoring");
+		log1s("packet with bad UDP checksum received, ignoring");
 		return -2;
 	}
  skip_udp_sum_check:
 
 	if (packet.data.cookie != htonl(DHCP_MAGIC)) {
-		bb_info_msg("packet with bad magic, ignoring");
+		bb_simple_info_msg("packet with bad magic, ignoring");
 		return -2;
 	}
 
@@ -1084,10 +1044,10 @@ static int udhcp_raw_socket(int ifindex)
 
 	if (setsockopt_1(fd, SOL_PACKET, PACKET_AUXDATA) != 0) {
 		if (errno != ENOPROTOOPT)
-			log1("can't set PACKET_AUXDATA on raw socket");
+			log1s("can't set PACKET_AUXDATA on raw socket");
 	}
 
-	log1("created raw socket");
+	log1s("created raw socket");
 
 	return fd;
 }
@@ -1115,7 +1075,7 @@ static void change_listen_mode(int new_m
 /* Called only on SIGUSR1 */
 static void perform_renew(void)
 {
-	bb_info_msg("performing DHCP renew");
+	bb_simple_info_msg("performing DHCP renew");
 	switch (client_data.state) {
 	case BOUND:
 		change_listen_mode(LISTEN_KERNEL);
@@ -1153,7 +1113,7 @@ static void perform_release(uint32_t ser
 				inet_ntoa(temp_addr), buffer);
 		send_release(server_addr, requested_ip); /* unicast */
 	}
-	bb_info_msg("entering released state");
+	bb_simple_info_msg("entering released state");
 /*
  * We can be here on: SIGUSR2,
  * or on exit (SIGTERM) and -R "release on quit" is specified.
@@ -1298,7 +1258,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 	);
 	if (opt & (OPT_h|OPT_H)) {
 		//msg added 2011-11
-		bb_error_msg("option -h NAME is deprecated, use -x hostname:NAME");
+		bb_simple_error_msg("option -h NAME is deprecated, use -x hostname:NAME");
 		client_data.hostname = alloc_dhcp_option(DHCP_HOST_NAME, str_h, 0);
 	}
 	if (opt & OPT_F) {
@@ -1392,7 +1352,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 	/* Create pidfile */
 	write_pidfile(client_data.pidfile);
 	/* Goes to stdout (unless NOMMU) and possibly syslog */
-	bb_info_msg("started, v"BB_VER);
+	bb_simple_info_msg("started, v"BB_VER);
 	/* We want random_xid to be random... */
 	srand(monotonic_us());
 
@@ -1439,7 +1399,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 					continue;
 				}
 				/* Else: an error occurred, panic! */
-				bb_perror_msg_and_die("poll");
+				bb_simple_perror_msg_and_die("poll");
 			}
 		}
 
@@ -1480,7 +1440,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 				udhcp_run_script(NULL, "leasefail");
 #if BB_MMU /* -b is not supported on NOMMU */
 				if (opt & OPT_b) { /* background if no lease */
-					bb_info_msg("no lease, forking to background");
+					bb_simple_info_msg("no lease, forking to background");
 					client_background();
 					/* do not background again! */
 					opt = ((opt & ~(OPT_b|OPT_n)) | OPT_f);
@@ -1493,7 +1453,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 				} else
 #endif
 				if (opt & OPT_n) { /* abort if no lease */
-					bb_info_msg("no lease, failing");
+					bb_simple_info_msg("no lease, failing");
 					retval = 1;
 					goto ret;
 				}
@@ -1521,7 +1481,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 				client_data.state = RENEWING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
 				change_listen_mode(LISTEN_KERNEL);
-				log1("entering renew state");
+				log1s("entering renew state");
 				/* fall right through */
 			case RENEW_REQUESTED: /* manual (SIGUSR1) renew */
 			case_RENEW_REQUESTED:
@@ -1554,7 +1514,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 					 */
 				}
 				/* Timed out or error, enter rebinding state */
-				log1("entering rebinding state");
+				log1s("entering rebinding state");
 				client_data.state = REBINDING;
 				/* fall right through */
 			case REBINDING:
@@ -1569,7 +1529,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 					continue;
 				}
 				/* Timed out, enter init state */
-				bb_info_msg("lease lost, entering init state");
+				bb_simple_info_msg("lease lost, entering init state");
 				udhcp_run_script(NULL, "deconfig");
 				client_data.state = INIT_SELECTING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
@@ -1655,13 +1615,13 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 		 || memcmp(packet.chaddr, client_data.client_mac, 6) != 0
 		) {
 //FIXME: need to also check that last 10 bytes are zero
-			log1("chaddr does not match, ignoring packet"); // log2?
+			log1("chaddr does not match%s", ", ignoring packet"); // log2?
 			continue;
 		}
 
 		message = udhcp_get_option(&packet, DHCP_MESSAGE_TYPE);
 		if (message == NULL) {
-			bb_info_msg("no message type option, ignoring packet");
+			bb_info_msg("no message type option%s", ", ignoring packet");
 			continue;
 		}
 
@@ -1698,7 +1658,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 				server_addr = 0;
 				temp = udhcp_get_option32(&packet, DHCP_SERVER_ID);
 				if (!temp) {
-					bb_info_msg("no server ID, using 0.0.0.0");
+					bb_simple_info_msg("no server ID, using 0.0.0.0");
 				} else {
 					/* it IS unaligned sometimes, don't "optimize" */
 					move_from_unaligned32(server_addr, temp);
@@ -1725,7 +1685,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 
 				temp = udhcp_get_option32(&packet, DHCP_LEASE_TIME);
 				if (!temp) {
-					bb_info_msg("no lease time with ACK, using 1 hour lease");
+					bb_simple_info_msg("no lease time with ACK, using 1 hour lease");
 					lease_seconds = 60 * 60;
 				} else {
 					/* it IS unaligned sometimes, don't "optimize" */
@@ -1758,7 +1718,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 							client_data.interface,
 							arpping_ms)
 					) {
-						bb_info_msg("offered address is in use "
+						bb_simple_info_msg("offered address is in use "
 							"(got ARP reply), declining");
 						send_decline(/*xid,*/ server_addr, packet.yiaddr);
 
@@ -1822,7 +1782,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 					if (!temp) {
  non_matching_svid:
 						log1("received DHCP NAK with wrong"
-							" server ID, ignoring packet");
+							" server ID%s", ", ignoring packet");
 						continue;
 					}
 					move_from_unaligned32(svid, temp);
diff -urpN busybox-1.31.1/networking/udhcp/dhcpc.h busybox-1.32.0/networking/udhcp/dhcpc.h
--- busybox-1.31.1/networking/udhcp/dhcpc.h	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/udhcp/dhcpc.h	2020-06-26 22:47:44.000000000 +0400
@@ -22,8 +22,8 @@ struct client_data_t {
 	uint8_t *hostname;              /* Optional hostname to use */
 	uint8_t *fqdn;                  /* Optional fully qualified domain name to use */
 
-	uint16_t first_secs;
-	uint16_t last_secs;
+	unsigned first_secs;
+	unsigned last_secs;
 
 	int sockfd;
 	smallint listen_mode;
diff -urpN busybox-1.31.1/networking/udhcp/dhcpd.c busybox-1.32.0/networking/udhcp/dhcpd.c
--- busybox-1.31.1/networking/udhcp/dhcpd.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/udhcp/dhcpd.c	2020-06-26 22:47:44.000000000 +0400
@@ -192,6 +192,8 @@ static struct dyn_lease *add_lease(
 			 * but merely make dumpleases output safe for shells to use.
 			 * We accept "0-9A-Za-z._-", all other chars turn to dots.
 			 */
+			if (*p == '-')
+				*p = '.'; /* defeat "-option" attacks too */
 			while (*p) {
 				if (!isalnum(*p) && *p != '-' && *p != '_')
 					*p = '.';
@@ -582,11 +584,11 @@ static void send_packet_to_client(struct
 	 || (dhcp_pkt->flags & htons(BROADCAST_FLAG))
 	 || dhcp_pkt->ciaddr == 0
 	) {
-		log1("broadcasting packet to client");
+		log1s("broadcasting packet to client");
 		ciaddr = INADDR_BROADCAST;
 		chaddr = MAC_BCAST_ADDR;
 	} else {
-		log1("unicasting packet to client ciaddr");
+		log1s("unicasting packet to client ciaddr");
 		ciaddr = dhcp_pkt->ciaddr;
 		chaddr = dhcp_pkt->chaddr;
 	}
@@ -600,7 +602,7 @@ static void send_packet_to_client(struct
 /* Send a packet to gateway_nip using the kernel ip stack */
 static void send_packet_to_relay(struct dhcp_packet *dhcp_pkt)
 {
-	log1("forwarding packet to relay");
+	log1s("forwarding packet to relay");
 
 	udhcp_send_kernel_packet(dhcp_pkt,
 			server_data.server_nip, SERVER_PORT,
@@ -754,7 +756,7 @@ static NOINLINE void send_offer(struct d
 		}
 
 		if (!packet.yiaddr) {
-			bb_error_msg("no free IP addresses. OFFER abandoned");
+			bb_simple_error_msg("no free IP addresses. OFFER abandoned");
 			return;
 		}
 		/* Reserve the IP for a short time hoping to get DHCPREQUEST soon */
@@ -765,7 +767,7 @@ static NOINLINE void send_offer(struct d
 				p_host_name ? (unsigned char)p_host_name[OPT_LEN - OPT_DATA] : 0
 		);
 		if (!lease) {
-			bb_error_msg("no free IP addresses. OFFER abandoned");
+			bb_simple_error_msg("no free IP addresses. OFFER abandoned");
 			return;
 		}
 	}
@@ -914,7 +916,7 @@ int udhcpd_main(int argc UNUSED_PARAM, c
 	write_pidfile(server_data.pidfile);
 	/* if (!..) bb_perror_msg("can't create pidfile %s", pidfile); */
 
-	bb_info_msg("started, v"BB_VER);
+	bb_simple_info_msg("started, v"BB_VER);
 
 	option = udhcp_find_option(server_data.options, DHCP_LEASE_TIME);
 	server_data.max_lease_sec = DEFAULT_LEASE_TIME;
@@ -985,7 +987,7 @@ int udhcpd_main(int argc UNUSED_PARAM, c
 			if (errno == EINTR)
 				goto new_tv;
 			/* < 0 and not EINTR: should not happen */
-			bb_perror_msg_and_die("poll");
+			bb_simple_perror_msg_and_die("poll");
 		}
 
 		if (pfds[0].revents) switch (udhcp_sp_read()) {
@@ -1019,16 +1021,16 @@ int udhcpd_main(int argc UNUSED_PARAM, c
 			continue;
 		}
 		if (packet.hlen != 6) {
-			bb_info_msg("MAC length != 6, ignoring packet");
+			bb_info_msg("MAC length != 6%s", ", ignoring packet");
 			continue;
 		}
 		if (packet.op != BOOTREQUEST) {
-			bb_info_msg("not a REQUEST, ignoring packet");
+			bb_info_msg("not a REQUEST%s", ", ignoring packet");
 			continue;
 		}
 		state = udhcp_get_option(&packet, DHCP_MESSAGE_TYPE);
 		if (state == NULL || state[0] < DHCP_MINTYPE || state[0] > DHCP_MAXTYPE) {
-			bb_info_msg("no or bad message type option, ignoring packet");
+			bb_info_msg("no or bad message type option%s", ", ignoring packet");
 			continue;
 		}
 
@@ -1039,7 +1041,7 @@ int udhcpd_main(int argc UNUSED_PARAM, c
 			move_from_unaligned32(server_id_network_order, server_id_opt);
 			if (server_id_network_order != server_data.server_nip) {
 				/* client talks to somebody else */
-				log1("server ID doesn't match, ignoring");
+				log1("server ID doesn't match%s", ", ignoring");
 				continue;
 			}
 		}
@@ -1162,7 +1164,7 @@ o DHCPREQUEST generated during REBINDING
 			if (!requested_ip_opt) {
 				requested_nip = packet.ciaddr;
 				if (requested_nip == 0) {
-					log1("no requested IP and no ciaddr, ignoring");
+					log1("no requested IP and no ciaddr%s", ", ignoring");
 					break;
 				}
 			}
diff -urpN busybox-1.31.1/networking/udhcp/dhcprelay.c busybox-1.32.0/networking/udhcp/dhcprelay.c
--- busybox-1.31.1/networking/udhcp/dhcprelay.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/udhcp/dhcprelay.c	2020-06-26 22:47:44.000000000 +0400
@@ -186,7 +186,7 @@ static int sendto_ip4(int sock, const vo
 	err = sendto(sock, msg, msg_len, 0, (struct sockaddr*) to, sizeof(*to));
 	err -= msg_len;
 	if (err)
-		bb_perror_msg("sendto");
+		bb_simple_perror_msg("sendto");
 	return err;
 }
 
@@ -273,7 +273,7 @@ int dhcprelay_main(int argc UNUSED_PARAM
 		bb_show_usage();
 	if (argv[3]) {
 		if (!inet_aton(argv[3], &server_addr.sin_addr))
-			bb_perror_msg_and_die("bad server IP");
+			bb_simple_perror_msg_and_die("bad server IP");
 	}
 
 	iface_list = make_iface_list(argv + 1, &num_sockets);
diff -urpN busybox-1.31.1/networking/udhcp/domain_codec.c busybox-1.32.0/networking/udhcp/domain_codec.c
--- busybox-1.31.1/networking/udhcp/domain_codec.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/udhcp/domain_codec.c	2020-06-26 22:47:44.000000000 +0400
@@ -109,11 +109,11 @@ char* FAST_FUNC dname_dec(const uint8_t
 	return ret;
 }
 
-/* Convert a domain name (src) from human-readable "foo.blah.com" format into
+/* Convert a domain name (src) from human-readable "foo.BLAH.com" format into
  * RFC1035 encoding "\003foo\004blah\003com\000". Return allocated string, or
  * NULL if an error occurs.
  */
-static uint8_t *convert_dname(const char *src)
+static uint8_t *convert_dname(const char *src, int *retlen)
 {
 	uint8_t c, *res, *lenptr, *dst;
 	int len;
@@ -129,6 +129,7 @@ static uint8_t *convert_dname(const char
 			/* label too long, too short, or two '.'s in a row? abort */
 			if (len > NS_MAXLABEL || len == 0 || (c == '.' && *src == '.')) {
 				free(res);
+				*retlen = 0;
 				return NULL;
 			}
 			*lenptr = len;
@@ -144,13 +145,16 @@ static uint8_t *convert_dname(const char
 
 	if (dst - res >= NS_MAXCDNAME) {  /* dname too long? abort */
 		free(res);
+		*retlen = 0;
 		return NULL;
 	}
 
-	*dst = 0;
+	*dst++ = 0;
+	*retlen = dst - res;
 	return res;
 }
 
+#if 0 //UNUSED
 /* Returns the offset within cstr at which dname can be found, or -1 */
 static int find_offset(const uint8_t *cstr, int clen, const uint8_t *dname)
 {
@@ -188,28 +192,27 @@ static int find_offset(const uint8_t *cs
 
 	return -1;
 }
+#endif
 
+uint8_t* FAST_FUNC dname_enc(/*const uint8_t *cstr, int clen,*/ const char *src, int *retlen)
+{
+#if 0 //UNUSED, was intended for long, repetitive DHCP_DOMAIN_SEARCH options?
+	uint8_t *d, *dname;
 /* Computes string to be appended to cstr so that src would be added to
  * the compression (best case, it's a 2-byte pointer to some offset within
  * cstr; worst case, it's all of src, converted to <4>host<3>com<0> format).
  * The computed string is returned directly; its length is returned via retlen;
  * NULL and 0, respectively, are returned if an error occurs.
  */
-uint8_t* FAST_FUNC dname_enc(const uint8_t *cstr, int clen, const char *src, int *retlen)
-{
-	uint8_t *d, *dname;
-	int off;
-
-	dname = convert_dname(src);
+	dname = convert_dname(src, retlen);
 	if (dname == NULL) {
-		*retlen = 0;
 		return NULL;
 	}
 
 	d = dname;
 	while (*d) {
 		if (cstr) {
-			off = find_offset(cstr, clen, d);
+			int off = find_offset(cstr, clen, d);
 			if (off >= 0) {	/* found a match, add pointer and return */
 				*d++ = NS_CMPRSFLGS | (off >> 8);
 				*d = off;
@@ -221,6 +224,8 @@ uint8_t* FAST_FUNC dname_enc(const uint8
 
 	*retlen = d - dname + 1;
 	return dname;
+#endif
+	return convert_dname(src, retlen);
 }
 
 #ifdef DNS_COMPR_TESTING
diff -urpN busybox-1.31.1/networking/udhcp/packet.c busybox-1.32.0/networking/udhcp/packet.c
--- busybox-1.31.1/networking/udhcp/packet.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/udhcp/packet.c	2020-06-26 22:47:44.000000000 +0400
@@ -85,14 +85,14 @@ int FAST_FUNC udhcp_recv_kernel_packet(s
 	memset(packet, 0, sizeof(*packet));
 	bytes = safe_read(fd, packet, sizeof(*packet));
 	if (bytes < 0) {
-		log1("packet read error, ignoring");
+		log1s("packet read error, ignoring");
 		return bytes; /* returns -1 */
 	}
 
 	if (bytes < offsetof(struct dhcp_packet, options)
 	 || packet->cookie != htonl(DHCP_MAGIC)
 	) {
-		bb_info_msg("packet with bad magic, ignoring");
+		bb_simple_info_msg("packet with bad magic, ignoring");
 		return -2;
 	}
 	log1("received %s", "a packet");
diff -urpN busybox-1.31.1/networking/udhcp/signalpipe.c busybox-1.32.0/networking/udhcp/signalpipe.c
--- busybox-1.31.1/networking/udhcp/signalpipe.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/udhcp/signalpipe.c	2020-06-26 22:47:44.000000000 +0400
@@ -28,7 +28,7 @@ static void signal_handler(int sig)
 	int sv = errno;
 	unsigned char ch = sig; /* use char, avoid dealing with partial writes */
 	if (write(WRITE_FD, &ch, 1) != 1)
-		bb_perror_msg("can't send signal");
+		bb_simple_perror_msg("can't send signal");
 	errno = sv;
 }
 
diff -urpN busybox-1.31.1/networking/udhcp/socket.c busybox-1.32.0/networking/udhcp/socket.c
--- busybox-1.31.1/networking/udhcp/socket.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/udhcp/socket.c	2020-06-26 22:47:44.000000000 +0400
@@ -87,7 +87,7 @@ int FAST_FUNC udhcp_listen_socket(/*uint
 
 	setsockopt_reuseaddr(fd);
 	if (setsockopt_broadcast(fd) == -1)
-		bb_perror_msg_and_die("SO_BROADCAST");
+		bb_simple_perror_msg_and_die("SO_BROADCAST");
 
 	/* SO_BINDTODEVICE doesn't work on ethernet aliases (ethN:M) */
 	colon = strrchr(inf, ':');
diff -urpN busybox-1.31.1/networking/wget.c busybox-1.32.0/networking/wget.c
--- busybox-1.31.1/networking/wget.c	2019-10-21 18:54:40.000000000 +0400
+++ busybox-1.32.0/networking/wget.c	2020-06-26 22:47:44.000000000 +0400
@@ -91,6 +91,9 @@
 //config:	patches, but do want to waste bandwidth expaining how wrong
 //config:	it is, you will be ignored.
 //config:
+//config:	FEATURE_WGET_OPENSSL does implement TLS verification
+//config:	using the certificates available to OpenSSL.
+//config:
 //config:config FEATURE_WGET_OPENSSL
 //config:	bool "Try to connect to HTTPS using openssl"
 //config:	default y
@@ -115,6 +118,9 @@
 //config:	If openssl can't be executed, internal TLS code will be used
 //config:	(if you enabled it); if openssl can be executed but fails later,
 //config:	wget can't detect this, and download will fail.
+//config:
+//config:	By default TLS verification is performed, unless
+//config:	--no-check-certificate option is passed.
 
 //applet:IF_WGET(APPLET(wget, BB_DIR_USR_BIN, BB_SUID_DROP))
 
@@ -124,8 +130,11 @@
 //usage:	IF_FEATURE_WGET_LONG_OPTIONS(
 //usage:       "[-c|--continue] [--spider] [-q|--quiet] [-O|--output-document FILE]\n"
 //usage:       "	[-o|--output-file FILE] [--header 'header: value'] [-Y|--proxy on/off]\n"
+//usage:	IF_FEATURE_WGET_OPENSSL(
+//usage:       "	[--no-check-certificate]\n"
+//usage:	)
 /* Since we ignore these opts, we don't show them in --help */
-/* //usage:    "	[--no-check-certificate] [--no-cache] [--passive-ftp] [-t TRIES]" */
+/* //usage:    "	[--no-cache] [--passive-ftp] [-t TRIES]" */
 /* //usage:    "	[-nv] [-nc] [-nH] [-np]" */
 //usage:       "	[-P DIR] [-S|--server-response] [-U|--user-agent AGENT]" IF_FEATURE_WGET_TIMEOUT(" [-T SEC]") " URL..."
 //usage:	)
@@ -137,7 +146,9 @@
 //usage:       "Retrieve files via HTTP or FTP\n"
 //usage:	IF_FEATURE_WGET_LONG_OPTIONS(
 //usage:     "\n	--spider	Only check URL existence: $? is 0 if exists"
-///////:     "\n	--no-check-certificate	Don't validate the server's certificate"
+//usage:	IF_FEATURE_WGET_OPENSSL(
+//usage:     "\n	--no-check-certificate	Don't validate the server's certificate"
+//usage:	)
 //usage:	)
 //usage:     "\n	-c		Continue retrieval of aborted transfer"
 //usage:     "\n	-q		Quiet"
@@ -368,7 +379,7 @@ static void alarm_handler(int sig UNUSED
 {
 	/* This is theoretically unsafe (uses stdio and malloc in signal handler) */
 	if (G.die_if_timed_out)
-		bb_error_msg_and_die("download timed out");
+		bb_simple_error_msg_and_die("download timed out");
 }
 static void set_alarm(void)
 {
@@ -452,7 +463,7 @@ static char fgets_trim_sanitize(FILE *fp
 
 	set_alarm();
 	if (fgets(G.wget_buf, sizeof(G.wget_buf), fp) == NULL)
-		bb_perror_msg_and_die("error getting response");
+		bb_simple_perror_msg_and_die("error getting response");
 	clear_alarm();
 
 	buf_ptr = strchrnul(G.wget_buf, '\n');
@@ -633,7 +644,7 @@ static char *get_sanitized_hdr(FILE *fp)
 
 static void reset_beg_range_to_zero(void)
 {
-	bb_error_msg("restart failed");
+	bb_simple_error_msg("restart failed");
 	G.beg_range = 0;
 	xlseek(G.output_fd, 0, SEEK_SET);
 	/* Done at the end instead: */
@@ -651,7 +662,7 @@ static int spawn_https_helper_openssl(co
 
 	if (socketpair(AF_UNIX, SOCK_STREAM, 0, sp) != 0)
 		/* Kernel can have AF_UNIX support disabled */
-		bb_perror_msg_and_die("socketpair");
+		bb_simple_perror_msg_and_die("socketpair");
 
 	if (!strchr(host, ':'))
 		host = allocated = xasprintf("%s:%u", host, port);
@@ -662,7 +673,7 @@ static int spawn_https_helper_openssl(co
 	pid = xvfork();
 	if (pid == 0) {
 		/* Child */
-		char *argv[8];
+		char *argv[9];
 
 		close(sp[0]);
 		xmove_fd(sp[1], 0);
@@ -689,6 +700,9 @@ static int spawn_https_helper_openssl(co
 			argv[5] = (char*)"-servername";
 			argv[6] = (char*)servername;
 		}
+		if (!(option_mask32 & WGET_OPT_NO_CHECK_CERT)) {
+			argv[7] = (char*)"-verify_return_error";
+		}
 
 		BB_EXECVP(argv[0], argv);
 		xmove_fd(3, 2);
@@ -724,7 +738,7 @@ static void spawn_ssl_client(const char
 
 	if (!(option_mask32 & WGET_OPT_NO_CHECK_CERT)) {
 		option_mask32 |= WGET_OPT_NO_CHECK_CERT;
-		bb_error_msg("note: TLS certificate validation not implemented");
+		bb_simple_error_msg("note: TLS certificate validation not implemented");
 	}
 
 	servername = xstrdup(host);
@@ -733,7 +747,7 @@ static void spawn_ssl_client(const char
 
 	if (socketpair(AF_UNIX, SOCK_STREAM, 0, sp) != 0)
 		/* Kernel can have AF_UNIX support disabled */
-		bb_perror_msg_and_die("socketpair");
+		bb_simple_perror_msg_and_die("socketpair");
 
 	fflush_all();
 	pid = BB_MMU ? xfork() : xvfork();
@@ -785,7 +799,7 @@ static FILE* prepare_ftp_session(FILE **
 #endif
 
 	if (ftpcmd(NULL, NULL, sfp) != 220)
-		bb_error_msg_and_die("%s", G.wget_buf);
+		bb_simple_error_msg_and_die(G.wget_buf);
 		/* note: ftpcmd() sanitizes G.wget_buf, ok to print */
 
 	/* Split username:password pair */
@@ -948,7 +962,7 @@ static void NOINLINE retrieve_file_data(
 			if (errno != EAGAIN) {
 				if (ferror(dfp)) {
 					progress_meter(PROGRESS_END);
-					bb_perror_msg_and_die(bb_msg_read_error);
+					bb_simple_perror_msg_and_die(bb_msg_read_error);
 				}
 				break; /* EOF, not error */
 			}
@@ -961,7 +975,7 @@ static void NOINLINE retrieve_file_data(
 # if ENABLE_FEATURE_WGET_TIMEOUT
 				if (second_cnt != 0 && --second_cnt == 0) {
 					progress_meter(PROGRESS_END);
-					bb_error_msg_and_die("download timed out");
+					bb_simple_error_msg_and_die("download timed out");
 				}
 # endif
 				/* We used to loop back to poll here,
@@ -1014,7 +1028,7 @@ static void NOINLINE retrieve_file_data(
 	G.got_clen = 1; /* makes it show 100% even for download of (formerly) unknown size */
 	progress_meter(PROGRESS_END);
 	if (G.content_len != 0) {
-		bb_perror_msg_and_die("connection closed prematurely");
+		bb_simple_perror_msg_and_die("connection closed prematurely");
 		/* GNU wget says "DATE TIME (NN MB/s) - Connection closed at byte NNN. Retrying." */
 	}
 
@@ -1348,7 +1362,7 @@ However, in real world it was observed t
 			}
 			if (key == KEY_location && status >= 300) {
 				if (--redir_limit == 0)
-					bb_error_msg_and_die("too many redirections");
+					bb_simple_error_msg_and_die("too many redirections");
 				fclose(sfp);
 				if (str[0] == '/') {
 					free(redirected_path);
diff -urpN busybox-1.31.1/networking/whois.c busybox-1.32.0/networking/whois.c
--- busybox-1.31.1/networking/whois.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/whois.c	2020-06-26 22:47:44.000000000 +0400
@@ -53,7 +53,9 @@ static char *query(const char *host, int
 	fp = xfdopen_for_read(fd);
 
 	success = 0;
-	while (fgets(linebuf, sizeof(linebuf)-1, fp)) {
+	while (bufpos < 32*1024 /* paranoia */
+	 && fgets(linebuf, sizeof(linebuf)-1, fp)
+	) {
 		unsigned len;
 
 		len = strcspn(linebuf, "\r\n");
diff -urpN busybox-1.31.1/networking/zcip.c busybox-1.32.0/networking/zcip.c
--- busybox-1.31.1/networking/zcip.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/networking/zcip.c	2020-06-26 22:47:44.000000000 +0400
@@ -276,7 +276,7 @@ int zcip_main(int argc UNUSED_PARAM, cha
 		if (inet_aton(l_opt, &net) == 0
 		 || (net.s_addr & htonl(IN_CLASSB_NET)) != net.s_addr
 		) {
-			bb_error_msg_and_die("invalid network address");
+			bb_simple_error_msg_and_die("invalid network address");
 		}
 		G.localnet_ip = ntohl(net.s_addr);
 	}
@@ -285,7 +285,7 @@ int zcip_main(int argc UNUSED_PARAM, cha
 		if (inet_aton(r_opt, &ip) == 0
 		 || (ntohl(ip.s_addr) & IN_CLASSB_NET) != G.localnet_ip
 		) {
-			bb_error_msg_and_die("invalid link address");
+			bb_simple_error_msg_and_die("invalid link address");
 		}
 		chosen_nip = ip.s_addr;
 	}
@@ -473,7 +473,7 @@ int zcip_main(int argc UNUSED_PARAM, cha
 
 		// Read ARP packet
 		if (safe_read(sock_fd, &p, sizeof(p)) < 0) {
-			bb_perror_msg_and_die(bb_msg_read_error);
+			bb_simple_perror_msg_and_die(bb_msg_read_error);
 		}
 
 		if (p.eth.ether_type != htons(ETHERTYPE_ARP))
diff -urpN busybox-1.31.1/printutils/lpr.c busybox-1.32.0/printutils/lpr.c
--- busybox-1.31.1/printutils/lpr.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/printutils/lpr.c	2020-06-26 22:47:44.000000000 +0400
@@ -167,7 +167,7 @@ int lpqr_main(int argc UNUSED_PARAM, cha
 	// LPR ------------------------
 	//
 	if (opts & LPR_V)
-		bb_error_msg("connected to server");
+		bb_simple_error_msg("connected to server");
 
 	job = getpid() % 1000;
 	hostname = safe_gethostname();
@@ -206,7 +206,7 @@ int lpqr_main(int argc UNUSED_PARAM, cha
 		 * Standard lpr works around it by refusing to send such jobs:
 		 */
 		if (st.st_size == 0) {
-			bb_error_msg("nothing to print");
+			bb_simple_error_msg("nothing to print");
 			continue;
 		}
 
@@ -246,7 +246,7 @@ int lpqr_main(int argc UNUSED_PARAM, cha
 
 		// send control file
 		if (opts & LPR_V)
-			bb_error_msg("sending control file");
+			bb_simple_error_msg("sending control file");
 		/* "Acknowledgement processing must occur as usual
 		 * after the command is sent." */
 		cflen = (unsigned)strlen(controlfile);
@@ -262,12 +262,12 @@ int lpqr_main(int argc UNUSED_PARAM, cha
 
 		// send data file, with name "dfaXXX"
 		if (opts & LPR_V)
-			bb_error_msg("sending data file");
+			bb_simple_error_msg("sending data file");
 		fdprintf(fd, "\x3" "%"OFF_FMT"u d%s\n", st.st_size, remote_filename);
 		get_response_or_say_and_die(fd, "sending data file");
 		if (bb_copyfd_size(dfd, fd, st.st_size) != st.st_size) {
 			// We're screwed. We sent less bytes than we advertised.
-			bb_error_msg_and_die("local file changed size?!");
+			bb_simple_error_msg_and_die("local file changed size?!");
 		}
 		write(fd, "", 1); // send ACK
 		get_response_or_say_and_die(fd, "sending data file");
@@ -283,7 +283,7 @@ int lpqr_main(int argc UNUSED_PARAM, cha
 
 		// say job accepted
 		if (opts & LPR_V)
-			bb_error_msg("job accepted");
+			bb_simple_error_msg("job accepted");
 
 		// next, please!
 		job = (job + 1) % 1000;
diff -urpN busybox-1.31.1/procps/free.c busybox-1.32.0/procps/free.c
--- busybox-1.31.1/procps/free.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/procps/free.c	2020-06-26 22:47:44.000000000 +0400
@@ -44,6 +44,7 @@ struct globals {
 #else
 # define G_unit_steps 10
 #endif
+	unsigned long cached_kb, available_kb, reclaimable_kb;
 };
 /* Because of NOFORK, "globals" are not in global data */
 
@@ -53,27 +54,30 @@ static unsigned long long scale(struct g
 }
 
 /* NOINLINE reduces main() stack usage, which makes code smaller (on x86 at least) */
-static NOINLINE unsigned int parse_meminfo(unsigned long *cached_kb, unsigned long *available_kb)
+static NOINLINE unsigned int parse_meminfo(struct globals *g)
 {
 	char buf[60]; /* actual lines we expect are ~30 chars or less */
 	FILE *fp;
-	int seen_cached_and_available;
+	int seen_cached_and_available_and_reclaimable;
 
 	fp = xfopen_for_read("/proc/meminfo");
-	*cached_kb = *available_kb = 0;
-	seen_cached_and_available = 2;
+	g->cached_kb = g->available_kb = g->reclaimable_kb = 0;
+	seen_cached_and_available_and_reclaimable = 3;
 	while (fgets(buf, sizeof(buf), fp)) {
-		if (sscanf(buf, "Cached: %lu %*s\n", cached_kb) == 1)
-			if (--seen_cached_and_available == 0)
+		if (sscanf(buf, "Cached: %lu %*s\n", &g->cached_kb) == 1)
+			if (--seen_cached_and_available_and_reclaimable == 0)
 				break;
-		if (sscanf(buf, "MemAvailable: %lu %*s\n", available_kb) == 1)
-			if (--seen_cached_and_available == 0)
+		if (sscanf(buf, "MemAvailable: %lu %*s\n", &g->available_kb) == 1)
+			if (--seen_cached_and_available_and_reclaimable == 0)
+				break;
+		if (sscanf(buf, "SReclaimable: %lu %*s\n", &g->reclaimable_kb) == 1)
+			if (--seen_cached_and_available_and_reclaimable == 0)
 				break;
 	}
 	/* Have to close because of NOFORK */
 	fclose(fp);
 
-	return seen_cached_and_available == 0;
+	return seen_cached_and_available_and_reclaimable == 0;
 }
 
 int free_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -82,7 +86,6 @@ int free_main(int argc UNUSED_PARAM, cha
 	struct globals G;
 	struct sysinfo info;
 	unsigned long long cached, cached_plus_free, available;
-	unsigned long cached_kb, available_kb;
 	int seen_available;
 
 #if ENABLE_DESKTOP
@@ -118,10 +121,11 @@ int free_main(int argc UNUSED_PARAM, cha
 	/* Kernels prior to 2.4.x will return info.mem_unit==0, so cope... */
 	G.mem_unit = (info.mem_unit ? info.mem_unit : 1);
 	/* Extract cached and memavailable from /proc/meminfo and convert to mem_units */
-	seen_available = parse_meminfo(&cached_kb, &available_kb);
-	available = ((unsigned long long) available_kb * 1024) / G.mem_unit;
-	cached = ((unsigned long long) cached_kb * 1024) / G.mem_unit;
+	seen_available = parse_meminfo(&G);
+	available = ((unsigned long long) G.available_kb * 1024) / G.mem_unit;
+	cached = ((unsigned long long) G.cached_kb * 1024) / G.mem_unit;
 	cached += info.bufferram;
+	cached += ((unsigned long long) G.reclaimable_kb * 1024) / G.mem_unit;
 	cached_plus_free = cached + info.freeram;
 
 #define FIELDS_6 "%12llu %11llu %11llu %11llu %11llu %11llu\n"
diff -urpN busybox-1.31.1/procps/kill.c busybox-1.32.0/procps/kill.c
--- busybox-1.31.1/procps/kill.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/procps/kill.c	2020-06-26 22:47:44.000000000 +0400
@@ -268,7 +268,7 @@ int kill_main(int argc UNUSED_PARAM, cha
 #if ENABLE_KILL || ENABLE_KILLALL
 	/* Pid or name is required for kill/killall */
 	if (!arg) {
-		bb_error_msg("you need to specify whom to kill");
+		bb_simple_error_msg("you need to specify whom to kill");
 		return EXIT_FAILURE;
 	}
 
diff -urpN busybox-1.31.1/procps/mpstat.c busybox-1.32.0/procps/mpstat.c
--- busybox-1.31.1/procps/mpstat.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/procps/mpstat.c	2020-06-26 22:47:44.000000000 +0400
@@ -931,7 +931,7 @@ int mpstat_main(int argc UNUSED_PARAM, c
 				/* Get CPU number */
 				unsigned n = xatoi_positive(t);
 				if (n >= G.cpu_nr)
-					bb_error_msg_and_die("not that many processors");
+					bb_simple_error_msg_and_die("not that many processors");
 				n++;
 				G.cpu_bitmap[n >> 3] |= 1 << (n & 7);
 			}
diff -urpN busybox-1.31.1/procps/nmeter.c busybox-1.32.0/procps/nmeter.c
--- busybox-1.31.1/procps/nmeter.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/procps/nmeter.c	2020-06-26 22:47:44.000000000 +0400
@@ -37,6 +37,7 @@
 //usage:     "\n %[pn]		# of processes"
 //usage:     "\n %b		Block io"
 //usage:     "\n %Nt		Time (with N decimal points)"
+//usage:     "\n %NT		Zero-based timestamp (with N decimal points)"
 //usage:     "\n %r		Print <cr> instead of <lf> at EOL"
 
 //TODO:
@@ -88,6 +89,7 @@ struct globals {
 	int delta;
 	unsigned deltanz;
 	struct timeval tv;
+	struct timeval start;
 #define first_proc_file proc_stat
 	proc_file proc_stat;	// Must match the order of proc_name's!
 	proc_file proc_loadavg;
@@ -101,7 +103,6 @@ struct globals {
 #define is26               (G.is26              )
 #define need_seconds       (G.need_seconds      )
 #define cur_outbuf         (G.cur_outbuf        )
-#define tv                 (G.tv                )
 #define proc_stat          (G.proc_stat         )
 #define proc_loadavg       (G.proc_loadavg      )
 #define proc_net_dev       (G.proc_net_dev      )
@@ -122,11 +123,6 @@ static inline void reset_outbuf(void)
 	cur_outbuf = outbuf;
 }
 
-static inline int outbuf_count(void)
-{
-	return cur_outbuf - outbuf;
-}
-
 static void print_outbuf(void)
 {
 	int sz = cur_outbuf - outbuf;
@@ -351,7 +347,7 @@ static s_stat* init_cr(const char *param
 enum { CPU_FIELDCNT = 7 };
 S_STAT(cpu_stat)
 	ullong old[CPU_FIELDCNT];
-	int bar_sz;
+	unsigned bar_sz;
 	char bar[1];
 S_STAT_END(cpu_stat)
 
@@ -360,8 +356,8 @@ static void FAST_FUNC collect_cpu(cpu_st
 	ullong data[CPU_FIELDCNT] = { 0, 0, 0, 0, 0, 0, 0 };
 	unsigned frac[CPU_FIELDCNT] = { 0, 0, 0, 0, 0, 0, 0 };
 	ullong all = 0;
-	int norm_all = 0;
-	int bar_sz = s->bar_sz;
+	unsigned norm_all = 0;
+	unsigned bar_sz = s->bar_sz;
 	char *bar = s->bar;
 	int i;
 
@@ -420,8 +416,8 @@ static s_stat* init_cpu(const char *para
 {
 	int sz;
 	cpu_stat *s;
-	sz = strtoul(param, NULL, 0); /* param can be "" */
-	if (sz < 10) sz = 10;
+	sz = param[0] ? strtoul(param, NULL, 0) : 10;
+	if (sz <= 0) sz = 1;
 	if (sz > 1000) sz = 1000;
 	s = xzalloc(sizeof(*s) + sz);
 	/*s->bar[sz] = '\0'; - xzalloc did it */
@@ -759,25 +755,53 @@ S_STAT(time_stat)
 	unsigned scale;
 S_STAT_END(time_stat)
 
-static void FAST_FUNC collect_time(time_stat *s)
+static void FAST_FUNC collect_tv(time_stat *s, struct timeval *tv, int local)
 {
 	char buf[sizeof("12:34:56.123456")];
 	struct tm* tm;
-	unsigned us = tv.tv_usec + s->scale/2;
-	time_t t = tv.tv_sec;
+	unsigned us = tv->tv_usec + s->scale/2;
+	time_t t = tv->tv_sec;
 
 	if (us >= 1000000) {
 		t++;
 		us -= 1000000;
 	}
-	tm = localtime(&t);
+	if (local)
+		tm = localtime(&t);
+	else
+		tm = gmtime(&t);
 
-	sprintf(buf, "%02d:%02d:%02d", tm->tm_hour, tm->tm_min, tm->tm_sec);
+	sprintf(buf, "%02u:%02u:%02u", tm->tm_hour, tm->tm_min, tm->tm_sec);
 	if (s->prec)
-		sprintf(buf+8, ".%0*d", s->prec, us / s->scale);
+		sprintf(buf+8, ".%0*u", s->prec, us / s->scale);
 	put(buf);
 }
 
+static void FAST_FUNC collect_time(time_stat *s)
+{
+	collect_tv(s, &G.tv, /*local:*/ 1);
+}
+
+static void FAST_FUNC collect_monotonic(time_stat *s)
+{
+	struct timeval tv_mono;
+
+	tv_mono.tv_sec = G.tv.tv_sec - G.start.tv_sec;
+#if 0 /* Do we want this? */
+	if (tv_mono.tv_sec < 0) {
+		/* Time went backwards, reset start time to "now" */
+		tv_mono.tv_sec = 0;
+		G.start = G.tv;
+	}
+#endif
+	tv_mono.tv_usec = G.tv.tv_usec - G.start.tv_usec;
+	if ((int32_t)tv_mono.tv_usec < 0) {
+		tv_mono.tv_usec += 1000000;
+		tv_mono.tv_sec--;
+	}
+	collect_tv(s, &tv_mono, /*local:*/ 0);
+}
+
 static s_stat* init_time(const char *param)
 {
 	int prec;
@@ -794,6 +818,13 @@ static s_stat* init_time(const char *par
 	return (s_stat*)s;
 }
 
+static s_stat* init_monotonic(const char *param)
+{
+	time_stat *s = (void*)init_time(param);
+	s->collect = collect_monotonic;
+	return (s_stat*)s;
+}
+
 static void FAST_FUNC collect_info(s_stat *s)
 {
 	gen ^= 1;
@@ -806,7 +837,7 @@ static void FAST_FUNC collect_info(s_sta
 
 typedef s_stat* init_func(const char *param);
 
-static const char options[] ALIGN1 = "ncmsfixptbr";
+static const char options[] ALIGN1 = "ncmsfixptTbr";
 static init_func *const init_functions[] = {
 	init_if,
 	init_cpu,
@@ -817,6 +848,7 @@ static init_func *const init_functions[]
 	init_ctx,
 	init_fork,
 	init_time,
+	init_monotonic,
 	init_blk,
 	init_cr
 };
@@ -918,13 +950,15 @@ int nmeter_main(int argc UNUSED_PARAM, c
 	// Generate first samples but do not print them, they're bogus
 	collect_info(first);
 	reset_outbuf();
+
 	if (G.delta >= 0) {
-		gettimeofday(&tv, NULL);
-		usleep(G.delta > 1000000 ? 1000000 : G.delta - tv.tv_usec % G.deltanz);
+		gettimeofday(&G.tv, NULL);
+		usleep(G.delta > 1000000 ? 1000000 : G.delta - G.tv.tv_usec % G.deltanz);
 	}
 
+	gettimeofday(&G.start, NULL);
+	G.tv = G.start;
 	while (1) {
-		gettimeofday(&tv, NULL);
 		collect_info(first);
 		put_c(G.final_char);
 		print_outbuf();
@@ -937,11 +971,11 @@ int nmeter_main(int argc UNUSED_PARAM, c
 		if (G.delta >= 0) {
 			int rem;
 			// can be commented out, will sacrifice sleep time precision a bit
-			gettimeofday(&tv, NULL);
+			gettimeofday(&G.tv, NULL);
 			if (need_seconds)
-				rem = G.delta - ((ullong)tv.tv_sec*1000000 + tv.tv_usec) % G.deltanz;
+				rem = G.delta - ((ullong)G.tv.tv_sec*1000000 + G.tv.tv_usec) % G.deltanz;
 			else
-				rem = G.delta - (unsigned)tv.tv_usec % G.deltanz;
+				rem = G.delta - (unsigned)G.tv.tv_usec % G.deltanz;
 			// Sometimes kernel wakes us up just a tiny bit earlier than asked
 			// Do not go to very short sleep in this case
 			if (rem < (unsigned)G.delta / 128) {
@@ -949,6 +983,7 @@ int nmeter_main(int argc UNUSED_PARAM, c
 			}
 			usleep(rem);
 		}
+		gettimeofday(&G.tv, NULL);
 	}
 
 	/*return 0;*/
diff -urpN busybox-1.31.1/procps/powertop.c busybox-1.32.0/procps/powertop.c
--- busybox-1.31.1/procps/powertop.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/procps/powertop.c	2020-06-26 22:47:44.000000000 +0400
@@ -657,7 +657,7 @@ static void show_timerstats(void)
 		}
 	} else {
 		bb_putchar('\n');
-		bb_error_msg("no stats available; run as root or"
+		bb_simple_error_msg("no stats available; run as root or"
 				" enable the timer_stats module");
 	}
 }
@@ -707,7 +707,7 @@ int powertop_main(int argc UNUSED_PARAM,
 
 	/* Print warning when we don't have superuser privileges */
 	if (geteuid() != 0)
-		bb_error_msg("run as root to collect enough information");
+		bb_simple_error_msg("run as root to collect enough information");
 
 	/* Get number of CPUs */
 	G.total_cpus = get_cpu_count();
diff -urpN busybox-1.31.1/procps/pstree.c busybox-1.32.0/procps/pstree.c
--- busybox-1.31.1/procps/pstree.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/procps/pstree.c	2020-06-26 22:47:44.000000000 +0400
@@ -404,7 +404,7 @@ int pstree_main(int argc UNUSED_PARAM, c
 	else {
 		dump_by_user(find_proc(1), uid);
 		if (!G.dumped) {
-			bb_error_msg_and_die("no processes found");
+			bb_simple_error_msg_and_die("no processes found");
 		}
 	}
 
diff -urpN busybox-1.31.1/procps/sysctl.c busybox-1.32.0/procps/sysctl.c
--- busybox-1.31.1/procps/sysctl.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/procps/sysctl.c	2020-06-26 22:47:44.000000000 +0400
@@ -169,13 +169,15 @@ static int sysctl_act_on_setting(char *s
 
 	if (fd < 0) {
 		switch (errno) {
-		case EACCES:
-			/* Happens for write-only settings, e.g. net.ipv6.route.flush */
-			goto end;
 		case ENOENT:
 			if (option_mask32 & FLAG_SHOW_KEY_ERRORS)
 				bb_error_msg("error: '%s' is an unknown key", outname);
 			break;
+		case EACCES:
+			/* Happens for write-only settings, e.g. net.ipv6.route.flush */
+			if (!writing)
+				goto end;
+			/* fall through */
 		default:
 			bb_perror_msg("error %sing key '%s'",
 					writing ?
@@ -236,6 +238,7 @@ static int sysctl_act_recursive(const ch
 	int retval = 0;
 
 	if (!(option_mask32 & FLAG_WRITE)
+	 && !strchr(path, '=')  /* do not try to resurse on "var=val" */
 	 && stat(path, &buf) == 0
 	 && S_ISDIR(buf.st_mode)
 	) {
diff -urpN busybox-1.31.1/procps/top.c busybox-1.32.0/procps/top.c
--- busybox-1.31.1/procps/top.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/procps/top.c	2020-06-26 22:47:44.000000000 +0400
@@ -979,6 +979,11 @@ static unsigned handle_input(unsigned sc
 		IF_FEATURE_TOPMEM(&& scan_mask != TOPMEM_MASK)
 		) {
 			scan_mask ^= PSSCAN_TASKS;
+#  if ENABLE_FEATURE_TOP_CPU_USAGE_PERCENTAGE
+			free(prev_hist);
+			prev_hist = NULL;
+			prev_hist_count = 0;
+#   endif
 			continue;
 		}
 # endif
@@ -1000,10 +1005,10 @@ static unsigned handle_input(unsigned sc
 #  if ENABLE_FEATURE_TOPMEM
 		if (c == 's') {
 			scan_mask = TOPMEM_MASK;
+			sort_field = (sort_field + 1) % NUM_SORT_FIELD;
 			free(prev_hist);
 			prev_hist = NULL;
 			prev_hist_count = 0;
-			sort_field = (sort_field + 1) % NUM_SORT_FIELD;
 			continue;
 		}
 #  endif
@@ -1229,7 +1234,7 @@ int top_main(int argc UNUSED_PARAM, char
 #endif
 		} /* end of "while we read /proc" */
 		if (ntop == 0) {
-			bb_error_msg("no process info in /proc");
+			bb_simple_error_msg("no process info in /proc");
 			break;
 		}
 
diff -urpN busybox-1.31.1/runit/chpst.c busybox-1.32.0/runit/chpst.c
--- busybox-1.31.1/runit/chpst.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/runit/chpst.c	2020-06-26 22:47:44.000000000 +0400
@@ -270,7 +270,7 @@ static void limit(int what, long l)
 	else
 		r.rlim_cur = l;
 	if (setrlimit(what, &r) == -1)
-		bb_perror_msg_and_die("setrlimit");
+		bb_simple_perror_msg_and_die("setrlimit");
 }
 
 int chpst_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -467,12 +467,12 @@ int chpst_main(int argc UNUSED_PARAM, ch
 	if (opt & OPT_n) {
 		errno = 0;
 		if (nice(xatoi(nicestr)) == -1)
-			bb_perror_msg_and_die("nice");
+			bb_simple_perror_msg_and_die("nice");
 	}
 
 	if (opt & OPT_u) {
 		if (setgroups(1, &ugid.gid) == -1)
-			bb_perror_msg_and_die("setgroups");
+			bb_simple_perror_msg_and_die("setgroups");
 		xsetgid(ugid.gid);
 		xsetuid(ugid.uid);
 	}
diff -urpN busybox-1.31.1/runit/runsv.c busybox-1.32.0/runit/runsv.c
--- busybox-1.31.1/runit/runsv.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/runit/runsv.c	2020-06-26 22:47:44.000000000 +0400
@@ -51,11 +51,9 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAG
 #if ENABLE_MONOTONIC_SYSCALL
 #include <sys/syscall.h>
 
-/* libc has incredibly messy way of doing this,
- * typically requiring -lrt. We just skip all this mess */
 static void gettimeofday_ns(struct timespec *ts)
 {
-	syscall(__NR_clock_gettime, CLOCK_REALTIME, ts);
+	clock_gettime(CLOCK_REALTIME, ts);
 }
 #else
 static void gettimeofday_ns(struct timespec *ts)
diff -urpN busybox-1.31.1/runit/svlogd.c busybox-1.32.0/runit/svlogd.c
--- busybox-1.31.1/runit/svlogd.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/runit/svlogd.c	2020-06-26 22:47:44.000000000 +0400
@@ -274,7 +274,7 @@ static void warnx(const char *m0, const
 }
 static void pause_nomem(void)
 {
-	bb_error_msg(PAUSE"out of memory");
+	bb_simple_error_msg(PAUSE"out of memory");
 	sleep(3);
 }
 static void pause1cannot(const char *m0)
diff -urpN busybox-1.31.1/scripts/Kbuild.include busybox-1.32.0/scripts/Kbuild.include
--- busybox-1.31.1/scripts/Kbuild.include	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/scripts/Kbuild.include	2020-06-26 22:47:44.000000000 +0400
@@ -4,6 +4,7 @@
 # Convinient variables
 comma   := ,
 squote  := '
+quote   := "
 empty   :=
 space   := $(empty) $(empty)
 
diff -urpN busybox-1.31.1/scripts/Makefile.IMA busybox-1.32.0/scripts/Makefile.IMA
--- busybox-1.31.1/scripts/Makefile.IMA	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/scripts/Makefile.IMA	2020-06-26 22:47:44.000000000 +0400
@@ -49,7 +49,6 @@ OBJCOPY         = $(CROSS_COMPILE)objcop
 OBJDUMP         = $(CROSS_COMPILE)objdump
 
 CFLAGS   := $(CFLAGS)
-CPPFLAGS += -D"KBUILD_STR(s)=\#s" #-Q
 
 # We need some generic definitions
 include $(srctree)/scripts/Kbuild.include
diff -urpN busybox-1.31.1/scripts/Makefile.lib busybox-1.32.0/scripts/Makefile.lib
--- busybox-1.31.1/scripts/Makefile.lib	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/scripts/Makefile.lib	2020-06-26 22:47:44.000000000 +0400
@@ -81,10 +81,10 @@ obj-dirs	:= $(addprefix $(obj)/,$(obj-di
 # Note: It's possible that one object gets potentially linked into more
 #       than one module. In that case KBUILD_MODNAME will be set to foo_bar,
 #       where foo and bar are the name of the modules.
-name-fix = $(subst $(comma),_,$(subst -,_,$1))
-basename_flags = -D"KBUILD_BASENAME=KBUILD_STR($(call name-fix,$(*F)))"
+name-fix = $(squote)$(quote)$(subst $(comma),_,$(subst -,_,$1))$(quote)$(squote)
+basename_flags = -DKBUILD_BASENAME=$(call name-fix,$(*F))
 modname_flags  = $(if $(filter 1,$(words $(modname))),\
-                 -D"KBUILD_MODNAME=KBUILD_STR($(call name-fix,$(modname)))")
+                 -DKBUILD_MODNAME=$(call name-fix,$(modname)))
 
 _c_flags       = $(CFLAGS) $(EXTRA_CFLAGS) $(CFLAGS_$(*F).o)
 _a_flags       = $(AFLAGS) $(EXTRA_AFLAGS) $(AFLAGS_$(*F).o)
@@ -110,7 +110,7 @@ endif
 
 c_flags        = -Wp,-MD,$(depfile) $(NOSTDINC_FLAGS) $(CPPFLAGS) \
 		 $(__c_flags) $(modkern_cflags) \
-		 -D"KBUILD_STR(s)=\#s" $(basename_flags) $(modname_flags)
+		 $(basename_flags) $(modname_flags)
 
 a_flags        = -Wp,-MD,$(depfile) $(NOSTDINC_FLAGS) $(CPPFLAGS) \
 		 $(__a_flags) $(modkern_aflags)
diff -urpN busybox-1.31.1/scripts/randomtest busybox-1.32.0/scripts/randomtest
--- busybox-1.31.1/scripts/randomtest	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/scripts/randomtest	2020-06-26 22:47:44.000000000 +0400
@@ -113,6 +113,31 @@ if test x"$LIBC" = x"uclibc"; then
 	echo 'CONFIG_ASH_INTERNAL_GLOB=y' >>.config
 fi
 
+# If musl
+if test x"$LIBC" = x"musl"; then
+	cat .config \
+	| grep -v CONFIG_STATIC \
+	| grep -v CONFIG_DEBUG_SANITIZE \
+	| grep -v CONFIG_LFS \
+	| grep -v CONFIG_EXTRA_COMPAT \
+	| grep -v CONFIG_FEATURE_2_4_MODULES \
+	| grep -v CONFIG_FEATURE_VI_REGEX_SEARCH \
+	| grep -v CONFIG_FEATURE_MOUNT_NFS \
+	| grep -v CONFIG_FEATURE_INETD_RPC \
+	>.config.new
+	mv .config.new .config
+	echo 'CONFIG_STATIC=y' >>.config
+	# "error: cannot specify -static with -fsanitize=address":
+	echo '# CONFIG_DEBUG_SANITIZE is not set' >>.config
+	# with LFS off, uoff_t will have wrong width:
+	echo 'CONFIG_LFS=y' >>.config
+	echo '# CONFIG_EXTRA_COMPAT is not set' >>.config
+	echo '# CONFIG_FEATURE_2_4_MODULES is not set' >>.config
+	echo '# CONFIG_FEATURE_VI_REGEX_SEARCH is not set' >>.config
+	echo '# CONFIG_FEATURE_MOUNT_NFS is not set' >>.config
+	echo '# CONFIG_FEATURE_INETD_RPC is not set' >>.config
+fi
+
 # If STATIC, remove some things.
 # PAM with static linking is probably pointless
 # (but I need to try - now I don't have libpam.a on my system, only libpam.so)
diff -urpN busybox-1.31.1/scripts/trylink busybox-1.32.0/scripts/trylink
--- busybox-1.31.1/scripts/trylink	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/scripts/trylink	2020-06-26 22:47:44.000000000 +0400
@@ -50,9 +50,6 @@ check_cc() {
     echo "int main(int argc,char**argv){return argv?argc:0;}" >"$tempname".c
     # Can use "-o /dev/null", but older gcc tend to *unlink it* on failure! :(
     # Was using "-xc /dev/null", but we need a valid C program.
-    # "eval" may be needed if CFLAGS can contain
-    # '... -D"BB_VER=KBUILD_STR(1.N.M)" ...'
-    # and we need shell to process quotes!
     $CC $CFLAGS $LDFLAGS $1 "$tempname".c -o "$tempname" >/dev/null 2>&1
     exitcode=$?
     rm -f "$tempname" "$tempname".c "$tempname".o
diff -urpN busybox-1.31.1/selinux/chcon.c busybox-1.32.0/selinux/chcon.c
--- busybox-1.31.1/selinux/chcon.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/selinux/chcon.c	2020-06-26 22:47:44.000000000 +0400
@@ -107,7 +107,7 @@ static int FAST_FUNC change_filedir_cont
 
 	context_string = context_str(context);
 	if (!context_string) {
-		bb_error_msg("can't obtain security context in text expression");
+		bb_simple_error_msg("can't obtain security context in text expression");
 		goto skip;
 	}
 
@@ -194,7 +194,7 @@ int chcon_main(int argc UNUSED_PARAM, ch
 		/* specified_context is never NULL -
 		 * "-1" in opt_complementary prevents this. */
 		if (!argv[0])
-			bb_error_msg_and_die("too few arguments");
+			bb_simple_error_msg_and_die("too few arguments");
 	}
 
 	for (i = 0; (fname = argv[i]) != NULL; i++) {
diff -urpN busybox-1.31.1/selinux/getenforce.c busybox-1.32.0/selinux/getenforce.c
--- busybox-1.31.1/selinux/getenforce.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/selinux/getenforce.c	2020-06-26 22:47:44.000000000 +0400
@@ -29,12 +29,12 @@ int getenforce_main(int argc UNUSED_PARA
 
 	rc = is_selinux_enabled();
 	if (rc < 0)
-		bb_error_msg_and_die("is_selinux_enabled() failed");
+		bb_simple_error_msg_and_die("is_selinux_enabled() failed");
 
 	if (rc == 1) {
 		rc = security_getenforce();
 		if (rc < 0)
-			bb_error_msg_and_die("getenforce() failed");
+			bb_simple_error_msg_and_die("getenforce() failed");
 
 		if (rc)
 			puts("Enforcing");
diff -urpN busybox-1.31.1/selinux/getsebool.c busybox-1.32.0/selinux/getsebool.c
--- busybox-1.31.1/selinux/getsebool.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/selinux/getsebool.c	2020-06-26 22:47:44.000000000 +0400
@@ -40,7 +40,7 @@ int getsebool_main(int argc, char **argv
 
 		rc = security_get_boolean_names(&names, &len);
 		if (rc)
-			bb_perror_msg_and_die("can't get boolean names");
+			bb_simple_perror_msg_and_die("can't get boolean names");
 
 		if (!len) {
 			puts("No booleans");
diff -urpN busybox-1.31.1/selinux/load_policy.c busybox-1.32.0/selinux/load_policy.c
--- busybox-1.31.1/selinux/load_policy.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/selinux/load_policy.c	2020-06-26 22:47:44.000000000 +0400
@@ -31,7 +31,7 @@ int load_policy_main(int argc UNUSED_PAR
 
 	rc = selinux_mkload_policy(1);
 	if (rc < 0) {
-		bb_perror_msg_and_die("can't load policy");
+		bb_simple_perror_msg_and_die("can't load policy");
 	}
 
 	return 0;
diff -urpN busybox-1.31.1/selinux/runcon.c busybox-1.32.0/selinux/runcon.c
--- busybox-1.31.1/selinux/runcon.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/selinux/runcon.c	2020-06-26 22:47:44.000000000 +0400
@@ -65,7 +65,7 @@ static context_t runcon_compute_new_cont
 	security_context_t cur_context;
 
 	if (getcon(&cur_context))
-		bb_error_msg_and_die("can't get current context");
+		bb_simple_error_msg_and_die("can't get current context");
 
 	if (compute_trans) {
 		security_context_t file_context, new_context;
@@ -75,7 +75,7 @@ static context_t runcon_compute_new_cont
 					command);
 		if (security_compute_create(cur_context, file_context,
 					SECCLASS_PROCESS, &new_context))
-			bb_error_msg_and_die("unable to compute a new context");
+			bb_simple_error_msg_and_die("unable to compute a new context");
 		cur_context = new_context;
 	}
 
@@ -137,7 +137,7 @@ int runcon_main(int argc UNUSED_PARAM, c
 	if (!(opts & OPTS_CONTEXT_COMPONENT)) {
 		context = *argv++;
 		if (!argv[0])
-			bb_error_msg_and_die("no command given");
+			bb_simple_error_msg_and_die("no command given");
 	}
 
 	if (context) {
diff -urpN busybox-1.31.1/selinux/sestatus.c busybox-1.32.0/selinux/sestatus.c
--- busybox-1.31.1/selinux/sestatus.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/selinux/sestatus.c	2020-06-26 22:47:44.000000000 +0400
@@ -216,5 +216,5 @@ int sestatus_main(int argc UNUSED_PARAM,
 	return 0;
 
   error:
-	bb_perror_msg_and_die("libselinux returns unknown state");
+	bb_simple_perror_msg_and_die("libselinux returns unknown state");
 }
diff -urpN busybox-1.31.1/selinux/setenforce.c busybox-1.32.0/selinux/setenforce.c
--- busybox-1.31.1/selinux/setenforce.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/selinux/setenforce.c	2020-06-26 22:47:44.000000000 +0400
@@ -49,7 +49,7 @@ int setenforce_main(int argc UNUSED_PARA
 			continue;
 		rc = security_setenforce(i & 1);
 		if (rc < 0)
-			bb_perror_msg_and_die("setenforce() failed");
+			bb_simple_perror_msg_and_die("setenforce() failed");
 		return 0;
 	}
 
diff -urpN busybox-1.31.1/selinux/setfiles.c busybox-1.32.0/selinux/setfiles.c
--- busybox-1.31.1/selinux/setfiles.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/selinux/setfiles.c	2020-06-26 22:47:44.000000000 +0400
@@ -182,7 +182,7 @@ static void inc_err(void)
 {
 	nerr++;
 	if (nerr > 9 && !FLAG_d_debug) {
-		bb_error_msg_and_die("exiting after 10 errors");
+		bb_simple_error_msg_and_die("exiting after 10 errors");
 	}
 }
 
diff -urpN busybox-1.31.1/selinux/setsebool.c busybox-1.32.0/selinux/setsebool.c
--- busybox-1.31.1/selinux/setsebool.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/selinux/setsebool.c	2020-06-26 22:47:44.000000000 +0400
@@ -46,7 +46,7 @@ int setsebool_main(int argc, char **argv
 	}
 
 	if (security_set_boolean(argv[1], value) < 0)
-		bb_error_msg_and_die("can't set boolean");
+		bb_simple_error_msg_and_die("can't set boolean");
 
 	return 0;
 }
diff -urpN busybox-1.31.1/shell/Config.src busybox-1.32.0/shell/Config.src
--- busybox-1.31.1/shell/Config.src	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/shell/Config.src	2020-06-26 22:47:44.000000000 +0400
@@ -17,6 +17,7 @@ choice
 config SH_IS_ASH
 	depends on !NOMMU
 	bool "ash"
+	select SHELL_ASH
 	help
 	Choose ash to be the shell executed by 'sh' name.
 	The ash code will be built into busybox. If you don't select
@@ -25,6 +26,7 @@ config SH_IS_ASH
 
 config SH_IS_HUSH
 	bool "hush"
+	select SHELL_HUSH
 	help
 	Choose hush to be the shell executed by 'sh' name.
 	The hush code will be built into busybox. If you don't select
@@ -57,6 +59,7 @@ choice
 config BASH_IS_ASH
 	depends on !NOMMU
 	bool "ash"
+	select SHELL_ASH
 	help
 	Choose ash to be the shell executed by 'bash' name.
 	The ash code will be built into busybox. If you don't select
@@ -65,6 +68,7 @@ config BASH_IS_ASH
 
 config BASH_IS_HUSH
 	bool "hush"
+	select SHELL_HUSH
 	help
 	Choose hush to be the shell executed by 'bash' name.
 	The hush code will be built into busybox. If you don't select
@@ -81,12 +85,12 @@ INSERT
 
 
 comment "Options common to all shells"
-if ASH || HUSH || SH_IS_ASH || BASH_IS_ASH || SH_IS_HUSH || BASH_IS_HUSH
+if SHELL_ASH || SHELL_HUSH
 
 config FEATURE_SH_MATH
 	bool "POSIX math support"
 	default y
-	depends on ASH || HUSH || SH_IS_ASH || BASH_IS_ASH || SH_IS_HUSH || BASH_IS_HUSH
+	depends on SHELL_ASH || SHELL_HUSH
 	help
 	Enable math support in the shell via $((...)) syntax.
 
@@ -107,14 +111,14 @@ config FEATURE_SH_MATH_BASE
 config FEATURE_SH_EXTRA_QUIET
 	bool "Hide message on interactive shell startup"
 	default y
-	depends on ASH || HUSH || SH_IS_ASH || BASH_IS_ASH || SH_IS_HUSH || BASH_IS_HUSH
+	depends on SHELL_ASH || SHELL_HUSH
 	help
 	Remove the busybox introduction when starting a shell.
 
 config FEATURE_SH_STANDALONE
 	bool "Standalone shell"
 	default n
-	depends on ASH || HUSH || SH_IS_ASH || BASH_IS_ASH || SH_IS_HUSH || BASH_IS_HUSH
+	depends on SHELL_ASH || SHELL_HUSH
 	help
 	This option causes busybox shells to use busybox applets
 	in preference to executables in the PATH whenever possible. For
@@ -135,7 +139,7 @@ config FEATURE_SH_STANDALONE
 config FEATURE_SH_NOFORK
 	bool "Run 'nofork' applets directly"
 	default n
-	depends on ASH || HUSH || SH_IS_ASH || BASH_IS_ASH || SH_IS_HUSH || BASH_IS_HUSH
+	depends on SHELL_ASH || SHELL_HUSH
 	help
 	This option causes busybox shells to not execute typical
 	fork/exec/wait sequence, but call <applet>_main directly,
@@ -153,14 +157,14 @@ config FEATURE_SH_NOFORK
 config FEATURE_SH_READ_FRAC
 	bool "read -t N.NNN support (+110 bytes)"
 	default y
-	depends on ASH || HUSH || SH_IS_ASH || BASH_IS_ASH || SH_IS_HUSH || BASH_IS_HUSH
+	depends on SHELL_ASH || SHELL_HUSH
 	help
 	Enable support for fractional second timeout in read builtin.
 
 config FEATURE_SH_HISTFILESIZE
 	bool "Use $HISTFILESIZE"
 	default y
-	depends on ASH || HUSH || SH_IS_ASH || BASH_IS_ASH || SH_IS_HUSH || BASH_IS_HUSH
+	depends on SHELL_ASH || SHELL_HUSH
 	help
 	This option makes busybox shells to use $HISTFILESIZE variable
 	to set shell history size. Note that its max value is capped
@@ -169,7 +173,7 @@ config FEATURE_SH_HISTFILESIZE
 config FEATURE_SH_EMBEDDED_SCRIPTS
 	bool "Embed scripts in the binary"
 	default y
-	depends on ASH || HUSH || SH_IS_ASH || BASH_IS_ASH || SH_IS_HUSH || BASH_IS_HUSH
+	depends on SHELL_ASH || SHELL_HUSH
 	help
 	Allow scripts to be compressed and embedded in the busybox
 	binary. The scripts should be placed in the 'embed' directory
diff -urpN busybox-1.31.1/shell/ash.c busybox-1.32.0/shell/ash.c
--- busybox-1.31.1/shell/ash.c	2019-10-21 18:54:40.000000000 +0400
+++ busybox-1.32.0/shell/ash.c	2020-06-26 22:47:44.000000000 +0400
@@ -15,10 +15,15 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+//config:config SHELL_ASH
+//config:	bool #hidden option
+//config:	depends on !NOMMU
+//config:
 //config:config ASH
 //config:	bool "ash (78 kb)"
 //config:	default y
 //config:	depends on !NOMMU
+//config:	select SHELL_ASH
 //config:	help
 //config:	The most complete and most pedantically correct shell included with
 //config:	busybox. This shell is actually a derivative of the Debian 'dash'
@@ -28,17 +33,17 @@
 //config:# ash options
 //config:# note: Don't remove !NOMMU part in the next line; it would break
 //config:# menuconfig's indenting.
-//config:if !NOMMU && (ASH || SH_IS_ASH || BASH_IS_ASH)
+//config:if !NOMMU && (SHELL_ASH || ASH || SH_IS_ASH || BASH_IS_ASH)
 //config:
 //config:config ASH_OPTIMIZE_FOR_SIZE
 //config:	bool "Optimize for size instead of speed"
 //config:	default y
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:	depends on SHELL_ASH
 //config:
 //config:config ASH_INTERNAL_GLOB
 //config:	bool "Use internal glob() implementation"
 //config:	default y	# Y is bigger, but because of uclibc glob() bug, let Y be default for now
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:	depends on SHELL_ASH
 //config:	help
 //config:	Do not use glob() function from libc, use internal implementation.
 //config:	Use this if you are getting "glob.h: No such file or directory"
@@ -49,7 +54,7 @@
 //config:config ASH_BASH_COMPAT
 //config:	bool "bash-compatible extensions"
 //config:	default y
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:	depends on SHELL_ASH
 //config:
 //config:config ASH_BASH_SOURCE_CURDIR
 //config:	bool "'source' and '.' builtins search current directory after $PATH"
@@ -70,17 +75,17 @@
 //config:config ASH_JOB_CONTROL
 //config:	bool "Job control"
 //config:	default y
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:	depends on SHELL_ASH
 //config:
 //config:config ASH_ALIAS
 //config:	bool "Alias support"
 //config:	default y
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:	depends on SHELL_ASH
 //config:
 //config:config ASH_RANDOM_SUPPORT
 //config:	bool "Pseudorandom generator and $RANDOM variable"
 //config:	default y
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:	depends on SHELL_ASH
 //config:	help
 //config:	Enable pseudorandom generator and dynamic variable "$RANDOM".
 //config:	Each read of "$RANDOM" will generate a new pseudorandom value.
@@ -91,7 +96,7 @@
 //config:config ASH_EXPAND_PRMT
 //config:	bool "Expand prompt string"
 //config:	default y
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:	depends on SHELL_ASH
 //config:	help
 //config:	$PS# may contain volatile content, such as backquote commands.
 //config:	This option recreates the prompt string from the environment
@@ -100,14 +105,14 @@
 //config:config ASH_IDLE_TIMEOUT
 //config:	bool "Idle timeout variable $TMOUT"
 //config:	default y
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:	depends on SHELL_ASH
 //config:	help
 //config:	Enable bash-like auto-logout after $TMOUT seconds of idle time.
 //config:
 //config:config ASH_MAIL
 //config:	bool "Check for new mail in interactive shell"
 //config:	default y
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:	depends on SHELL_ASH
 //config:	help
 //config:	Enable "check for new mail" function:
 //config:	if set, $MAIL file and $MAILPATH list of files
@@ -117,32 +122,32 @@
 //config:config ASH_ECHO
 //config:	bool "echo builtin"
 //config:	default y
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:	depends on SHELL_ASH
 //config:
 //config:config ASH_PRINTF
 //config:	bool "printf builtin"
 //config:	default y
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:	depends on SHELL_ASH
 //config:
 //config:config ASH_TEST
 //config:	bool "test builtin"
 //config:	default y
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:	depends on SHELL_ASH
 //config:
 //config:config ASH_HELP
 //config:	bool "help builtin"
 //config:	default y
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:	depends on SHELL_ASH
 //config:
 //config:config ASH_GETOPTS
 //config:	bool "getopts builtin"
 //config:	default y
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:	depends on SHELL_ASH
 //config:
 //config:config ASH_CMDCMD
 //config:	bool "command builtin"
 //config:	default y
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:	depends on SHELL_ASH
 //config:	help
 //config:	Enable support for the 'command' builtin, which allows
 //config:	you to run the specified command or builtin,
@@ -155,9 +160,7 @@
 //applet:IF_SH_IS_ASH(  APPLET_ODDNAME(sh,   ash, BB_DIR_BIN, BB_SUID_DROP, ash))
 //applet:IF_BASH_IS_ASH(APPLET_ODDNAME(bash, ash, BB_DIR_BIN, BB_SUID_DROP, ash))
 
-//kbuild:lib-$(CONFIG_ASH) += ash.o ash_ptr_hack.o shell_common.o
-//kbuild:lib-$(CONFIG_SH_IS_ASH) += ash.o ash_ptr_hack.o shell_common.o
-//kbuild:lib-$(CONFIG_BASH_IS_ASH) += ash.o ash_ptr_hack.o shell_common.o
+//kbuild:lib-$(CONFIG_SHELL_ASH) += ash.o ash_ptr_hack.o shell_common.o
 //kbuild:lib-$(CONFIG_ASH_RANDOM_SUPPORT) += random.o
 
 /*
@@ -384,6 +387,7 @@ struct globals_misc {
 	uint8_t exitstatus;     /* exit status of last command */
 	uint8_t back_exitstatus;/* exit status of backquoted command */
 	smallint job_warning;   /* user was warned about stopped jobs (can be 2, 1 or 0). */
+	int savestatus;         /* exit status of last command outside traps */
 	int rootpid;            /* pid of main shell */
 	/* shell level: 0 for the main shell, 1 for its children, and so on */
 	int shlvl;
@@ -403,11 +407,11 @@ struct globals_misc {
 	volatile /*sig_atomic_t*/ smallint pending_int; /* 1 = got SIGINT */
 	volatile /*sig_atomic_t*/ smallint got_sigchld; /* 1 = got SIGCHLD */
 	volatile /*sig_atomic_t*/ smallint pending_sig;	/* last pending signal */
-	smallint exception_type; /* kind of exception (0..5) */
-	/* exceptions */
+	smallint exception_type; /* kind of exception: */
 #define EXINT 0         /* SIGINT received */
 #define EXERROR 1       /* a generic error */
-#define EXEXIT 4        /* exit the shell */
+#define EXEND 3         /* exit the shell */
+#define EXEXIT 4        /* exit the shell via exitcmd */
 
 	char nullstr[1];        /* zero length string */
 
@@ -466,6 +470,7 @@ extern struct globals_misc *BB_GLOBAL_CO
 #define exitstatus        (G_misc.exitstatus )
 #define back_exitstatus   (G_misc.back_exitstatus )
 #define job_warning       (G_misc.job_warning)
+#define savestatus  (G_misc.savestatus )
 #define rootpid     (G_misc.rootpid    )
 #define shlvl       (G_misc.shlvl      )
 #define errlinno    (G_misc.errlinno   )
@@ -489,8 +494,9 @@ extern struct globals_misc *BB_GLOBAL_CO
 #define random_gen  (G_misc.random_gen )
 #define backgndpid  (G_misc.backgndpid )
 #define INIT_G_misc() do { \
-	(*(struct globals_misc**)&ash_ptr_to_globals_misc) = xzalloc(sizeof(G_misc)); \
+	(*(struct globals_misc**)not_const_pp(&ash_ptr_to_globals_misc)) = xzalloc(sizeof(G_misc)); \
 	barrier(); \
+	savestatus = -1; \
 	curdir = nullstr; \
 	physdir = nullstr; \
 	trap_ptr = trap; \
@@ -710,7 +716,7 @@ fmtstr(char *outbuf, size_t length, cons
 	ret = vsnprintf(outbuf, length, fmt, ap);
 	va_end(ap);
 	INT_ON;
-	return ret;
+	return ret > (int)length ? length : ret;
 }
 
 static void
@@ -1542,7 +1548,7 @@ extern struct globals_memstack *BB_GLOBA
 #define g_stacknleft (G_memstack.g_stacknleft)
 #define stackbase    (G_memstack.stackbase   )
 #define INIT_G_memstack() do { \
-	(*(struct globals_memstack**)&ash_ptr_to_globals_memstack) = xzalloc(sizeof(G_memstack)); \
+	(*(struct globals_memstack**)not_const_pp(&ash_ptr_to_globals_memstack)) = xzalloc(sizeof(G_memstack)); \
 	barrier(); \
 	g_stackp = &stackbase; \
 	g_stacknxt = stackbase.space; \
@@ -1675,15 +1681,16 @@ popstackmark(struct stackmark *mark)
  * part of the block that has been used.
  */
 static void
-growstackblock(void)
+growstackblock(size_t min)
 {
 	size_t newlen;
 
 	newlen = g_stacknleft * 2;
 	if (newlen < g_stacknleft)
 		ash_msg_and_raise_error(bb_msg_memory_exhausted);
-	if (newlen < 128)
-		newlen += 128;
+	min = SHELL_ALIGN(min | 128);
+	if (newlen < min)
+		newlen += min;
 
 	if (g_stacknxt == g_stackp->space && g_stackp != &stackbase) {
 		struct stack_block *sp;
@@ -1733,10 +1740,18 @@ static void *
 growstackstr(void)
 {
 	size_t len = stackblocksize();
-	growstackblock();
+	growstackblock(0);
 	return (char *)stackblock() + len;
 }
 
+static char *
+growstackto(size_t len)
+{
+	if (stackblocksize() < len)
+		growstackblock(len);
+	return stackblock();
+}
+
 /*
  * Called from CHECKSTRSPACE.
  */
@@ -1744,22 +1759,12 @@ static char *
 makestrspace(size_t newlen, char *p)
 {
 	size_t len = p - g_stacknxt;
-	size_t size;
 
-	for (;;) {
-		size_t nleft;
-
-		size = stackblocksize();
-		nleft = size - len;
-		if (nleft >= newlen)
-			break;
-		growstackblock();
-	}
-	return (char *)stackblock() + len;
+	return growstackto(len + newlen) + len;
 }
 
 static char *
-stack_nputstr(const char *s, size_t n, char *p)
+stnputs(const char *s, size_t n, char *p)
 {
 	p = makestrspace(n, p);
 	p = (char *)mempcpy(p, s, n);
@@ -1769,7 +1774,7 @@ stack_nputstr(const char *s, size_t n, c
 static char *
 stack_putstr(const char *s, char *p)
 {
-	return stack_nputstr(s, strlen(s), p);
+	return stnputs(s, strlen(s), p);
 }
 
 static char *
@@ -2165,7 +2170,7 @@ extern struct globals_var *BB_GLOBAL_CON
 #endif
 #define INIT_G_var() do { \
 	unsigned i; \
-	(*(struct globals_var**)&ash_ptr_to_globals_var) = xzalloc(sizeof(G_var)); \
+	(*(struct globals_var**)not_const_pp(&ash_ptr_to_globals_var)) = xzalloc(sizeof(G_var)); \
 	barrier(); \
 	for (i = 0; i < ARRAY_SIZE(varinit_data); i++) { \
 		varinit[i].flags    = varinit_data[i].flags; \
@@ -2475,24 +2480,6 @@ unsetvar(const char *s)
 }
 
 /*
- * Process a linked list of variable assignments.
- */
-static void
-listsetvar(struct strlist *list_set_var, int flags)
-{
-	struct strlist *lp = list_set_var;
-
-	if (!lp)
-		return;
-	INT_OFF;
-	do {
-		setvareq(lp->text, flags);
-		lp = lp->next;
-	} while (lp);
-	INT_ON;
-}
-
-/*
  * Generate a list of variables satisfying the given conditions.
  */
 #if !ENABLE_FEATURE_SH_NOFORK
@@ -2555,51 +2542,102 @@ listvars(int on, int off, struct strlist
 }
 
 
-/* ============ Path search helper
- *
+/* ============ Path search helper */
+static const char *
+legal_pathopt(const char *opt, const char *term, int magic)
+{
+	switch (magic) {
+	case 0:
+		opt = NULL;
+		break;
+
+	case 1:
+		opt = prefix(opt, "builtin") ?: prefix(opt, "func");
+		break;
+
+	default:
+		opt += strcspn(opt, term);
+		break;
+	}
+
+	if (opt && *opt == '%')
+		opt++;
+
+	return opt;
+}
+
+/*
  * The variable path (passed by reference) should be set to the start
- * of the path before the first call; path_advance will update
- * this value as it proceeds.  Successive calls to path_advance will return
+ * of the path before the first call; padvance will update
+ * this value as it proceeds.  Successive calls to padvance will return
  * the possible path expansions in sequence.  If an option (indicated by
  * a percent sign) appears in the path entry then the global variable
  * pathopt will be set to point to it; otherwise pathopt will be set to
  * NULL.
+ *
+ * If magic is 0 then pathopt recognition will be disabled.  If magic is
+ * 1 we shall recognise %builtin/%func.  Otherwise we shall accept any
+ * pathopt.
  */
-static const char *pathopt;     /* set by path_advance */
+static const char *pathopt;     /* set by padvance */
 
-static char *
-path_advance(const char **path, const char *name)
+static int
+padvance_magic(const char **path, const char *name, int magic)
 {
+	const char *term = "%:";
+	const char *lpathopt;
 	const char *p;
 	char *q;
 	const char *start;
+	size_t qlen;
 	size_t len;
 
 	if (*path == NULL)
-		return NULL;
+		return -1;
+
+	lpathopt = NULL;
 	start = *path;
-	for (p = start; *p && *p != ':' && *p != '%'; p++)
-		continue;
-	len = p - start + strlen(name) + 2;     /* "2" is for '/' and '\0' */
-	while (stackblocksize() < len)
-		growstackblock();
-	q = stackblock();
-	if (p != start) {
-		q = mempcpy(q, start, p - start);
-		*q++ = '/';
+
+	if (*start == '%' && (p = legal_pathopt(start + 1, term, magic))) {
+		lpathopt = start + 1;
+		start = p;
+		term = ":";
 	}
-	strcpy(q, name);
-	pathopt = NULL;
+
+	len = strcspn(start, term);
+	p = start + len;
+
 	if (*p == '%') {
-		pathopt = ++p;
-		while (*p && *p != ':')
-			p++;
+		size_t extra = strchrnul(p, ':') - p;
+
+		if (legal_pathopt(p + 1, term, magic))
+			lpathopt = p + 1;
+		else
+			len += extra;
+
+		p += extra;
 	}
-	if (*p == ':')
-		*path = p + 1;
-	else
-		*path = NULL;
-	return stalloc(len);
+
+	pathopt = lpathopt;
+	*path = *p == ':' ? p + 1 : NULL;
+
+	/* "2" is for '/' and '\0' */
+	qlen = len + strlen(name) + 2;
+	q = growstackto(qlen);
+
+	if (len) {
+		q = mempcpy(q, start, len);
+		*q++ = '/';
+	}
+	strcpy(q, name);
+
+	return qlen;
+}
+
+static int
+padvance(const char **path, const char *name)
+{
+	return padvance_magic(path, name, 1);
 }
 
 
@@ -2840,6 +2878,7 @@ cdcmd(int argc UNUSED_PARAM, char **argv
 	char c;
 	struct stat statb;
 	int flags;
+	int len;
 
 	flags = cdopt();
 	dest = *argptr;
@@ -2869,9 +2908,10 @@ cdcmd(int argc UNUSED_PARAM, char **argv
 	if (!*dest)
 		dest = ".";
 	path = bltinlookup("CDPATH");
-	while (path) {
-		c = *path;
-		p = path_advance(&path, dest);
+	while (p = path, (len = padvance(&path, dest)) >= 0) {
+		c = *p;
+		p = stalloc(len);
+
 		if (stat(p, &statb) >= 0 && S_ISDIR(statb.st_mode)) {
 			if (c && c != ':')
 				flags |= CD_PRINT;
@@ -3755,8 +3795,6 @@ static struct job *jobtab; //5
 static unsigned njobs; //4
 /* current job */
 static struct job *curjob; //lots
-/* number of presumed living untracked jobs */
-static int jobless; //4
 
 #if 0
 /* Bash has a feature: it restores termios after a successful wait for
@@ -4200,12 +4238,11 @@ fg_bgcmd(int argc UNUSED_PARAM, char **a
 #endif
 
 static int
-sprint_status48(char *s, int status, int sigonly)
+sprint_status48(char *os, int status, int sigonly)
 {
-	int col;
+	char *s = os;
 	int st;
 
-	col = 0;
 	if (!WIFEXITED(status)) {
 #if JOBS
 		if (WIFSTOPPED(status))
@@ -4223,17 +4260,17 @@ sprint_status48(char *s, int status, int
 		}
 		st &= 0x7f;
 //TODO: use bbox's get_signame? strsignal adds ~600 bytes to text+rodata
-		col = fmtstr(s, 32, strsignal(st));
+		//s = stpncpy(s, strsignal(st), 32); //not all libc have stpncpy()
+		s += fmtstr(s, 32, strsignal(st));
 		if (WCOREDUMP(status)) {
-			strcpy(s + col, " (core dumped)");
-			col += sizeof(" (core dumped)")-1;
+			s = stpcpy(s, " (core dumped)");
 		}
 	} else if (!sigonly) {
 		st = WEXITSTATUS(status);
-		col = fmtstr(s, 16, (st ? "Done(%d)" : "Done"), st);
+		s += fmtstr(s, 16, (st ? "Done(%d)" : "Done"), st);
 	}
  out:
-	return col;
+	return s - os;
 }
 
 static int
@@ -4255,8 +4292,19 @@ wait_block_or_sig(int *status)
 #if 1
 		sigfillset(&mask);
 		sigprocmask2(SIG_SETMASK, &mask); /* mask is updated */
-		while (!got_sigchld && !pending_sig)
+		while (!got_sigchld && !pending_sig) {
 			sigsuspend(&mask);
+			/* ^^^ add "sigdelset(&mask, SIGCHLD);" before sigsuspend
+			 * to make sure SIGCHLD is not masked off?
+			 * It was reported that this:
+			 *	fn() { : | return; }
+			 *	shopt -s lastpipe
+			 *	fn
+			 *	exec ash SCRIPT
+			 * under bash 4.4.23 runs SCRIPT with SIGCHLD masked,
+			 * making "wait" commands in SCRIPT block forever.
+			 */
+		}
 		sigprocmask(SIG_SETMASK, &mask, NULL);
 #else /* unsafe: a signal can set pending_sig after check, but before pause() */
 		while (!got_sigchld && !pending_sig)
@@ -4277,7 +4325,7 @@ wait_block_or_sig(int *status)
 #endif
 
 static int
-dowait(int block, struct job *job)
+waitone(int block, struct job *job)
 {
 	int pid;
 	int status;
@@ -4378,10 +4426,6 @@ dowait(int block, struct job *job)
 		goto out;
 	}
 	/* The process wasn't found in job list */
-#if JOBS
-	if (!WIFSTOPPED(status))
-		jobless--;
-#endif
  out:
 	INT_ON;
 
@@ -4406,6 +4450,20 @@ dowait(int block, struct job *job)
 	return pid;
 }
 
+static int
+dowait(int block, struct job *jp)
+{
+	int pid = block == DOWAIT_NONBLOCK ? got_sigchld : 1;
+
+	while (jp ? jp->state == JOBRUNNING : pid > 0) {
+		if (!jp)
+			got_sigchld = 0;
+		pid = waitone(block, jp);
+	}
+
+	return pid;
+}
+
 #if JOBS
 static void
 showjob(struct job *jp, int mode)
@@ -4494,8 +4552,7 @@ showjobs(int mode)
 	TRACE(("showjobs(0x%x) called\n", mode));
 
 	/* Handle all finished jobs */
-	while (dowait(DOWAIT_NONBLOCK, NULL) > 0)
-		continue;
+	dowait(DOWAIT_NONBLOCK, NULL);
 
 	for (jp = curjob; jp; jp = jp->prev_job) {
 		if (!(mode & SHOW_CHANGED) || jp->changed) {
@@ -4612,10 +4669,10 @@ waitcmd(int argc UNUSED_PARAM, char **ar
 #else
 			dowait(DOWAIT_BLOCK_OR_SIG, NULL);
 #endif
-	/* if child sends us a signal *and immediately exits*,
-	 * dowait() returns pid > 0. Check this case,
-	 * not "if (dowait() < 0)"!
-	 */
+			/* if child sends us a signal *and immediately exits*,
+			 * dowait() returns pid > 0. Check this case,
+			 * not "if (dowait() < 0)"!
+			 */
 			if (pending_sig)
 				goto sigout;
 #if BASH_WAIT_N
@@ -4651,11 +4708,9 @@ waitcmd(int argc UNUSED_PARAM, char **ar
 			job = getjob(*argv, 0);
 		}
 		/* loop until process terminated or stopped */
-		while (job->state == JOBRUNNING) {
-			dowait(DOWAIT_BLOCK_OR_SIG, NULL);
-			if (pending_sig)
-				goto sigout;
-		}
+		dowait(DOWAIT_BLOCK_OR_SIG, NULL);
+		if (pending_sig)
+			goto sigout;
 		job->waited = 1;
 		retval = getstatus(job);
  repeat: ;
@@ -4797,7 +4852,8 @@ cmdputs(const char *s)
 				str = "${";
 			goto dostr;
 		case CTLENDVAR:
-			str = "\"}" + !(quoted & 1);
+			str = "\"}";
+			str += !(quoted & 1);
 			quoted >>= 1;
 			subtype = 0;
 			goto dostr;
@@ -5206,7 +5262,6 @@ forkchild(struct job *jp, union node *n,
 #endif
 	for (jp = curjob; jp; jp = jp->prev_job)
 		freejob(jp);
-	jobless = 0;
 }
 
 /* Called after fork(), in parent */
@@ -5217,13 +5272,8 @@ static void
 forkparent(struct job *jp, union node *n, int mode, pid_t pid)
 {
 	TRACE(("In parent shell: child = %d\n", pid));
-	if (!jp) {
-		/* jp is NULL when called by openhere() for heredoc support */
-		while (jobless && dowait(DOWAIT_NONBLOCK, NULL) > 0)
-			continue;
-		jobless++;
+	if (!jp) /* jp is NULL when called by openhere() for heredoc support */
 		return;
-	}
 #if JOBS
 	if (mode != FORK_NOJOB && jp->jobctl) {
 		int pgrp;
@@ -5300,43 +5350,41 @@ waitforjob(struct job *jp)
 {
 	int st;
 
-	TRACE(("waitforjob(%%%d) called\n", jobno(jp)));
+	TRACE(("waitforjob(%%%d) called\n", jp ? jobno(jp) : 0));
 
-	INT_OFF;
-	while (jp->state == JOBRUNNING) {
-		/* In non-interactive shells, we _can_ get
-		 * a keyboard signal here and be EINTRed,
-		 * but we just loop back, waiting for command to complete.
-		 *
-		 * man bash:
-		 * "If bash is waiting for a command to complete and receives
-		 * a signal for which a trap has been set, the trap
-		 * will not be executed until the command completes."
-		 *
-		 * Reality is that even if trap is not set, bash
-		 * will not act on the signal until command completes.
-		 * Try this. sleep5intoff.c:
-		 * #include <signal.h>
-		 * #include <unistd.h>
-		 * int main() {
-		 *         sigset_t set;
-		 *         sigemptyset(&set);
-		 *         sigaddset(&set, SIGINT);
-		 *         sigaddset(&set, SIGQUIT);
-		 *         sigprocmask(SIG_BLOCK, &set, NULL);
-		 *         sleep(5);
-		 *         return 0;
-		 * }
-		 * $ bash -c './sleep5intoff; echo hi'
-		 * ^C^C^C^C <--- pressing ^C once a second
-		 * $ _
-		 * $ bash -c './sleep5intoff; echo hi'
-		 * ^\^\^\^\hi <--- pressing ^\ (SIGQUIT)
-		 * $ _
-		 */
-		dowait(DOWAIT_BLOCK, jp);
-	}
-	INT_ON;
+	/* In non-interactive shells, we _can_ get
+	 * a keyboard signal here and be EINTRed, but we just loop
+	 * inside dowait(), waiting for command to complete.
+	 *
+	 * man bash:
+	 * "If bash is waiting for a command to complete and receives
+	 * a signal for which a trap has been set, the trap
+	 * will not be executed until the command completes."
+	 *
+	 * Reality is that even if trap is not set, bash
+	 * will not act on the signal until command completes.
+	 * Try this. sleep5intoff.c:
+	 * #include <signal.h>
+	 * #include <unistd.h>
+	 * int main() {
+	 *         sigset_t set;
+	 *         sigemptyset(&set);
+	 *         sigaddset(&set, SIGINT);
+	 *         sigaddset(&set, SIGQUIT);
+	 *         sigprocmask(SIG_BLOCK, &set, NULL);
+	 *         sleep(5);
+	 *         return 0;
+	 * }
+	 * $ bash -c './sleep5intoff; echo hi'
+	 * ^C^C^C^C <--- pressing ^C once a second
+	 * $ _
+	 * $ bash -c './sleep5intoff; echo hi'
+	 * ^\^\^\^\hi <--- pressing ^\ (SIGQUIT)
+	 * $ _
+	 */
+	dowait(jp ? DOWAIT_BLOCK : DOWAIT_NONBLOCK, jp);
+	if (!jp)
+		return exitstatus;
 
 	st = getstatus(jp);
 #if JOBS
@@ -5399,22 +5447,29 @@ stoppedjobs(void)
  * the pipe without forking.
  */
 /* openhere needs this forward reference */
-static void expandhere(union node *arg, int fd);
+static void expandhere(union node *arg);
 static int
 openhere(union node *redir)
 {
+	char *p;
 	int pip[2];
 	size_t len = 0;
 
 	if (pipe(pip) < 0)
 		ash_msg_and_raise_perror("can't create pipe");
-	if (redir->type == NHERE) {
-		len = strlen(redir->nhere.doc->narg.text);
-		if (len <= PIPE_BUF) {
-			full_write(pip[1], redir->nhere.doc->narg.text, len);
-			goto out;
-		}
+
+	p = redir->nhere.doc->narg.text;
+	if (redir->type == NXHERE) {
+		expandhere(redir->nhere.doc);
+		p = stackblock();
+	}
+
+	len = strlen(p);
+	if (len <= PIPE_BUF) {
+		xwrite(pip[1], p, len);
+		goto out;
 	}
+
 	if (forkshell((struct job *)NULL, (union node *)NULL, FORK_NOJOB) == 0) {
 		/* child */
 		close(pip[0]);
@@ -5423,10 +5478,7 @@ openhere(union node *redir)
 		ignoresig(SIGHUP);  //signal(SIGHUP, SIG_IGN);
 		ignoresig(SIGTSTP); //signal(SIGTSTP, SIG_IGN);
 		signal(SIGPIPE, SIG_DFL);
-		if (redir->type == NHERE)
-			full_write(pip[1], redir->nhere.doc->narg.text, len);
-		else /* NXHERE */
-			expandhere(redir->nhere.doc, pip[1]);
+		xwrite(pip[1], p, len);
 		_exit(EXIT_SUCCESS);
 	}
  out:
@@ -5985,6 +6037,9 @@ static int substr_atoi(const char *s)
 #define EXP_VARTILDE2   0x20    /* expand tildes after colons only */
 #define EXP_WORD        0x40    /* expand word in parameter expansion */
 #define EXP_QUOTED      0x100   /* expand word in double quotes */
+#define EXP_KEEPNUL     0x200   /* do not skip NUL characters */
+#define EXP_DISCARD     0x400   /* discard result of expansion */
+
 /*
  * rmescape() flags
  */
@@ -5995,8 +6050,6 @@ static int substr_atoi(const char *s)
 
 /* Add CTLESC when necessary. */
 #define QUOTES_ESC     (EXP_FULL | EXP_CASE)
-/* Do not skip NUL characters. */
-#define QUOTES_KEEPNUL EXP_TILDE
 
 /*
  * Structure specifying which parts of the string should be searched
@@ -6026,26 +6079,6 @@ static struct ifsregion *ifslastp;
 static struct arglist exparg;
 
 /*
- * Our own itoa().
- * cvtnum() is used even if math support is off (to prepare $? values and such).
- */
-static int
-cvtnum(arith_t num)
-{
-	int len;
-
-	/* 32-bit and wider ints require buffer size of bytes*3 (or less) */
-	len = sizeof(arith_t) * 3;
-	/* If narrower: worst case, 1-byte ints: need 5 bytes: "-127<NUL>" */
-	if (sizeof(arith_t) < 4) len += 2;
-
-	expdest = makestrspace(len, expdest);
-	len = fmtstr(expdest, len, ARITH_FMT, num);
-	STADJUST(len, expdest);
-	return len;
-}
-
-/*
  * Break the argument string into pieces based upon IFS and add the
  * strings to the argument list.  The regions of the string to be
  * searched for IFS characters have been stored by recordregion.
@@ -6302,44 +6335,64 @@ preglob(const char *pattern, int flag)
 /*
  * Put a string on the stack.
  */
-static void
-memtodest(const char *p, size_t len, int syntax, int quotes)
+static size_t
+memtodest(const char *p, size_t len, int flags)
 {
+	int syntax = flags & EXP_QUOTED ? DQSYNTAX : BASESYNTAX;
 	char *q;
+	char *s;
 
 	if (!len)
-		return;
+		return 0;
 
-	q = makestrspace((quotes & QUOTES_ESC) ? len * 2 : len, expdest);
+	q = makestrspace(len * 2, expdest);
+	s = q;
 
 	do {
 		unsigned char c = *p++;
 		if (c) {
-			if (quotes & QUOTES_ESC) {
+			if (flags & QUOTES_ESC) {
 				int n = SIT(c, syntax);
 				if (n == CCTL
-				 || (syntax != BASESYNTAX && n == CBACK)
+				 || ((flags & EXP_QUOTED) && n == CBACK)
 				) {
 					USTPUTC(CTLESC, q);
 				}
 			}
-		} else if (!(quotes & QUOTES_KEEPNUL))
+		} else if (!(flags & EXP_KEEPNUL))
 			continue;
 		USTPUTC(c, q);
 	} while (--len);
 
 	expdest = q;
+	return q - s;
 }
 
 static size_t
-strtodest(const char *p, int syntax, int quotes)
+strtodest(const char *p, int flags)
 {
 	size_t len = strlen(p);
-	memtodest(p, len, syntax, quotes);
+	memtodest(p, len, flags);
 	return len;
 }
 
 /*
+ * Our own itoa().
+ * cvtnum() is used even if math support is off (to prepare $? values and such).
+ */
+static int
+cvtnum(arith_t num, int flags)
+{
+	/* 32-bit and wider ints require buffer size of bytes*3 (or less) */
+	/* If narrower: worst case, 1-byte ints: need 5 bytes: "-127<NUL>" */
+	int len = (sizeof(arith_t) >= 4) ? sizeof(arith_t) * 3 : sizeof(arith_t) * 3 + 2;
+	char buf[len];
+
+	len = fmtstr(buf, len, ARITH_FMT, num);
+	return memtodest(buf, len, flags);
+}
+
+/*
  * Record the fact that we have to scan this region of the
  * string for IFS characters.
  */
@@ -6403,14 +6456,15 @@ removerecordregions(int endoff)
 }
 
 static char *
-exptilde(char *startp, char *p, int flags)
+exptilde(char *startp, int flag)
 {
 	unsigned char c;
 	char *name;
 	struct passwd *pw;
 	const char *home;
-	int quotes = flags & QUOTES_ESC;
+	char *p;
 
+	p = startp;
 	name = p + 1;
 
 	while ((c = *++p) != '\0') {
@@ -6420,7 +6474,7 @@ exptilde(char *startp, char *p, int flag
 		case CTLQUOTEMARK:
 			return startp;
 		case ':':
-			if (flags & EXP_VARTILDE)
+			if (flag & EXP_VARTILDE)
 				goto done;
 			break;
 		case '/':
@@ -6429,6 +6483,8 @@ exptilde(char *startp, char *p, int flag
 		}
 	}
  done:
+	if (flag & EXP_DISCARD)
+		goto out;
 	*p = '\0';
 	if (*name == '\0') {
 		home = lookupvar("HOME");
@@ -6438,13 +6494,13 @@ exptilde(char *startp, char *p, int flag
 			goto lose;
 		home = pw->pw_dir;
 	}
-	if (!home || !*home)
-		goto lose;
 	*p = c;
-	strtodest(home, SQSYNTAX, quotes);
+	if (!home)
+		goto lose;
+	strtodest(home, flag | EXP_QUOTED);
+ out:
 	return p;
  lose:
-	*p = c;
 	return startp;
 }
 
@@ -6541,9 +6597,11 @@ expbackq(union node *cmd, int flag)
 	char *p;
 	char *dest;
 	int startloc;
-	int syntax = flag & EXP_QUOTED ? DQSYNTAX : BASESYNTAX;
 	struct stackmark smark;
 
+	if (flag & EXP_DISCARD)
+		goto out;
+
 	INT_OFF;
 	startloc = expdest - (char *)stackblock();
 	pushstackmark(&smark, startloc);
@@ -6555,7 +6613,7 @@ expbackq(union node *cmd, int flag)
 	if (i == 0)
 		goto read;
 	for (;;) {
-		memtodest(p, i, syntax, flag & QUOTES_ESC);
+		memtodest(p, i, flag);
  read:
 		if (in.fd < 0)
 			break;
@@ -6575,7 +6633,7 @@ expbackq(union node *cmd, int flag)
 
 	/* Eat all trailing newlines */
 	dest = expdest;
-	for (; dest > (char *)stackblock() && dest[-1] == '\n';)
+	for (; dest > ((char *)stackblock() + startloc) && dest[-1] == '\n';)
 		STUNPUTC(dest);
 	expdest = dest;
 
@@ -6585,64 +6643,57 @@ expbackq(union node *cmd, int flag)
 		(int)((dest - (char *)stackblock()) - startloc),
 		(int)((dest - (char *)stackblock()) - startloc),
 		stackblock() + startloc));
+
+ out:
+	argbackq = argbackq->next;
 }
 
+/* expari needs it */
+static char *argstr(char *p, int flag);
+
 #if ENABLE_FEATURE_SH_MATH
 /*
  * Expand arithmetic expression.  Backup to start of expression,
  * evaluate, place result in (backed up) result, adjust string position.
  */
-static void
-expari(int flag)
+static char *
+expari(char *start, int flag)
 {
-	char *p, *start;
+	struct stackmark sm;
 	int begoff;
+	int endoff;
 	int len;
+	arith_t result;
+	char *p;
 
-	/* ifsfree(); */
-
-	/*
-	 * This routine is slightly over-complicated for
-	 * efficiency.  Next we scan backwards looking for the
-	 * start of arithmetic.
-	 */
-	start = stackblock();
-	p = expdest - 1;
-	*p = '\0';
-	p--;
-	while (1) {
-		int esc;
-
-		while ((unsigned char)*p != CTLARI) {
-			p--;
-#if DEBUG
-			if (p < start) {
-				ash_msg_and_raise_error("missing CTLARI (shouldn't happen)");
-			}
-#endif
-		}
-
-		esc = esclen(start, p);
-		if (!(esc % 2)) {
-			break;
-		}
+	p = stackblock();
+	begoff = expdest - p;
+	p = argstr(start, flag & EXP_DISCARD);
 
-		p -= esc + 1;
-	}
+	if (flag & EXP_DISCARD)
+		goto out;
 
-	begoff = p - start;
+	start = stackblock();
+	endoff = expdest - start;
+	start += begoff;
+	STADJUST(start - expdest, expdest);
 
 	removerecordregions(begoff);
 
-	expdest = p;
-
 	if (flag & QUOTES_ESC)
-		rmescapes(p + 1, 0, NULL);
+		rmescapes(start, 0, NULL);
 
-	len = cvtnum(ash_arith(p + 1));
+	pushstackmark(&sm, endoff);
+	result = ash_arith(start);
+	popstackmark(&sm);
+
+	len = cvtnum(result, flag);
 
 	if (!(flag & EXP_QUOTED))
 		recordregion(begoff, begoff + len, 0);
+
+ out:
+	return p;
 }
 #endif
 
@@ -6654,8 +6705,8 @@ static char *evalvar(char *p, int flags)
  * characters to allow for further processing.  Otherwise treat
  * $@ like $* since no splitting will be performed.
  */
-static void
-argstr(char *p, int flags)
+static char *
+argstr(char *p, int flag)
 {
 	static const char spclchars[] ALIGN1 = {
 		'=',
@@ -6666,51 +6717,56 @@ argstr(char *p, int flags)
 		CTLVAR,
 		CTLBACKQ,
 #if ENABLE_FEATURE_SH_MATH
+		CTLARI,
 		CTLENDARI,
 #endif
 		'\0'
 	};
 	const char *reject = spclchars;
-	int breakall = (flags & (EXP_WORD | EXP_QUOTED)) == EXP_WORD;
+	int breakall = (flag & (EXP_WORD | EXP_QUOTED)) == EXP_WORD;
 	int inquotes;
 	size_t length;
 	int startloc;
 
-	if (!(flags & EXP_VARTILDE)) {
-		reject += 2;
-	} else if (flags & EXP_VARTILDE2) {
-		reject++;
-	}
+	reject += !!(flag & EXP_VARTILDE2);
+	reject += flag & EXP_VARTILDE ? 0 : 2;
 	inquotes = 0;
 	length = 0;
-	if (flags & EXP_TILDE) {
-		char *q;
-
-		flags &= ~EXP_TILDE;
+	if (flag & EXP_TILDE) {
+		flag &= ~EXP_TILDE;
  tilde:
-		q = p;
-		if (*q == '~')
-			p = exptilde(p, q, flags);
+		if (*p == '~')
+			p = exptilde(p, flag);
 	}
  start:
 	startloc = expdest - (char *)stackblock();
 	for (;;) {
+		int end;
 		unsigned char c;
 
 		length += strcspn(p + length, reject);
+		end = 0;
 		c = p[length];
-		if (c) {
-			if (!(c & 0x80)
-			IF_FEATURE_SH_MATH(|| c == CTLENDARI)
-			) {
-				/* c == '=' || c == ':' || c == CTLENDARI */
-				length++;
-			}
+		if (!(c & 0x80)
+		 IF_FEATURE_SH_MATH(|| c == CTLENDARI)
+		 || c == CTLENDVAR
+		) {
+			/*
+			 * c == '=' || c == ':' || c == '\0' ||
+			 * c == CTLENDARI || c == CTLENDVAR
+			 */
+			length++;
+			/* c == '\0' || c == CTLENDARI || c == CTLENDVAR */
+			end = !!((c - 1) & 0x80);
 		}
-		if (length > 0) {
+		if (length > 0 && !(flag & EXP_DISCARD)) {
 			int newloc;
-			expdest = stack_nputstr(p, length, expdest);
-			newloc = expdest - (char *)stackblock();
+			char *q;
+
+			q = stnputs(p, length, expdest);
+			q[-1] &= end - 1;
+			expdest = q - (flag & EXP_WORD ? end : 0);
+			newloc = q - (char *)stackblock() - end;
 			if (breakall && !inquotes && newloc > startloc) {
 				recordregion(startloc, newloc, 0);
 			}
@@ -6719,15 +6775,12 @@ argstr(char *p, int flags)
 		p += length + 1;
 		length = 0;
 
+		if (end)
+			break;
+
 		switch (c) {
-		case '\0':
-			goto breakloop;
 		case '=':
-			if (flags & EXP_VARTILDE2) {
-				p--;
-				continue;
-			}
-			flags |= EXP_VARTILDE2;
+			flag |= EXP_VARTILDE2;
 			reject++;
 			/* fall through */
 		case ':':
@@ -6739,20 +6792,15 @@ argstr(char *p, int flags)
 				goto tilde;
 			}
 			continue;
-		}
-
-		switch (c) {
-		case CTLENDVAR: /* ??? */
-			goto breakloop;
 		case CTLQUOTEMARK:
 			/* "$@" syntax adherence hack */
 			if (!inquotes && !memcmp(p, dolatstr + 1, DOLATSTRLEN - 1)) {
-				p = evalvar(p + 1, flags | EXP_QUOTED) + 1;
+				p = evalvar(p + 1, flag | EXP_QUOTED) + 1;
 				goto start;
 			}
 			inquotes ^= EXP_QUOTED;
  addquote:
-			if (flags & QUOTES_ESC) {
+			if (flag & QUOTES_ESC) {
 				p--;
 				length++;
 				startloc++;
@@ -6764,22 +6812,20 @@ argstr(char *p, int flags)
 			goto addquote;
 		case CTLVAR:
 			TRACE(("argstr: evalvar('%s')\n", p));
-			p = evalvar(p, flags | inquotes);
+			p = evalvar(p, flag | inquotes);
 			TRACE(("argstr: evalvar:'%s'\n", (char *)stackblock()));
 			goto start;
 		case CTLBACKQ:
-			expbackq(argbackq->n, flags | inquotes);
-			argbackq = argbackq->next;
+			expbackq(argbackq->n, flag | inquotes);
 			goto start;
 #if ENABLE_FEATURE_SH_MATH
-		case CTLENDARI:
-			p--;
-			expari(flags | inquotes);
+		case CTLARI:
+			p = expari(p, flag | inquotes);
 			goto start;
 #endif
 		}
 	}
- breakloop: ;
+	return p - 1;
 }
 
 static char *
@@ -6904,26 +6950,27 @@ varunset(const char *end, const char *va
 	ash_msg_and_raise_error("%.*s: %s%s", (int)(end - var - 1), var, msg, tail);
 }
 
-static const char *
-subevalvar(char *p, char *varname, int strloc, int subtype,
+static char *
+subevalvar(char *start, char *str, int strloc,
 		int startloc, int varflags, int flag)
 {
-	struct nodelist *saveargbackq = argbackq;
+	int subtype = varflags & VSTYPE;
 	int quotes = flag & QUOTES_ESC;
 	char *startp;
 	char *loc;
 	char *rmesc, *rmescend;
-	char *str;
-	int amount, resetloc;
+	long amount;
+	int resetloc;
 	int argstr_flags;
 	IF_BASH_PATTERN_SUBST(int workloc;)
 	IF_BASH_PATTERN_SUBST(int slash_pos;)
 	IF_BASH_PATTERN_SUBST(char *repl;)
 	int zero;
 	char *(*scan)(char*, char*, char*, char*, int, int);
+	char *p;
 
-	//bb_error_msg("subevalvar(p:'%s',varname:'%s',strloc:%d,subtype:%d,startloc:%d,varflags:%x,quotes:%d)",
-	//		p, varname, strloc, subtype, startloc, varflags, quotes);
+	//bb_error_msg("subevalvar(start:'%s',str:'%s',strloc:%d,startloc:%d,varflags:%x,quotes:%d)",
+	//		start, str, strloc, startloc, varflags, quotes);
 
 #if BASH_PATTERN_SUBST
 	/* For "${v/pattern/repl}", we must find the delimiter _before_
@@ -6933,7 +6980,7 @@ subevalvar(char *p, char *varname, int s
 	repl = NULL;
 	if (subtype == VSREPLACE || subtype == VSREPLACEALL) {
 		/* Find '/' and replace with NUL */
-		repl = p;
+		repl = start;
 		/* The pattern can't be empty.
 		 * IOW: if the first char after "${v//" is a slash,
 		 * it does not terminate the pattern - it's the first char of the pattern:
@@ -6958,17 +7005,17 @@ subevalvar(char *p, char *varname, int s
 		}
 	}
 #endif
-	argstr_flags = EXP_TILDE;
-	if (subtype != VSASSIGN
-	 && subtype != VSQUESTION
+	argstr_flags = (flag & EXP_DISCARD) | EXP_TILDE;
+	if (!str
 #if BASH_SUBSTR
 	 && subtype != VSSUBSTR
 #endif
 	) {
 		/* EXP_CASE keeps CTLESC's */
-		argstr_flags = EXP_TILDE | EXP_CASE;
+		argstr_flags |= EXP_CASE;
 	}
-	argstr(p, argstr_flags);
+	p = argstr(start, argstr_flags);
+
 	//bb_error_msg("str0:'%s'", (char *)stackblock() + strloc);
 #if BASH_PATTERN_SUBST
 	slash_pos = -1;
@@ -6976,32 +7023,34 @@ subevalvar(char *p, char *varname, int s
 		slash_pos = expdest - ((char *)stackblock() + strloc);
 		STPUTC('/', expdest);
 		//bb_error_msg("repl+1:'%s'", repl + 1);
-		argstr(repl + 1, EXP_TILDE); /* EXP_TILDE: echo "${v/x/~}" expands ~ ! */
+		p = argstr(repl + 1, (flag & EXP_DISCARD) | EXP_TILDE); /* EXP_TILDE: echo "${v/x/~}" expands ~ ! */
 		*repl = '/';
 	}
 #endif
-	STPUTC('\0', expdest);
-	argbackq = saveargbackq;
+	if (flag & EXP_DISCARD)
+		return p;
+
 	startp = (char *)stackblock() + startloc;
 	//bb_error_msg("str1:'%s'", (char *)stackblock() + strloc);
 
 	switch (subtype) {
 	case VSASSIGN:
-		setvar0(varname, startp);
-		amount = startp - expdest;
-		STADJUST(amount, expdest);
-		return startp;
+		setvar0(str, startp);
+
+		loc = startp;
+		goto out;
 
 	case VSQUESTION:
-		varunset(p, varname, startp, varflags);
+		varunset(start, str, startp, varflags);
 		/* NOTREACHED */
 
 #if BASH_SUBSTR
 	case VSSUBSTR: {
 		int pos, len, orig_len;
 		char *colon;
+		char *vstr;
 
-		loc = str = stackblock() + strloc;
+		loc = vstr = stackblock() + strloc;
 
 		/* Read POS in ${var:POS:LEN} */
 		colon = strchr(loc, ':');
@@ -7010,12 +7059,12 @@ subevalvar(char *p, char *varname, int s
 		if (colon) *colon = ':';
 
 		/* Read LEN in ${var:POS:LEN} */
-		len = str - startp - 1;
+		len = vstr - startp - 1;
 		/* *loc != '\0', guaranteed by parser */
 		if (quotes) {
 			char *ptr;
 			/* Adjust the length by the number of escapes */
-			for (ptr = startp; ptr < (str - 1); ptr++) {
+			for (ptr = startp; ptr < (vstr - 1); ptr++) {
 				if ((unsigned char)*ptr == CTLESC) {
 					len--;
 					ptr++;
@@ -7053,19 +7102,17 @@ subevalvar(char *p, char *varname, int s
 		if ((unsigned)len > (orig_len - pos))
 			len = orig_len - pos;
 
-		for (str = startp; pos; str++, pos--) {
-			if (quotes && (unsigned char)*str == CTLESC)
-				str++;
+		for (vstr = startp; pos; vstr++, pos--) {
+			if (quotes && (unsigned char)*vstr == CTLESC)
+				vstr++;
 		}
 		for (loc = startp; len; len--) {
-			if (quotes && (unsigned char)*str == CTLESC)
-				*loc++ = *str++;
-			*loc++ = *str++;
+			if (quotes && (unsigned char)*vstr == CTLESC)
+				*loc++ = *vstr++;
+			*loc++ = *vstr++;
 		}
 		*loc = '\0';
-		amount = loc - expdest;
-		STADJUST(amount, expdest);
-		return loc;
+		goto out;
 	}
 #endif /* BASH_SUBSTR */
 	}
@@ -7131,7 +7178,7 @@ subevalvar(char *p, char *varname, int s
 
 		/* If there's no pattern to match, return the expansion unmolested */
 		if (str[0] == '\0')
-			return NULL;
+			goto out1;
 
 		len = 0;
 		idx = startp;
@@ -7212,9 +7259,8 @@ subevalvar(char *p, char *varname, int s
 		startp = (char *)stackblock() + startloc;
 		memmove(startp, (char *)stackblock() + workloc, len + 1);
 		//bb_error_msg("startp:'%s'", startp);
-		amount = expdest - (startp + len);
-		STADJUST(-amount, expdest);
-		return startp;
+		loc = startp + len;
+		goto out;
 	}
 #endif /* BASH_PATTERN_SUBST */
 
@@ -7235,10 +7281,17 @@ subevalvar(char *p, char *varname, int s
 			loc = startp + (str - loc) - 1;
 		}
 		*loc = '\0';
-		amount = loc - expdest;
-		STADJUST(amount, expdest);
-	}
-	return loc;
+	} else
+		loc = str - 1;
+
+ out:
+	amount = loc - expdest;
+	STADJUST(amount, expdest);
+ out1:
+	/* Remove any recorded regions beyond start of variable */
+	removerecordregions(startloc);
+
+	return p;
 }
 
 /*
@@ -7263,12 +7316,18 @@ varvalue(char *name, int varflags, int f
 	ssize_t len = 0;
 	int sep;
 	int subtype = varflags & VSTYPE;
-	int discard = subtype == VSPLUS || subtype == VSLENGTH;
-	int quotes = (discard ? 0 : (flags & QUOTES_ESC)) | QUOTES_KEEPNUL;
-	int syntax;
+	int discard = (subtype == VSPLUS || subtype == VSLENGTH) | (flags & EXP_DISCARD);
+
+	if (!subtype) {
+		if (discard)
+			return -1;
 
+		raise_error_syntax("bad substitution");
+	}
+
+	flags |= EXP_KEEPNUL;
+	flags &= discard ? ~QUOTES_ESC : ~0;
 	sep = (flags & EXP_FULL) << CHAR_BIT;
-	syntax = quoted ? DQSYNTAX : BASESYNTAX;
 
 	switch (*name) {
 	case '$':
@@ -7285,7 +7344,7 @@ varvalue(char *name, int varflags, int f
 		if (num == 0)
 			return -1;
  numvar:
-		len = cvtnum(num);
+		len = cvtnum(num, flags);
 		goto check_1char_name;
 	case '-':
 		expdest = makestrspace(NOPTS, expdest);
@@ -7334,11 +7393,11 @@ varvalue(char *name, int varflags, int f
 		if (!ap)
 			return -1;
 		while ((p = *ap++) != NULL) {
-			len += strtodest(p, syntax, quotes);
+			len += strtodest(p, flags);
 
 			if (*ap && sep) {
 				len++;
-				memtodest(&sepc, 1, syntax, quotes);
+				memtodest(&sepc, 1, flags);
 			}
 		}
 		break;
@@ -7365,7 +7424,7 @@ varvalue(char *name, int varflags, int f
 		if (!p)
 			return -1;
 
-		len = strtodest(p, syntax, quotes);
+		len = strtodest(p, flags);
 #if ENABLE_UNICODE_SUPPORT
 		if (subtype == VSLENGTH && len > 0) {
 			reinit_unicode_for_ash();
@@ -7381,6 +7440,7 @@ varvalue(char *name, int varflags, int f
 
 	if (discard)
 		STADJUST(-len, expdest);
+
 	return len;
 }
 
@@ -7393,18 +7453,16 @@ evalvar(char *p, int flag)
 {
 	char varflags;
 	char subtype;
-	int quoted;
 	char *var;
 	int patloc;
 	int startloc;
 	ssize_t varlen;
+	int discard;
+	int quoted;
 
 	varflags = (unsigned char) *p++;
 	subtype = varflags & VSTYPE;
 
-	if (!subtype)
-		raise_error_syntax("bad substitution");
-
 	quoted = flag & EXP_QUOTED;
 	var = p;
 	startloc = expdest - (char *)stackblock();
@@ -7415,56 +7473,43 @@ evalvar(char *p, int flag)
 	if (varflags & VSNUL)
 		varlen--;
 
-	if (subtype == VSPLUS) {
-		varlen = -1 - varlen;
-		goto vsplus;
-	}
+	discard = varlen < 0 ? EXP_DISCARD : 0;
 
-	if (subtype == VSMINUS) {
- vsplus:
-		if (varlen < 0) {
-			argstr(
-				p,
-				flag | EXP_TILDE | EXP_WORD
-			);
-			goto end;
-		}
+	switch (subtype) {
+	case VSPLUS:
+		discard ^= EXP_DISCARD;
+		/* fall through */
+	case 0:
+	case VSMINUS:
+		p = argstr(p, flag | EXP_TILDE | EXP_WORD | (discard ^ EXP_DISCARD));
 		goto record;
-	}
 
-	if (subtype == VSASSIGN || subtype == VSQUESTION) {
-		if (varlen >= 0)
+	case VSASSIGN:
+	case VSQUESTION:
+		p = subevalvar(p, var, 0, startloc, varflags,
+			(flag & ~QUOTES_ESC) | (discard ^ EXP_DISCARD));
+
+		if ((flag | ~discard) & EXP_DISCARD)
 			goto record;
 
-		subevalvar(p, var, 0, subtype, startloc, varflags,
-			   flag & ~QUOTES_ESC);
 		varflags &= ~VSNUL;
-		/*
-		 * Remove any recorded regions beyond
-		 * start of variable
-		 */
-		removerecordregions(startloc);
+		subtype = VSNORMAL;
 		goto again;
 	}
 
-	if (varlen < 0 && uflag)
+	if ((discard & ~flag) && uflag)
 		varunset(p, var, 0, 0);
 
 	if (subtype == VSLENGTH) {
-		cvtnum(varlen > 0 ? varlen : 0);
-		goto record;
+		p++;
+		if (flag & EXP_DISCARD)
+			return p;
+		cvtnum(varlen > 0 ? varlen : 0, flag);
+		goto really_record;
 	}
 
-	if (subtype == VSNORMAL) {
- record:
-		if (quoted) {
-			quoted = *var == '@' && shellparam.nparam;
-			if (!quoted)
-				goto end;
-		}
-		recordregion(startloc, expdest - (char *)stackblock(), quoted);
-		goto end;
-	}
+	if (subtype == VSNORMAL)
+		goto record;
 
 #if DEBUG
 	switch (subtype) {
@@ -7485,44 +7530,29 @@ evalvar(char *p, int flag)
 	}
 #endif
 
-	if (varlen >= 0) {
+	flag |= discard;
+	if (!(flag & EXP_DISCARD)) {
 		/*
 		 * Terminate the string and start recording the pattern
 		 * right after it
 		 */
 		STPUTC('\0', expdest);
-		patloc = expdest - (char *)stackblock();
-		if (NULL == subevalvar(p, /* varname: */ NULL, patloc, subtype,
-				startloc, varflags, flag)) {
-			int amount = expdest - (
-				(char *)stackblock() + patloc - 1
-			);
-			STADJUST(-amount, expdest);
-		}
-		/* Remove any recorded regions beyond start of variable */
-		removerecordregions(startloc);
-		goto record;
 	}
 
- end:
-	if (subtype != VSNORMAL) {      /* skip to end of alternative */
-		int nesting = 1;
-		for (;;) {
-			unsigned char c = *p++;
-			if (c == CTLESC)
-				p++;
-			else if (c == CTLBACKQ) {
-				if (varlen >= 0)
-					argbackq = argbackq->next;
-			} else if (c == CTLVAR) {
-				if ((*p++ & VSTYPE) != VSNORMAL)
-					nesting++;
-			} else if (c == CTLENDVAR) {
-				if (--nesting == 0)
-					break;
-			}
-		}
+	patloc = expdest - (char *)stackblock();
+	p = subevalvar(p, NULL, patloc, startloc, varflags, flag);
+
+ record:
+	if ((flag | discard) & EXP_DISCARD)
+		return p;
+
+ really_record:
+	if (quoted) {
+		quoted = *var == '@' && shellparam.nparam;
+		if (!quoted)
+			return p;
 	}
+	recordregion(startloc, expdest - (char *)stackblock(), quoted);
 	return p;
 }
 
@@ -7935,13 +7965,11 @@ expandarg(union node *arg, struct arglis
 	STARTSTACKSTR(expdest);
 	TRACE(("expandarg: argstr('%s',flags:%x)\n", arg->narg.text, flag));
 	argstr(arg->narg.text, flag);
-	p = _STPUTC('\0', expdest);
-	expdest = p - 1;
 	if (arglist == NULL) {
 		/* here document expanded */
 		goto out;
 	}
-	p = grabstackstr(p);
+	p = grabstackstr(expdest);
 	TRACE(("expandarg: p:'%s'\n", p));
 	exparg.lastp = &exparg.list;
 	/*
@@ -7972,10 +8000,9 @@ expandarg(union node *arg, struct arglis
  * Expand shell variables and backquotes inside a here document.
  */
 static void
-expandhere(union node *arg, int fd)
+expandhere(union node *arg)
 {
 	expandarg(arg, (struct arglist *)NULL, EXP_QUOTED);
-	full_write(fd, stackblock(), expdest - (char *)stackblock());
 }
 
 /*
@@ -8003,7 +8030,6 @@ casematch(union node *pattern, char *val
 	argbackq = pattern->narg.backquote;
 	STARTSTACKSTR(expdest);
 	argstr(pattern->narg.text, EXP_TILDE | EXP_CASE);
-	STACKSTRNUL(expdest);
 	ifsfree();
 	result = patmatch(stackblock(), val);
 	popstackmark(&smark);
@@ -8047,7 +8073,7 @@ struct cmdentry {
 #define DO_ABS          0x02    /* checks absolute paths */
 #define DO_NOFUNC       0x04    /* don't return shell functions, for command */
 #define DO_ALTPATH      0x08    /* using alternate path */
-#define DO_ALTBLTIN     0x20    /* %builtin in alt. path */
+#define DO_REGBLTIN     0x10    /* regular built-ins and functions only */
 
 static void find_command(char *, struct cmdentry *, int, const char *);
 
@@ -8167,13 +8193,13 @@ static void shellexec(char *prog, char *
 	} else {
  try_PATH:
 		e = ENOENT;
-		while ((cmdname = path_advance(&path, prog)) != NULL) {
+		while (padvance(&path, argv[0]) >= 0) {
+			cmdname = stackblock();
 			if (--idx < 0 && pathopt == NULL) {
 				tryexec(IF_FEATURE_SH_STANDALONE(-1,) cmdname, argv, envp);
 				if (errno != ENOENT && errno != ENOTDIR)
 					e = errno;
 			}
-			stunalloc(cmdname);
 		}
 	}
 
@@ -8192,7 +8218,7 @@ static void shellexec(char *prog, char *
 	exitstatus = exerrno;
 	TRACE(("shellexec failed for %s, errno %d, suppress_int %d\n",
 		prog, e, suppress_int));
-	ash_msg_and_raise(EXEXIT, "%s: %s", prog, errmsg(e, "not found"));
+	ash_msg_and_raise(EXEND, "%s: %s", prog, errmsg(e, "not found"));
 	/* NOTREACHED */
 }
 
@@ -8206,18 +8232,17 @@ printentry(struct tblentry *cmdp)
 	idx = cmdp->param.index;
 	path = pathval();
 	do {
-		name = path_advance(&path, cmdp->cmdname);
-		stunalloc(name);
+		padvance(&path, cmdp->cmdname);
 	} while (--idx >= 0);
+	name = stackblock();
 	out1fmt("%s%s\n", name, (cmdp->rehash ? "*" : nullstr));
 }
 
 /*
- * Clear out command entries.  The argument specifies the first entry in
- * PATH which has changed.
+ * Clear out command entries.
  */
 static void
-clearcmdentry(int firstchange)
+clearcmdentry(void)
 {
 	struct tblentry **tblp;
 	struct tblentry **pp;
@@ -8227,10 +8252,11 @@ clearcmdentry(int firstchange)
 	for (tblp = cmdtable; tblp < &cmdtable[CMDTABLESIZE]; tblp++) {
 		pp = tblp;
 		while ((cmdp = *pp) != NULL) {
-			if ((cmdp->cmdtype == CMDNORMAL &&
-			     cmdp->param.index >= firstchange)
-			 || (cmdp->cmdtype == CMDBUILTIN &&
-			     builtinloc >= firstchange)
+			if (cmdp->cmdtype == CMDNORMAL
+			 || (cmdp->cmdtype == CMDBUILTIN
+			    && !IS_BUILTIN_REGULAR(cmdp->param.cmd)
+			    && builtinloc > 0
+			    )
 			) {
 				*pp = cmdp->next;
 				free(cmdp);
@@ -8330,7 +8356,7 @@ hashcmd(int argc UNUSED_PARAM, char **ar
 	char *name;
 
 	if (nextopt("r") != '\0') {
-		clearcmdentry(0);
+		clearcmdentry();
 		return 0;
 	}
 
@@ -8349,7 +8375,11 @@ hashcmd(int argc UNUSED_PARAM, char **ar
 		cmdp = cmdlookup(name, 0);
 		if (cmdp != NULL
 		 && (cmdp->cmdtype == CMDNORMAL
-		     || (cmdp->cmdtype == CMDBUILTIN && builtinloc >= 0))
+		    || (cmdp->cmdtype == CMDBUILTIN
+			&& !IS_BUILTIN_REGULAR(cmdp->param.cmd)
+			&& builtinloc > 0
+			)
+		    )
 		) {
 			delete_cmd_entry();
 		}
@@ -8391,42 +8421,28 @@ hashcd(void)
  * Called with interrupts off.
  */
 static void FAST_FUNC
-changepath(const char *new)
+changepath(const char *newval)
 {
-	const char *old;
-	int firstchange;
+	const char *new;
 	int idx;
-	int idx_bltin;
+	int bltin;
 
-	old = pathval();
-	firstchange = 9999;     /* assume no change */
+	new = newval;
 	idx = 0;
-	idx_bltin = -1;
+	bltin = -1;
 	for (;;) {
-		if (*old != *new) {
-			firstchange = idx;
-			if ((*old == '\0' && *new == ':')
-			 || (*old == ':' && *new == '\0')
-			) {
-				firstchange++;
-			}
-			old = new;      /* ignore subsequent differences */
+		if (*new == '%' && prefix(new + 1, "builtin")) {
+			bltin = idx;
+			break;
 		}
-		if (*new == '\0')
+		new = strchr(new, ':');
+		if (!new)
 			break;
-		if (*new == '%' && idx_bltin < 0 && prefix(new + 1, "builtin"))
-			idx_bltin = idx;
-		if (*new == ':')
-			idx++;
+		idx++;
 		new++;
-		old++;
 	}
-	if (builtinloc < 0 && idx_bltin >= 0)
-		builtinloc = idx_bltin;             /* zap builtins */
-	if (builtinloc >= 0 && idx_bltin < 0)
-		firstchange = 0;
-	clearcmdentry(firstchange);
-	builtinloc = idx_bltin;
+	builtinloc = bltin;
+	clearcmdentry();
 }
 enum {
 	TEOF,
@@ -8601,9 +8617,9 @@ describe_command(char *command, const ch
 			p = command;
 		} else {
 			do {
-				p = path_advance(&path, command);
-				stunalloc(p);
+				padvance(&path, command);
 			} while (--j >= 0);
+			p = stackblock();
 		}
 		if (describe_command_verbose) {
 			out1fmt(" is %s", p);
@@ -8662,25 +8678,44 @@ typecmd(int argc UNUSED_PARAM, char **ar
 	return err;
 }
 
+static struct strlist *
+fill_arglist(struct arglist *arglist, union node **argpp)
+{
+	struct strlist **lastp = arglist->lastp;
+	union node *argp;
+
+	while ((argp = *argpp) != NULL) {
+		expandarg(argp, arglist, EXP_FULL | EXP_TILDE);
+		*argpp = argp->narg.next;
+		if (*lastp)
+			break;
+	}
+
+	return *lastp;
+}
+
 #if ENABLE_ASH_CMDCMD
 /* Is it "command [-p] PROG ARGS" bltin, no other opts? Return ptr to "PROG" if yes */
-static char **
-parse_command_args(char **argv, const char **path)
+static int
+parse_command_args(struct arglist *arglist, union node **argpp, const char **path)
 {
+	struct strlist *sp = arglist->list;
 	char *cp, c;
 
 	for (;;) {
-		cp = *++argv;
-		if (!cp)
-			return NULL;
+		sp = sp->next ? sp->next : fill_arglist(arglist, argpp);
+		if (!sp)
+			return 0;
+		cp = sp->text;
 		if (*cp++ != '-')
 			break;
 		c = *cp++;
 		if (!c)
 			break;
 		if (c == '-' && !*cp) {
-			if (!*++argv)
-				return NULL;
+			if (!sp->next && !fill_arglist(arglist, argpp))
+				return 0;
+			sp = sp->next;
 			break;
 		}
 		do {
@@ -8690,12 +8725,14 @@ parse_command_args(char **argv, const ch
 				break;
 			default:
 				/* run 'typecmd' for other options */
-				return NULL;
+				return 0;
 			}
 			c = *cp++;
 		} while (c);
 	}
-	return argv;
+
+	arglist->list = sp;
+	return DO_NOFUNC;
 }
 
 static int FAST_FUNC
@@ -9035,6 +9072,7 @@ defun(union node *func)
 #define SKIPBREAK      (1 << 0)
 #define SKIPCONT       (1 << 1)
 #define SKIPFUNC       (1 << 2)
+#define SKIPFUNCDEF    (1 << 3)
 static smallint evalskip;       /* set to SKIPxxx if we are skipping commands */
 static int skipcount;           /* number of levels to skip */
 static int loopnest;            /* current loop nesting level */
@@ -9055,12 +9093,17 @@ dotrap(void)
 {
 	uint8_t *g;
 	int sig;
-	uint8_t last_status;
+	int status, last_status;
 
 	if (!pending_sig)
 		return;
 
-	last_status = exitstatus;
+	status = savestatus;
+	last_status = status;
+	if (status < 0) {
+		status = exitstatus;
+		savestatus = status;
+	}
 	pending_sig = 0;
 	barrier();
 
@@ -9087,8 +9130,11 @@ dotrap(void)
 		if (!p)
 			continue;
 		evalstring(p, 0);
+		if (evalskip != SKIPFUNC)
+			exitstatus = status;
 	}
-	exitstatus = last_status;
+
+	savestatus = last_status;
 	TRACE(("dotrap returns\n"));
 }
 
@@ -9226,9 +9272,9 @@ evaltree(union node *n, int flags)
 	dotrap();
 
 	if (checkexit & status)
-		raise_exception(EXEXIT);
+		raise_exception(EXEND);
 	if (flags & EV_EXIT)
-		raise_exception(EXEXIT);
+		raise_exception(EXEND);
 
 	popstackmark(&smark);
 	TRACE(("leaving evaltree (no interrupts)\n"));
@@ -9434,11 +9480,10 @@ expredir(union node *n)
 		case NFROMFD:
 		case NTOFD: /* >& */
 			if (redir->ndup.vname) {
-				expandarg(redir->ndup.vname, &fn, EXP_FULL | EXP_TILDE);
+				expandarg(redir->ndup.vname, &fn, EXP_TILDE | EXP_REDIR);
 				if (fn.list == NULL)
 					ash_msg_and_raise_error("redir error");
 #if BASH_REDIR_OUTPUT
-//FIXME: we used expandarg with different args!
 				if (!isdigit_str9(fn.list->text)) {
 					/* >&file, not >&fd */
 					if (redir->nfile.fd != 1) /* 123>&file - BAD */
@@ -9523,6 +9568,11 @@ evalpipe(union node *n, int flags)
 	return status;
 }
 
+/* setinteractive needs this forward reference */
+#if EDITING_HAS_get_exe_name
+static const char *get_builtin_name(int i) FAST_FUNC;
+#endif
+
 /*
  * Controls whether the shell is interactive or not.
  */
@@ -9554,8 +9604,12 @@ setinteractive(int on)
 		}
 #endif
 #if ENABLE_FEATURE_EDITING
-		if (!line_input_state)
+		if (!line_input_state) {
 			line_input_state = new_line_input_t(FOR_SHELL | WITH_PATH_LOOKUP);
+# if EDITING_HAS_get_exe_name
+			line_input_state->get_exe_name = get_builtin_name;
+# endif
+		}
 #endif
 	}
 }
@@ -9649,18 +9703,23 @@ poplocalvars(int keep)
  * Create a new localvar environment.
  */
 static struct localvar_list *
-pushlocalvars(void)
+pushlocalvars(int push)
 {
 	struct localvar_list *ll;
+	struct localvar_list *top;
+
+	top = localvar_stack;
+	if (!push)
+		goto out;
 
 	INT_OFF;
 	ll = ckzalloc(sizeof(*ll));
 	/*ll->lv = NULL; - zalloc did it */
-	ll->next = localvar_stack;
+	ll->next = top;
 	localvar_stack = ll;
 	INT_ON;
-
-	return ll->next;
+ out:
+	return top;
 }
 
 static void
@@ -9707,7 +9766,7 @@ evalfun(struct funcnode *func, int argc,
 	shellparam = saveparam;
 	exception_handler = savehandler;
 	INT_ON;
-	evalskip &= ~SKIPFUNC;
+	evalskip &= ~(SKIPFUNC | SKIPFUNCDEF);
 	return e;
 }
 
@@ -9719,7 +9778,7 @@ evalfun(struct funcnode *func, int argc,
  * (options will be restored on return from the function).
  */
 static void
-mklocal(char *name)
+mklocal(char *name, int flags)
 {
 	struct localvar *lvp;
 	struct var **vpp;
@@ -9756,9 +9815,9 @@ mklocal(char *name)
 		if (vp == NULL) {
 			/* variable did not exist yet */
 			if (eq)
-				vp = setvareq(name, VSTRFIXED);
+				vp = setvareq(name, VSTRFIXED | flags);
 			else
-				vp = setvar(name, NULL, VSTRFIXED);
+				vp = setvar(name, NULL, VSTRFIXED | flags);
 			lvp->flags = VUNSET;
 		} else {
 			lvp->text = vp->var_text;
@@ -9768,7 +9827,7 @@ mklocal(char *name)
 			 */
 			vp->flags |= VSTRFIXED|VTEXTFIXED;
 			if (eq)
-				setvareq(name, 0);
+				setvareq(name, flags);
 			else
 				/* "local VAR" unsets VAR: */
 				setvar0(name, NULL);
@@ -9794,7 +9853,7 @@ localcmd(int argc UNUSED_PARAM, char **a
 
 	argv = argptr;
 	while ((name = *argv++) != NULL) {
-		mklocal(name);
+		mklocal(name, 0);
 	}
 	return 0;
 }
@@ -9852,12 +9911,23 @@ execcmd(int argc UNUSED_PARAM, char **ar
 static int FAST_FUNC
 returncmd(int argc UNUSED_PARAM, char **argv)
 {
+	int skip;
+	int status;
+
 	/*
 	 * If called outside a function, do what ksh does;
 	 * skip the rest of the file.
 	 */
-	evalskip = SKIPFUNC;
-	return argv[1] ? number(argv[1]) : exitstatus;
+	if (argv[1]) {
+		skip = SKIPFUNC;
+		status = number(argv[1]);
+	} else {
+		skip = SKIPFUNCDEF;
+		status = exitstatus;
+	}
+	evalskip = skip;
+
+	return status;
 }
 
 /* Forward declarations for builtintab[] */
@@ -9944,7 +10014,7 @@ static const struct builtincmd builtinta
 #if ENABLE_ASH_GETOPTS
 	{ BUILTIN_REGULAR       "getopts" , getoptscmd },
 #endif
-	{ BUILTIN_NOSPEC        "hash"    , hashcmd    },
+	{ BUILTIN_REGULAR       "hash"    , hashcmd    },
 #if ENABLE_ASH_HELP
 	{ BUILTIN_NOSPEC        "help"    , helpcmd    },
 #endif
@@ -9962,7 +10032,7 @@ static const struct builtincmd builtinta
 #if ENABLE_ASH_PRINTF
 	{ BUILTIN_REGULAR       "printf"  , printfcmd  },
 #endif
-	{ BUILTIN_NOSPEC        "pwd"     , pwdcmd     },
+	{ BUILTIN_REGULAR       "pwd"     , pwdcmd     },
 	{ BUILTIN_REGULAR       "read"    , readcmd    },
 	{ BUILTIN_SPEC_REG_ASSG "readonly", exportcmd  },
 	{ BUILTIN_SPEC_REG      "return"  , returncmd  },
@@ -9977,8 +10047,8 @@ static const struct builtincmd builtinta
 	{ BUILTIN_SPEC_REG      "times"   , timescmd   },
 	{ BUILTIN_SPEC_REG      "trap"    , trapcmd    },
 	{ BUILTIN_REGULAR       "true"    , truecmd    },
-	{ BUILTIN_NOSPEC        "type"    , typecmd    },
-	{ BUILTIN_NOSPEC        "ulimit"  , ulimitcmd  },
+	{ BUILTIN_REGULAR       "type"    , typecmd    },
+	{ BUILTIN_REGULAR       "ulimit"  , ulimitcmd  },
 	{ BUILTIN_REGULAR       "umask"   , umaskcmd   },
 #if ENABLE_ASH_ALIAS
 	{ BUILTIN_REGULAR       "unalias" , unaliascmd },
@@ -10023,6 +10093,14 @@ find_builtin(const char *name)
 	return bp;
 }
 
+#if EDITING_HAS_get_exe_name
+static const char * FAST_FUNC
+get_builtin_name(int i)
+{
+	return /*i >= 0 &&*/ i < ARRAY_SIZE(builtintab) ? builtintab[i].name + 1 : NULL;
+}
+#endif
+
 /*
  * Execute a simple command.
  */
@@ -10046,7 +10124,7 @@ static int
 evalcommand(union node *cmd, int flags)
 {
 	static const struct builtincmd null_bltin = {
-		"\0\0", bltincmd /* why three NULs? */
+		BUILTIN_REGULAR "", bltincmd
 	};
 	struct localvar_list *localvar_stop;
 	struct parsefile *file_stop;
@@ -10056,15 +10134,19 @@ evalcommand(union node *cmd, int flags)
 	struct arglist varlist;
 	char **argv;
 	int argc;
+	struct strlist *osp;
 	const struct strlist *sp;
 	struct cmdentry cmdentry;
 	struct job *jp;
 	char *lastarg;
 	const char *path;
 	int spclbltin;
+	int cmd_flag;
 	int status;
 	char **nargv;
 	smallint cmd_is_exec;
+	int vflags;
+	int vlocal;
 
 	errlinno = lineno = cmd->ncmd.linno;
 	if (funcline)
@@ -10072,7 +10154,6 @@ evalcommand(union node *cmd, int flags)
 
 	/* First expand the arguments. */
 	TRACE(("evalcommand(0x%lx, %d) called\n", (long)cmd, flags));
-	localvar_stop = pushlocalvars();
 	file_stop = g_parsefile;
 	back_exitstatus = 0;
 
@@ -10083,28 +10164,60 @@ evalcommand(union node *cmd, int flags)
 	arglist.lastp = &arglist.list;
 	*arglist.lastp = NULL;
 
+	cmd_flag = 0;
+	cmd_is_exec = 0;
+	spclbltin = -1;
+	vflags = 0;
+	vlocal = 0;
+	path = NULL;
+
 	argc = 0;
-	if (cmd->ncmd.args) {
-		struct builtincmd *bcmd;
-		smallint pseudovarflag;
-
-		bcmd = find_builtin(cmd->ncmd.args->narg.text);
-		pseudovarflag = bcmd && IS_BUILTIN_ASSIGN(bcmd);
-
-		for (argp = cmd->ncmd.args; argp; argp = argp->narg.next) {
-			struct strlist **spp;
-
-			spp = arglist.lastp;
-			if (pseudovarflag && isassignment(argp->narg.text))
-				expandarg(argp, &arglist, EXP_VARTILDE);
-			else
-				expandarg(argp, &arglist, EXP_FULL | EXP_TILDE);
+	argp = cmd->ncmd.args;
+	osp = fill_arglist(&arglist, &argp);
+	if (osp) {
+		int pseudovarflag = 0;
 
-			for (sp = *spp; sp; sp = sp->next)
-				argc++;
+		for (;;) {
+			find_command(arglist.list->text, &cmdentry,
+					cmd_flag | DO_REGBLTIN, pathval());
+
+			vlocal++;
+
+			/* implement bltin and command here */
+			if (cmdentry.cmdtype != CMDBUILTIN)
+				break;
+
+			pseudovarflag = IS_BUILTIN_ASSIGN(cmdentry.u.cmd);
+			if (spclbltin < 0) {
+				spclbltin = IS_BUILTIN_SPECIAL(cmdentry.u.cmd);
+				vlocal = !spclbltin;
+			}
+			cmd_is_exec = cmdentry.u.cmd == EXECCMD;
+#if ENABLE_ASH_CMDCMD
+			if (cmdentry.u.cmd != COMMANDCMD)
+				break;
+
+			cmd_flag = parse_command_args(&arglist, &argp, &path);
+			if (!cmd_flag)
+#endif
+				break;
 		}
+
+		for (; argp; argp = argp->narg.next)
+			expandarg(argp, &arglist,
+					pseudovarflag &&
+					isassignment(argp->narg.text) ?
+					EXP_VARTILDE : EXP_FULL | EXP_TILDE);
+
+		for (sp = arglist.list; sp; sp = sp->next)
+			argc++;
+
+		if (cmd_is_exec && argc > 1)
+			vflags = VEXPORT;
 	}
 
+	localvar_stop = pushlocalvars(vlocal);
+
 	/* Reserve one extra spot at the front for shellexec. */
 	nargv = stalloc(sizeof(char *) * (argc + 2));
 	argv = ++nargv;
@@ -10132,23 +10245,27 @@ evalcommand(union node *cmd, int flags)
 	}
 	status = redirectsafe(cmd->ncmd.redirect, REDIR_PUSH | REDIR_SAVEFD2);
 
-	path = vpath.var_text;
+	if (status) {
+ bail:
+		exitstatus = status;
+
+		/* We have a redirection error. */
+		if (spclbltin > 0)
+			raise_exception(EXERROR);
+
+		goto out;
+	}
+
 	for (argp = cmd->ncmd.assign; argp; argp = argp->narg.next) {
 		struct strlist **spp;
-		char *p;
 
 		spp = varlist.lastp;
 		expandarg(argp, &varlist, EXP_VARTILDE);
 
-		mklocal((*spp)->text);
-
-		/*
-		 * Modify the command lookup path, if a PATH= assignment
-		 * is present
-		 */
-		p = (*spp)->text;
-		if (varcmp(p, path) == 0)
-			path = p;
+		if (vlocal)
+			mklocal((*spp)->text, VEXPORT);
+		else
+			setvareq((*spp)->text, vflags);
 	}
 
 	/* Print the command if xflag is set. */
@@ -10187,62 +10304,23 @@ evalcommand(union node *cmd, int flags)
 		safe_write(preverrout_fd, "\n", 1);
 	}
 
-	cmd_is_exec = 0;
-	spclbltin = -1;
-
 	/* Now locate the command. */
-	if (argc) {
-		int cmd_flag = DO_ERR;
-#if ENABLE_ASH_CMDCMD
-		const char *oldpath = path + 5;
-#endif
-		path += 5;
-		for (;;) {
-			find_command(argv[0], &cmdentry, cmd_flag, path);
-			if (cmdentry.cmdtype == CMDUNKNOWN) {
-				flush_stdout_stderr();
-				status = 127;
-				goto bail;
-			}
-
-			/* implement bltin and command here */
-			if (cmdentry.cmdtype != CMDBUILTIN)
-				break;
-			if (spclbltin < 0)
-				spclbltin = IS_BUILTIN_SPECIAL(cmdentry.u.cmd);
-			if (cmdentry.u.cmd == EXECCMD)
-				cmd_is_exec = 1;
-#if ENABLE_ASH_CMDCMD
-			if (cmdentry.u.cmd == COMMANDCMD) {
-				path = oldpath;
-				nargv = parse_command_args(argv, &path);
-				if (!nargv)
-					break;
-				/* It's "command [-p] PROG ARGS" (that is, no -Vv).
-				 * nargv => "PROG". path is updated if -p.
-				 */
-				argc -= nargv - argv;
-				argv = nargv;
-				cmd_flag |= DO_NOFUNC;
-			} else
-#endif
-				break;
-		}
+	if (cmdentry.cmdtype != CMDBUILTIN
+	 || !(IS_BUILTIN_REGULAR(cmdentry.u.cmd))
+	) {
+		path = path ? path : pathval();
+		find_command(argv[0], &cmdentry, cmd_flag | DO_ERR, path);
 	}
 
-	if (status) {
- bail:
-		exitstatus = status;
-
-		/* We have a redirection error. */
-		if (spclbltin > 0)
-			raise_exception(EXERROR);
-
-		goto out;
-	}
+	jp = NULL;
 
 	/* Execute the command. */
 	switch (cmdentry.cmdtype) {
+	case CMDUNKNOWN:
+		status = 127;
+		flush_stdout_stderr();
+		goto bail;
+
 	default: {
 
 #if ENABLE_FEATURE_SH_STANDALONE \
@@ -10269,7 +10347,7 @@ evalcommand(union node *cmd, int flags)
 			 * and/or wait for user input ineligible for NOFORK:
 			 * for example, "yes" or "rm" (rm -i waits for input).
 			 */
-			status = run_nofork_applet(applet_no, argv);
+			exitstatus = run_nofork_applet(applet_no, argv);
 			environ = sv_environ;
 			/*
 			 * Try enabling NOFORK for "yes" applet.
@@ -10295,52 +10373,35 @@ evalcommand(union node *cmd, int flags)
 			jp = makejob(/*cmd,*/ 1);
 			if (forkshell(jp, cmd, FORK_FG) != 0) {
 				/* parent */
-				status = waitforjob(jp);
-				INT_ON;
-				TRACE(("forked child exited with %d\n", status));
 				break;
 			}
 			/* child */
 			FORCE_INT_ON;
 			/* fall through to exec'ing external program */
 		}
-		listsetvar(varlist.list, VEXPORT|VSTACK);
 		shellexec(argv[0], argv, path, cmdentry.u.index);
 		/* NOTREACHED */
 	} /* default */
 	case CMDBUILTIN:
-		if (spclbltin > 0 || argc == 0) {
-			poplocalvars(1);
-			if (cmd_is_exec && argc > 1)
-				listsetvar(varlist.list, VEXPORT);
-		}
-
-		/* Tight loop with builtins only:
-		 * "while kill -0 $child; do true; done"
-		 * will never exit even if $child died, unless we do this
-		 * to reap the zombie and make kill detect that it's gone: */
-		dowait(DOWAIT_NONBLOCK, NULL);
-
-		if (evalbltin(cmdentry.u.cmd, argc, argv, flags)) {
-			if (exception_type == EXERROR && spclbltin <= 0) {
-				FORCE_INT_ON;
-				goto readstatus;
-			}
+		if (evalbltin(cmdentry.u.cmd, argc, argv, flags)
+		 && !(exception_type == EXERROR && spclbltin <= 0)
+		) {
  raise:
 			longjmp(exception_handler->loc, 1);
 		}
-		goto readstatus;
+		break;
 
 	case CMDFUNCTION:
-		/* See above for the rationale */
-		dowait(DOWAIT_NONBLOCK, NULL);
 		if (evalfun(cmdentry.u.func, argc, argv, flags))
 			goto raise;
- readstatus:
-		status = exitstatus;
 		break;
 	} /* switch */
 
+	status = waitforjob(jp);
+	if (jp)
+		TRACE(("forked child exited with %d\n", status));
+	FORCE_INT_ON;
+
  out:
 	if (cmd->ncmd.redirect)
 		popredir(/*drop:*/ cmd_is_exec);
@@ -10812,6 +10873,12 @@ struct synstack {
 	struct synstack *next;
 };
 
+static int
+pgetc_top(struct synstack *stack)
+{
+	return stack->syntax == SQSYNTAX ? pgetc() : pgetc_eatbnl();
+}
+
 static void
 synstack_push(struct synstack **stack, struct synstack *next, int syntax)
 {
@@ -10989,8 +11056,12 @@ chkmail(void)
 	mpath = mpathset() ? mpathval() : mailval();
 	new_hash = 0;
 	for (;;) {
-		p = path_advance(&mpath, nullstr);
-		if (p == NULL)
+		int len;
+
+		len = padvance_magic(&mpath, nullstr, 2);
+		if (!len)
+			break;
+		p = stackblock();
 			break;
 		if (*p == '\0')
 			continue;
@@ -11521,7 +11592,7 @@ list(int nlflag)
 
 	n1 = NULL;
 	for (;;) {
-		switch (peektoken()) {
+		switch (readtoken()) {
 		case TNL:
 			if (!(nlflag & 1))
 				break;
@@ -11532,9 +11603,12 @@ list(int nlflag)
 			if (!n1 && (nlflag & 1))
 				n1 = NODE_EOF;
 			parseheredoc();
+			tokpushback++;
+			lasttoken = TEOF;
 			return n1;
 		}
 
+		tokpushback++;
 		checkkwd = CHKNL | CHKKWD | CHKALIAS;
 		if (nlflag == 2 && ((1 << peektoken()) & tokendlist))
 			return n1;
@@ -12177,7 +12251,7 @@ readtoken1(int c, int syntax, char *eofm
 			}
 			USTPUTC(c, out);
 			nlprompt();
-			c = pgetc();
+			c = pgetc_top(synstack);
 			goto loop;              /* continue outer loop */
 		case CWORD:
 			USTPUTC(c, out);
@@ -12209,8 +12283,6 @@ readtoken1(int c, int syntax, char *eofm
 				USTPUTC(CTLESC, out);
 				USTPUTC('\\', out);
 				pungetc();
-			} else if (c == '\n') {
-				nlprompt();
 			} else {
 				if (pssyntax && c == '$') {
 					USTPUTC(CTLESC, out);
@@ -12330,7 +12402,7 @@ readtoken1(int c, int syntax, char *eofm
 			IF_ASH_ALIAS(if (c != PEOA))
 				USTPUTC(c, out);
 		}
-		c = pgetc();
+		c = pgetc_top(synstack);
 	} /* for (;;) */
  endword:
 
@@ -12393,7 +12465,13 @@ checkend: {
 		for (p = eofmark; STPUTC(c, out), *p; p++) {
 			if (c != *p)
 				goto more_heredoc;
-
+			/* FIXME: fails for backslash-newlined terminator:
+			 * cat <<EOF
+			 * ...
+			 * EO\
+			 * F
+			 * (see heredoc_bkslash_newline2.tests)
+			 */
 			c = pgetc_without_PEOA();
 		}
 
@@ -12564,7 +12642,7 @@ parsesub: {
 			do {
 				STPUTC(c, out);
 				c = pgetc_eatbnl();
-			} while (isdigit(c));
+			} while (!subtype && isdigit(c));
 		} else if (c != '}') {
 			/* $[{[#]]<specialchar>[}] */
 			int cc = c;
@@ -12695,6 +12773,7 @@ parsebackq: {
 	union node *n;
 	char *str;
 	size_t savelen;
+	struct heredoc *saveheredoclist;
 	smallint saveprompt = 0;
 
 	str = NULL;
@@ -12770,6 +12849,9 @@ parsebackq: {
 	*nlpp = stzalloc(sizeof(**nlpp));
 	/* (*nlpp)->next = NULL; - stzalloc did it */
 
+	saveheredoclist = heredoclist;
+	heredoclist = NULL;
+
 	if (oldstyle) {
 		saveprompt = doprompt;
 		doprompt = 0;
@@ -12779,21 +12861,22 @@ parsebackq: {
 
 	if (oldstyle)
 		doprompt = saveprompt;
-	else if (readtoken() != TRP)
-		raise_error_unexpected_syntax(TRP);
+	else {
+		if (readtoken() != TRP)
+			raise_error_unexpected_syntax(TRP);
+		setinputstring(nullstr);
+	}
+
+	parseheredoc();
+	heredoclist = saveheredoclist;
 
 	(*nlpp)->n = n;
-	if (oldstyle) {
-		/*
-		 * Start reading from old file again, ignoring any pushed back
-		 * tokens left from the backquote parsing
-		 */
-		popfile();
+	/* Start reading from old file again. */
+	popfile();
+	/* Ignore any pushed back tokens left from the backquote parsing. */
+	if (oldstyle)
 		tokpushback = 0;
-	}
-	while (stackblocksize() <= savelen)
-		growstackblock();
-	STARTSTACKSTR(out);
+	out = growstackto(savelen + 1);
 	if (str) {
 		memcpy(out, str, savelen);
 		STADJUST(savelen, out);
@@ -13070,8 +13153,10 @@ parseheredoc(void)
 	while (here) {
 		tokpushback = 0;
 		setprompt_if(needprompt, 2);
-		readtoken1(pgetc(), here->here->type == NHERE ? SQSYNTAX : DQSYNTAX,
-				here->eofmark, here->striptabs);
+		if (here->here->type == NHERE)
+			readtoken1(pgetc(), SQSYNTAX, here->eofmark, here->striptabs);
+		else
+			readtoken1(pgetc_eatbnl(), DQSYNTAX, here->eofmark, here->striptabs);
 		n = stzalloc(sizeof(struct narg));
 		n->narg.type = NARG;
 		/*n->narg.next = NULL; - stzalloc did it */
@@ -13092,29 +13177,27 @@ expandstr(const char *ps, int syntax_typ
 	volatile int saveint;
 	struct jmploc *volatile savehandler = exception_handler;
 	struct jmploc jmploc;
+	const char *volatile result;
+	int err;
 
 	/* XXX Fix (char *) cast. */
 	setinputstring((char *)ps);
 
 	saveprompt = doprompt;
 	doprompt = 0;
+	result = ps;
+
+	SAVE_INT(saveint);
+	err = setjmp(jmploc.loc);
+	if (err)
+		goto out;
 
 	/* readtoken1() might die horribly.
 	 * Try a prompt with syntactically wrong command:
 	 * PS1='$(date "+%H:%M:%S) > '
 	 */
-	SAVE_INT(saveint);
-	if (setjmp(jmploc.loc) == 0) {
-		exception_handler = &jmploc;
-		readtoken1(pgetc(), syntax_type, FAKEEOFMARK, 0);
-	}
-	exception_handler = savehandler;
-	RESTORE_INT(saveint);
-
-	doprompt = saveprompt;
-
-	/* Try: PS1='`xxx(`' */
-	unwindfiles(file_stop);
+	exception_handler = &jmploc;
+	readtoken1(pgetc(), syntax_type, FAKEEOFMARK, 0);
 
 	n.narg.type = NARG;
 	n.narg.next = NULL;
@@ -13124,17 +13207,20 @@ expandstr(const char *ps, int syntax_typ
 	/* expandarg() might fail too:
 	 * PS1='$((123+))'
 	 */
-	SAVE_INT(saveint);
-	if (setjmp(jmploc.loc) == 0) {
-		exception_handler = &jmploc;
-		expandarg(&n, NULL, EXP_QUOTED);
-	} else if (exception_type == EXEXIT) {
-		exitshell();
-	}
+	expandarg(&n, NULL, EXP_QUOTED);
+	result = stackblock();
+
+out:
 	exception_handler = savehandler;
+	if (err && exception_type != EXERROR)
+		longjmp(exception_handler->loc, 1);
 	RESTORE_INT(saveint);
 
-	return stackblock();
+	doprompt = saveprompt;
+	/* Try: PS1='`xxx(`' */
+	unwindfiles(file_stop);
+
+	return result;
 }
 
 static inline int
@@ -13263,8 +13349,12 @@ cmdloop(int top)
 			if (!top || numeof >= 50)
 				break;
 			if (!stoppedjobs()) {
-				if (!Iflag)
+				if (!Iflag) {
+					if (iflag) {
+						newline_and_flush(stderr);
+					}
 					break;
+				}
 				out2str("\nUse \"exit\" to leave shell.\n");
 			}
 			numeof++;
@@ -13282,7 +13372,7 @@ cmdloop(int top)
 		skip = evalskip;
 
 		if (skip) {
-			evalskip &= ~SKIPFUNC;
+			evalskip &= ~(SKIPFUNC | SKIPFUNCDEF);
 			break;
 		}
 	}
@@ -13294,33 +13384,32 @@ cmdloop(int top)
  * search for the file, which is necessary to find sub-commands.
  */
 static char *
-find_dot_file(char *name)
+find_dot_file(char *basename)
 {
 	char *fullname;
 	const char *path = pathval();
 	struct stat statb;
+	int len;
 
 	/* don't try this for absolute or relative paths */
-	if (strchr(name, '/'))
-		return name;
+	if (strchr(basename, '/'))
+		return basename;
 
-	while ((fullname = path_advance(&path, name)) != NULL) {
-		if ((stat(fullname, &statb) == 0) && S_ISREG(statb.st_mode)) {
-			/*
-			 * Don't bother freeing here, since it will
-			 * be freed by the caller.
-			 */
-			return fullname;
+	while ((len = padvance(&path, basename)) >= 0) {
+		fullname = stackblock();
+		if ((!pathopt || *pathopt == 'f')
+		 && !stat(fullname, &statb) && S_ISREG(statb.st_mode)
+		) {
+			/* This will be freed by the caller. */
+			return stalloc(len);
 		}
-		if (fullname != name)
-			stunalloc(fullname);
 	}
 	/* not found in PATH */
 
 #if ENABLE_ASH_BASH_SOURCE_CURDIR
-	return name;
+	return basename;
 #else
-	ash_msg_and_raise_error("%s: not found", name);
+	ash_msg_and_raise_error("%s: not found", basename);
 	/* NOTREACHED */
 #endif
 }
@@ -13386,8 +13475,10 @@ exitcmd(int argc UNUSED_PARAM, char **ar
 {
 	if (stoppedjobs())
 		return 0;
+
 	if (argv[1])
-		exitstatus = number(argv[1]);
+		savestatus = number(argv[1]);
+
 	raise_exception(EXEXIT);
 	/* NOTREACHED */
 }
@@ -13421,6 +13512,7 @@ find_command(char *name, struct cmdentry
 	int e;
 	int updatetbl;
 	struct builtincmd *bcmd;
+	int len;
 
 	/* If name contains a slash, don't use PATH or hash table */
 	if (strchr(name, '/') != NULL) {
@@ -13442,11 +13534,8 @@ find_command(char *name, struct cmdentry
 /* #if ENABLE_FEATURE_SH_STANDALONE... moved after builtin check */
 
 	updatetbl = (path == pathval());
-	if (!updatetbl) {
+	if (!updatetbl)
 		act |= DO_ALTPATH;
-		if (strstr(path, "%builtin") != NULL)
-			act |= DO_ALTBLTIN;
-	}
 
 	/* If name is in the table, check answer will be ok */
 	cmdp = cmdlookup(name, 0);
@@ -13459,16 +13548,19 @@ find_command(char *name, struct cmdentry
 			abort();
 #endif
 		case CMDNORMAL:
-			bit = DO_ALTPATH;
+			bit = DO_ALTPATH | DO_REGBLTIN;
 			break;
 		case CMDFUNCTION:
 			bit = DO_NOFUNC;
 			break;
 		case CMDBUILTIN:
-			bit = DO_ALTBLTIN;
+			bit = IS_BUILTIN_REGULAR(cmdp->param.cmd) ? 0 : DO_REGBLTIN;
 			break;
 		}
 		if (act & bit) {
+			if (act & bit & DO_REGBLTIN)
+				goto fail;
+
 			updatetbl = 0;
 			cmdp = NULL;
 		} else if (cmdp->rehash == 0)
@@ -13481,14 +13573,15 @@ find_command(char *name, struct cmdentry
 	if (bcmd) {
 		if (IS_BUILTIN_REGULAR(bcmd))
 			goto builtin_success;
-		if (act & DO_ALTPATH) {
-			if (!(act & DO_ALTBLTIN))
-				goto builtin_success;
-		} else if (builtinloc <= 0) {
+		if (act & DO_ALTPATH)
+			goto builtin_success;
+		if (builtinloc <= 0)
 			goto builtin_success;
-		}
 	}
 
+	if (act & DO_REGBLTIN)
+		goto fail;
+
 #if ENABLE_FEATURE_SH_STANDALONE
 	{
 		int applet_no = find_applet_by_name(name);
@@ -13512,20 +13605,20 @@ find_command(char *name, struct cmdentry
 	e = ENOENT;
 	idx = -1;
  loop:
-	while ((fullname = path_advance(&path, name)) != NULL) {
-		stunalloc(fullname);
-		/* NB: code below will still use fullname
-		 * despite it being "unallocated" */
+	while ((len = padvance(&path, name)) >= 0) {
+		const char *lpathopt = pathopt;
+
+		fullname = stackblock();
 		idx++;
-		if (pathopt) {
-			if (prefix(pathopt, "builtin")) {
+		if (lpathopt) {
+			if (*lpathopt == 'b') {
 				if (bcmd)
 					goto builtin_success;
 				continue;
-			}
-			if ((act & DO_NOFUNC)
-			 || !prefix(pathopt, "func")
-			) {     /* ignore unimplemented options */
+			} else if (!(act & DO_NOFUNC)) {
+				/* handled below */
+			} else {
+				/* ignore unimplemented options */
 				continue;
 			}
 		}
@@ -13548,8 +13641,8 @@ find_command(char *name, struct cmdentry
 		e = EACCES;     /* if we fail, this will be the error */
 		if (!S_ISREG(statb.st_mode))
 			continue;
-		if (pathopt) {          /* this is a %func directory */
-			stalloc(strlen(fullname) + 1);
+		if (lpathopt) {          /* this is a %func directory */
+			stalloc(len);
 			/* NB: stalloc will return space pointed by fullname
 			 * (because we don't have any intervening allocations
 			 * between stunalloc above and this stalloc) */
@@ -13592,6 +13685,7 @@ find_command(char *name, struct cmdentry
 #endif
 		ash_msg("%s: %s", name, errmsg(e, "not found"));
 	}
+ fail:
 	entry->cmdtype = CMDUNKNOWN;
 	return;
 
@@ -13733,8 +13827,7 @@ helpcmd(int argc UNUSED_PARAM, char **ar
 static int FAST_FUNC
 historycmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
 {
-	if (line_input_state)
-		show_history(line_input_state);
+	show_history(line_input_state);
 	return EXIT_SUCCESS;
 }
 #endif
@@ -14040,6 +14133,47 @@ ulimitcmd(int argc UNUSED_PARAM, char **
 /* ============ main() and helpers */
 
 /*
+ * This routine is called when an error or an interrupt occurs in an
+ * interactive shell and control is returned to the main command loop
+ * but prior to exitshell.
+ */
+static void
+exitreset(void)
+{
+	/* from eval.c: */
+	if (savestatus >= 0) {
+		if (exception_type == EXEXIT || evalskip == SKIPFUNCDEF)
+			exitstatus = savestatus;
+		savestatus = -1;
+	}
+	evalskip = 0;
+	loopnest = 0;
+
+	/* from expand.c: */
+	ifsfree();
+
+	/* from redir.c: */
+	unwindredir(NULL);
+}
+
+/*
+ * This routine is called when an error or an interrupt occurs in an
+ * interactive shell and control is returned to the main command loop.
+ * (In dash, this function is auto-generated by build machinery).
+ */
+static void
+reset(void)
+{
+	/* from input.c: */
+	g_parsefile->left_in_buffer = 0;
+	g_parsefile->left_in_line = 0;      /* clear input buffer */
+	popallfiles();
+
+	/* from var.c: */
+	unwindlocalvars(NULL);
+}
+
+/*
  * Called to exit the shell.
  */
 static void
@@ -14047,34 +14181,32 @@ exitshell(void)
 {
 	struct jmploc loc;
 	char *p;
-	int status;
 
 #if ENABLE_FEATURE_EDITING_SAVE_ON_EXIT
 	if (line_input_state)
 		save_history(line_input_state);
 #endif
-	status = exitstatus;
-	TRACE(("pid %d, exitshell(%d)\n", getpid(), status));
-	if (setjmp(loc.loc)) {
-		if (exception_type == EXEXIT)
-			status = exitstatus;
+	savestatus = exitstatus;
+	TRACE(("pid %d, exitshell(%d)\n", getpid(), savestatus));
+	if (setjmp(loc.loc))
 		goto out;
-	}
 	exception_handler = &loc;
 	p = trap[0];
 	if (p) {
 		trap[0] = NULL;
 		evalskip = 0;
 		evalstring(p, 0);
+		evalskip = SKIPFUNCDEF;
 		/*free(p); - we'll exit soon */
 	}
  out:
+	exitreset();
 	/* dash wraps setjobctl(0) in "if (setjmp(loc.loc) == 0) {...}".
 	 * our setjobctl(0) does not panic if tcsetpgrp fails inside it.
 	 */
 	setjobctl(0);
 	flush_stdout_stderr();
-	_exit(status);
+	_exit(exitstatus);
 	/* NOTREACHED */
 }
 
@@ -14089,11 +14221,6 @@ init(void)
 	sigmode[SIGCHLD - 1] = S_DFL; /* ensure we install handler even if it is SIG_IGNed */
 	setsignal(SIGCHLD);
 
-	/* bash re-enables SIGHUP which is SIG_IGNed on entry.
-	 * Try: "trap '' HUP; bash; echo RET" and type "kill -HUP $$"
-	 */
-	signal(SIGHUP, SIG_DFL);
-
 	{
 		char **envp;
 		const char *p;
@@ -14239,33 +14366,6 @@ read_profile(const char *name)
 	popfile();
 }
 
-/*
- * This routine is called when an error or an interrupt occurs in an
- * interactive shell and control is returned to the main command loop.
- * (In dash, this function is auto-generated by build machinery).
- */
-static void
-reset(void)
-{
-	/* from eval.c: */
-	evalskip = 0;
-	loopnest = 0;
-
-	/* from expand.c: */
-	ifsfree();
-
-	/* from input.c: */
-	g_parsefile->left_in_buffer = 0;
-	g_parsefile->left_in_line = 0;      /* clear input buffer */
-	popallfiles();
-
-	/* from redir.c: */
-	unwindredir(NULL);
-
-	/* from var.c: */
-	unwindlocalvars(NULL);
-}
-
 #if PROFILE
 static short profile_buf[16384];
 extern int etext();
@@ -14309,13 +14409,16 @@ int ash_main(int argc UNUSED_PARAM, char
 		smallint e;
 		smallint s;
 
-		reset();
+		exitreset();
 
 		e = exception_type;
 		s = state;
-		if (e == EXEXIT || s == 0 || iflag == 0 || shlvl) {
+		if (e == EXEND || e == EXEXIT || s == 0 || iflag == 0 || shlvl) {
 			exitshell();
 		}
+
+		reset();
+
 		if (e == EXINT) {
 			newline_and_flush(stderr);
 		}
@@ -14415,6 +14518,14 @@ int ash_main(int argc UNUSED_PARAM, char
 		}
 #endif
  state4: /* XXX ??? - why isn't this before the "if" statement */
+
+		/* Interactive bash re-enables SIGHUP which is SIG_IGNed on entry.
+		 * Try:
+		 * trap '' hup; bash; echo RET	# type "kill -hup $$", see SIGHUP having effect
+		 * trap '' hup; bash -c 'kill -hup $$; echo ALIVE'  # here SIGHUP is SIG_IGNed
+		 */
+		signal(SIGHUP, SIG_DFL);
+
 		cmdloop(1);
 	}
 #if PROFILE
diff -urpN busybox-1.31.1/shell/ash_test/ash-heredoc/heredoc_side_effects.right busybox-1.32.0/shell/ash_test/ash-heredoc/heredoc_side_effects.right
--- busybox-1.31.1/shell/ash_test/ash-heredoc/heredoc_side_effects.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-heredoc/heredoc_side_effects.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1 @@
+NO BUG
diff -urpN busybox-1.31.1/shell/ash_test/ash-heredoc/heredoc_side_effects.tests busybox-1.32.0/shell/ash_test/ash-heredoc/heredoc_side_effects.tests
--- busybox-1.31.1/shell/ash_test/ash-heredoc/heredoc_side_effects.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-heredoc/heredoc_side_effects.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,5 @@
+unset a
+cat <<EOF >/dev/null
+${a=NO}
+EOF
+echo $a BUG
diff -urpN busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap1.right busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap1.right
--- busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap1.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap1.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,2 @@
+Trapped
+One:1
diff -urpN busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap1.tests busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap1.tests
--- busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap1.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap1.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,6 @@
+# "exit" in trap should not use last command's exitcode,
+# but exitcode on entering the trap.
+(trap "echo Trapped; exit" EXIT
+ (exit 1)
+)
+echo One:$?
diff -urpN busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap2.right busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap2.right
--- busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap2.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap2.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1 @@
+42:42
diff -urpN busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap2.tests busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap2.tests
--- busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap2.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap2.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,8 @@
+# "exit" in trap should not use last command's exitcode,
+# but exitcode on entering the trap.
+$THIS_SH -c '
+ trap "false;exit" term
+ kill $$ &
+ (sleep 1; exit 42)
+'
+echo 42:$?
diff -urpN busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap3.right busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap3.right
--- busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap3.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap3.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,2 @@
+TERM
+42:42
diff -urpN busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap3.tests busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap3.tests
--- busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap3.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap3.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,9 @@
+# "return" in trap should not use last command's exitcode,
+# but exitcode on entering the trap.
+trap "echo TERM;return" term
+f() {
+	(sleep 1; kill $$) &
+	until (exit 42) do (exit 42); done
+}
+f
+echo 42:$?
diff -urpN busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap4.right busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap4.right
--- busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap4.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap4.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,2 @@
+TERM
+11:11
diff -urpN busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap4.tests busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap4.tests
--- busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap4.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap4.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,8 @@
+# "return" in trap sets $? after trap
+trap "echo TERM;return 11" term
+f() {
+	(sleep 1; kill $$) &
+	until (exit 42) do (exit 42); done
+}
+f
+echo 11:$?
diff -urpN busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap5.right busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap5.right
--- busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap5.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap5.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,3 @@
+TERM
+Nested
+Zero:0
diff -urpN busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap5.tests busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap5.tests
--- busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap5.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap5.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,10 @@
+# "return" in trap sets $? after trap...
+# ...but not a nested one!
+g() { echo Nested; return 22; }
+trap "echo TERM;false;g" term
+f() {
+	(kill $$) &
+	sleep 1
+}
+f
+echo Zero:$?
diff -urpN busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap6.right busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap6.right
--- busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap6.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap6.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,2 @@
+INT
+42:42
diff -urpN busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap6.tests busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap6.tests
--- busybox-1.31.1/shell/ash_test/ash-misc/exitcode_trap6.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-misc/exitcode_trap6.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,10 @@
+# "exit" in trap should not use last command's exitcode,
+# but exitcode on entering the trap.
+# Nested trap should not interfere with this.
+$THIS_SH -c '
+ trap "echo INT" int
+ trap "kill -int $$;exit" term
+ kill $$ &
+ (sleep 1; exit 42)
+'
+echo 42:$?
diff -urpN busybox-1.31.1/shell/ash_test/ash-psubst/tick_in_heredoc.right busybox-1.32.0/shell/ash_test/ash-psubst/tick_in_heredoc.right
--- busybox-1.31.1/shell/ash_test/ash-psubst/tick_in_heredoc.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-psubst/tick_in_heredoc.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,5 @@
+1
+
+2
+
+3
diff -urpN busybox-1.31.1/shell/ash_test/ash-psubst/tick_in_heredoc.tests busybox-1.32.0/shell/ash_test/ash-psubst/tick_in_heredoc.tests
--- busybox-1.31.1/shell/ash_test/ash-psubst/tick_in_heredoc.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-psubst/tick_in_heredoc.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,7 @@
+cat <<END
+1
+$(echo "")
+2
+`echo ""`
+3
+END
diff -urpN busybox-1.31.1/shell/ash_test/ash-quoting/negative_arith.right busybox-1.32.0/shell/ash_test/ash-quoting/negative_arith.right
--- busybox-1.31.1/shell/ash_test/ash-quoting/negative_arith.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-quoting/negative_arith.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,2 @@
+tempfile0.tmp tempfile9.tmp
+tempfile0.tmp tempfile1.tmp tempfile9.tmp
diff -urpN busybox-1.31.1/shell/ash_test/ash-quoting/negative_arith.tests busybox-1.32.0/shell/ash_test/ash-quoting/negative_arith.tests
--- busybox-1.31.1/shell/ash_test/ash-quoting/negative_arith.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-quoting/negative_arith.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,8 @@
+>tempfile0.tmp
+>tempfile1.tmp
+>tempfile9.tmp
+# The [...] is interpreted as: "any of the chars 0, -, and 9"
+echo tempfile[0"$((-9))"].tmp
+# The [...] is [0-9], interpreted as: "any digit"
+echo tempfile[0$((-9))].tmp
+rm tempfile?.tmp
diff -urpN busybox-1.31.1/shell/ash_test/ash-redir/redir_exec1.right busybox-1.32.0/shell/ash_test/ash-redir/redir_exec1.right
--- busybox-1.31.1/shell/ash_test/ash-redir/redir_exec1.right	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-redir/redir_exec1.right	2020-06-26 22:47:44.000000000 +0400
@@ -1,2 +1 @@
 ./redir_exec1.tests: line 1: can't create /cant/be/created: nonexistent directory
-First
diff -urpN busybox-1.31.1/shell/ash_test/ash-redir/redir_stdin1.right busybox-1.32.0/shell/ash_test/ash-redir/redir_stdin1.right
--- busybox-1.31.1/shell/ash_test/ash-redir/redir_stdin1.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-redir/redir_stdin1.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,3 @@
+#Testing that stdin redirect is restored
+read2
+Ok:0
diff -urpN busybox-1.31.1/shell/ash_test/ash-redir/redir_stdin1.tests busybox-1.32.0/shell/ash_test/ash-redir/redir_stdin1.tests
--- busybox-1.31.1/shell/ash_test/ash-redir/redir_stdin1.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-redir/redir_stdin1.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,7 @@
+#Testing that stdin redirect is restored
+echo read2 | $THIS_SH -c 'read r <redir_stdin1.tests
+echo $r
+read r
+echo $r
+'
+echo Ok:$?
diff -urpN busybox-1.31.1/shell/ash_test/ash-vars/var_10.right busybox-1.32.0/shell/ash_test/ash-vars/var_10.right
--- busybox-1.31.1/shell/ash_test/ash-vars/var_10.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-vars/var_10.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,3 @@
+Zero:0
+One:1
+Done:0
diff -urpN busybox-1.31.1/shell/ash_test/ash-vars/var_10.tests busybox-1.32.0/shell/ash_test/ash-vars/var_10.tests
--- busybox-1.31.1/shell/ash_test/ash-vars/var_10.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/ash_test/ash-vars/var_10.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,4 @@
+set -- : 2 3 4 5 6 7 8 9 ten eleven
+echo Zero$10
+echo One$11
+echo Done:$?
diff -urpN busybox-1.31.1/shell/hush.c busybox-1.32.0/shell/hush.c
--- busybox-1.31.1/shell/hush.c	2019-10-21 18:54:40.000000000 +0400
+++ busybox-1.32.0/shell/hush.c	2020-06-26 22:47:44.000000000 +0400
@@ -95,6 +95,7 @@
 //config:config HUSH
 //config:	bool "hush (68 kb)"
 //config:	default y
+//config:	select SHELL_HUSH
 //config:	help
 //config:	hush is a small shell. It handles the normal flow control
 //config:	constructs such as if/then/elif/else/fi, for/in/do/done, while loops,
@@ -106,10 +107,20 @@
 //config:	It does not handle select, aliases, tilde expansion,
 //config:	&>file and >&file redirection of stdout+stderr.
 //config:
+// This option is visible (has a description) to make it possible to select
+// a "scripted" applet (such as NOLOGIN) but avoid selecting any shells:
+//config:config SHELL_HUSH
+//config:	bool "Internal shell for embedded script support"
+//config:	default n
+//config:
+//config:# hush options
+//config:# It's only needed to get "nice" menuconfig indenting.
+//config:if SHELL_HUSH || HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:
 //config:config HUSH_BASH_COMPAT
 //config:	bool "bash-compatible extensions"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_BRACE_EXPANSION
 //config:	bool "Brace expansion"
@@ -133,7 +144,7 @@
 //config:config HUSH_INTERACTIVE
 //config:	bool "Interactive mode"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:	help
 //config:	Enable interactive mode (prompt and command editing).
 //config:	Without this, hush simply reads and executes commands
@@ -159,31 +170,31 @@
 //config:config HUSH_TICK
 //config:	bool "Support command substitution"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:	help
 //config:	Enable `command` and $(command).
 //config:
 //config:config HUSH_IF
 //config:	bool "Support if/then/elif/else/fi"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_LOOPS
 //config:	bool "Support for, while and until loops"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_CASE
 //config:	bool "Support case ... esac statement"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:	help
 //config:	Enable case ... esac statement. +400 bytes.
 //config:
 //config:config HUSH_FUNCTIONS
 //config:	bool "Support funcname() { commands; } syntax"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:	help
 //config:	Enable support for shell functions. +800 bytes.
 //config:
@@ -197,7 +208,7 @@
 //config:config HUSH_RANDOM_SUPPORT
 //config:	bool "Pseudorandom generator and $RANDOM variable"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:	help
 //config:	Enable pseudorandom generator and dynamic variable "$RANDOM".
 //config:	Each read of "$RANDOM" will generate a new pseudorandom value.
@@ -205,7 +216,7 @@
 //config:config HUSH_MODE_X
 //config:	bool "Support 'hush -x' option and 'set -x' command"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:	help
 //config:	This instructs hush to print commands before execution.
 //config:	Adds ~300 bytes.
@@ -213,27 +224,27 @@
 //config:config HUSH_ECHO
 //config:	bool "echo builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_PRINTF
 //config:	bool "printf builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_TEST
 //config:	bool "test builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_HELP
 //config:	bool "help builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_EXPORT
 //config:	bool "export builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_EXPORT_N
 //config:	bool "Support 'export -n' option"
@@ -245,83 +256,83 @@
 //config:config HUSH_READONLY
 //config:	bool "readonly builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:	help
 //config:	Enable support for read-only variables.
 //config:
 //config:config HUSH_KILL
 //config:	bool "kill builtin (supports kill %jobspec)"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_WAIT
 //config:	bool "wait builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_COMMAND
 //config:	bool "command builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_TRAP
 //config:	bool "trap builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_TYPE
 //config:	bool "type builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_TIMES
 //config:	bool "times builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_READ
 //config:	bool "read builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_SET
 //config:	bool "set builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_UNSET
 //config:	bool "unset builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_ULIMIT
 //config:	bool "ulimit builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_UMASK
 //config:	bool "umask builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_GETOPTS
 //config:	bool "getopts builtin"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
 //config:
 //config:config HUSH_MEMLEAK
 //config:	bool "memleak builtin (debugging)"
 //config:	default n
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on SHELL_HUSH
+//config:
+//config:endif # hush options
 
 //applet:IF_HUSH(APPLET(hush, BB_DIR_BIN, BB_SUID_DROP))
 //                       APPLET_ODDNAME:name  main  location    suid_type     help
 //applet:IF_SH_IS_HUSH(  APPLET_ODDNAME(sh,   hush, BB_DIR_BIN, BB_SUID_DROP, hush))
 //applet:IF_BASH_IS_HUSH(APPLET_ODDNAME(bash, hush, BB_DIR_BIN, BB_SUID_DROP, hush))
 
-//kbuild:lib-$(CONFIG_HUSH) += hush.o match.o shell_common.o
-//kbuild:lib-$(CONFIG_SH_IS_HUSH) += hush.o match.o shell_common.o
-//kbuild:lib-$(CONFIG_BASH_IS_HUSH) += hush.o match.o shell_common.o
+//kbuild:lib-$(CONFIG_SHELL_HUSH) += hush.o match.o shell_common.o
 //kbuild:lib-$(CONFIG_HUSH_RANDOM_SUPPORT) += random.o
 
 /* -i (interactive) is also accepted,
@@ -573,7 +584,6 @@ typedef struct HFILE {
 	char *cur;
 	char *end;
 	struct HFILE *next_hfile;
-	int is_stdin;
 	int fd;
 	char buf[1024];
 } HFILE;
@@ -973,6 +983,7 @@ struct globals {
 	unsigned execute_lineno;
 #endif
 	HFILE *HFILE_list;
+	HFILE *HFILE_stdin;
 	/* Which signals have non-DFL handler (even with no traps set)?
 	 * Set at the start to:
 	 * (SIGQUIT + maybe SPECIAL_INTERACTIVE_SIGS + maybe SPECIAL_JOBSTOP_SIGS)
@@ -988,6 +999,10 @@ struct globals {
 # define G_fatal_sig_mask 0
 #endif
 #if ENABLE_HUSH_TRAP
+	int pre_trap_exitcode;
+# if ENABLE_HUSH_FUNCTIONS
+	int return_exitcode;
+# endif
 	char **traps; /* char *traps[NSIG] */
 # define G_traps G.traps
 #else
@@ -1398,7 +1413,7 @@ static void syntax_error(unsigned lineno
 	if (msg)
 		bb_error_msg("syntax error: %s", msg);
 	else
-		bb_error_msg("syntax error");
+		bb_simple_error_msg("syntax error");
 	die_if_script();
 }
 
@@ -1603,7 +1618,8 @@ static HFILE *hfopen(const char *name)
 	}
 
 	fp = xmalloc(sizeof(*fp));
-	fp->is_stdin = (name == NULL);
+	if (name == NULL)
+		G.HFILE_stdin = fp;
 	fp->fd = fd;
 	fp->cur = fp->end = fp->buf;
 	fp->next_hfile = G.HFILE_list;
@@ -1637,7 +1653,7 @@ static int refill_HFILE_and_getc(HFILE *
 	fp->cur = fp->buf;
 	n = safe_read(fp->fd, fp->buf, sizeof(fp->buf));
 	if (n < 0) {
-		bb_perror_msg("read error");
+		bb_simple_perror_msg("read error");
 		n = 0;
 	}
 	fp->end = fp->buf + n;
@@ -2096,25 +2112,35 @@ static int check_and_run_traps(void)
 		} while (sig < NSIG);
 		break;
  got_sig:
+#if ENABLE_HUSH_TRAP
 		if (G_traps && G_traps[sig]) {
 			debug_printf_exec("%s: sig:%d handler:'%s'\n", __func__, sig, G.traps[sig]);
 			if (G_traps[sig][0]) {
 				/* We have user-defined handler */
 				smalluint save_rcode;
+				int save_pre;
 				char *argv[3];
 				/* argv[0] is unused */
 				argv[1] = xstrdup(G_traps[sig]);
 				/* why strdup? trap can modify itself: trap 'trap "echo oops" INT' INT */
 				argv[2] = NULL;
-				save_rcode = G.last_exitcode;
+				save_pre = G.pre_trap_exitcode;
+				G.pre_trap_exitcode = save_rcode = G.last_exitcode;
 				builtin_eval(argv);
 				free(argv[1]);
-//FIXME: shouldn't it be set to 128 + sig instead?
+				G.pre_trap_exitcode = save_pre;
 				G.last_exitcode = save_rcode;
+# if ENABLE_HUSH_FUNCTIONS
+				if (G.return_exitcode >= 0) {
+					debug_printf_exec("trap exitcode:%d\n", G.return_exitcode);
+					G.last_exitcode = G.return_exitcode;
+				}
+# endif
 				last_sig = sig;
 			} /* else: "" trap, ignoring signal */
 			continue;
 		}
+#endif
 		/* not a trap: special action */
 		switch (sig) {
 		case SIGINT:
@@ -2282,7 +2308,7 @@ static int set_local_var(char *str, unsi
 
 	eq_sign = strchr(str, '=');
 	if (HUSH_DEBUG && !eq_sign)
-		bb_error_msg_and_die("BUG in setvar");
+		bb_simple_error_msg_and_die("BUG in setvar");
 
 	name_len = eq_sign - str + 1; /* including '=' */
 	cur_pp = &G.top_var;
@@ -2505,7 +2531,7 @@ static void set_vars_and_save_old(char *
 
 		eq = strchr(*s, '=');
 		if (HUSH_DEBUG && !eq)
-			bb_error_msg_and_die("BUG in varexp4");
+			bb_simple_error_msg_and_die("BUG in varexp4");
 		var_pp = get_ptr_to_local_var(*s, eq - *s);
 		if (var_pp) {
 			var_p = *var_pp;
@@ -2666,7 +2692,7 @@ static int fgetc_interactive(struct in_s
 {
 	int ch;
 	/* If it's interactive stdin, get new line. */
-	if (G_interactive_fd && i->file->is_stdin) {
+	if (G_interactive_fd && i->file == G.HFILE_stdin) {
 		/* Returns first char (or EOF), the rest is in i->p[] */
 		ch = get_user_input(i);
 		G.promptmode = 1; /* PS2 */
@@ -2992,7 +3018,10 @@ static void x_mode_flush(void)
 static void o_addqchr(o_string *o, int ch)
 {
 	int sz = 1;
-	char *found = strchr("*?[\\" MAYBE_BRACES, ch);
+	/* '-' is included because of this case:
+	 * >filename0 >filename1 >filename9; v='-'; echo filename[0"$v"9]
+	 */
+	char *found = strchr("*?[-\\" MAYBE_BRACES, ch);
 	if (found)
 		sz++;
 	o_grow_by(o, sz);
@@ -3009,7 +3038,7 @@ static void o_addQchr(o_string *o, int c
 {
 	int sz = 1;
 	if ((o->o_expflags & EXP_FLAG_ESC_GLOB_CHARS)
-	 && strchr("*?[\\" MAYBE_BRACES, ch)
+	 && strchr("*?[-\\" MAYBE_BRACES, ch)
 	) {
 		sz++;
 		o->data[o->length] = '\\';
@@ -3026,7 +3055,7 @@ static void o_addqblock(o_string *o, con
 	while (len) {
 		char ch;
 		int sz;
-		int ordinary_cnt = strcspn(str, "*?[\\" MAYBE_BRACES);
+		int ordinary_cnt = strcspn(str, "*?[-\\" MAYBE_BRACES);
 		if (ordinary_cnt > len) /* paranoia */
 			ordinary_cnt = len;
 		o_addblock(o, str, ordinary_cnt);
@@ -3037,7 +3066,7 @@ static void o_addqblock(o_string *o, con
 
 		ch = *str++;
 		sz = 1;
-		if (ch) { /* it is necessarily one of "*?[\\" MAYBE_BRACES */
+		if (ch) { /* it is necessarily one of "*?[-\\" MAYBE_BRACES */
 			sz++;
 			o->data[o->length] = '\\';
 			o->length++;
@@ -3652,9 +3681,9 @@ static void debug_print_tree(struct pipe
 			fdprintf(2, "%*s cmd %d assignment_cnt:%d",
 					lvl*2, "", prn,
 					command->assignment_cnt);
-#if ENABLE_HUSH_LINENO_VAR
+# if ENABLE_HUSH_LINENO_VAR
 			fdprintf(2, " LINENO:%u", command->lineno);
-#endif
+# endif
 			if (command->group) {
 				fdprintf(2, " group %s: (argv=%p)%s%s\n",
 						CMDTYPE[command->cmd_type],
@@ -4246,7 +4275,7 @@ static int parse_redir_right_fd(o_string
 
 //TODO: this is the place to catch ">&file" bashism (redirect both fd 1 and 2)
 
-	bb_error_msg("ambiguous redirect");
+	bb_simple_error_msg("ambiguous redirect");
 	return REDIRFD_SYNTAX_ERR;
 }
 
@@ -4770,9 +4799,9 @@ static int add_till_closing_bracket(o_st
 # endif
 	end_ch &= (DOUBLE_CLOSE_CHAR_FLAG - 1);
 
-#if ENABLE_HUSH_INTERACTIVE
+# if ENABLE_HUSH_INTERACTIVE
 	G.promptmode = 1; /* PS2 */
-#endif
+# endif
 	debug_printf_prompt("%s promptmode=%d\n", __func__, G.promptmode);
 
 	while (1) {
@@ -4828,13 +4857,13 @@ static int add_till_closing_bracket(o_st
 				syntax_error_unterm_ch(end_ch);
 				return 0;
 			}
-#if 0
+# if 0
 			if (ch == '\n') {
 				/* "backslash+newline", ignore both */
 				o_delchr(dest); /* undo insertion of '\' */
 				continue;
 			}
-#endif
+# endif
 			o_addchr(dest, ch);
 			//bb_error_msg("%s:o_addchr('%c') after '\\'", __func__, ch);
 			continue;
@@ -4991,7 +5020,7 @@ static int parse_dollar(o_string *as_str
 				if (last_ch == 0) /* error? */
 					return 0;
 #else
-#error Simple code to only allow ${var} is not implemented
+# error Simple code to only allow ${var} is not implemented
 #endif
 				if (as_string) {
 					o_addstr(as_string, dest->data + pos);
@@ -5034,7 +5063,7 @@ static int parse_dollar(o_string *as_str
 			ch = i_getch(input);
 			nommu_addchr(as_string, ch);
 			o_addchr(dest, SPECIAL_VAR_SYMBOL);
-			o_addchr(dest, /*quote_mask |*/ '+');
+			o_addchr(dest, quote_mask | '+');
 			if (!BB_MMU)
 				pos = dest->length;
 			if (!add_till_closing_bracket(dest, input, ')' | DOUBLE_CLOSE_CHAR_FLAG))
@@ -6836,6 +6865,17 @@ static NOINLINE int expand_vars_to_list(
 			res = expand_and_evaluate_arith(arg, NULL);
 			debug_printf_subst("ARITH RES '"ARITH_FMT"'\n", res);
 			sprintf(arith_buf, ARITH_FMT, res);
+			if (res < 0
+			 && first_ch == (char)('+'|0x80)
+			/* && (output->o_expflags & EXP_FLAG_ESC_GLOB_CHARS) */
+			) {
+				/* Quoted negative ariths, like filename[0"$((-9))"],
+				 * should not be interpreted as glob ranges.
+				 * Convert leading '-' to '\-':
+				 */
+				o_grow_by(output, 1);
+				output->data[output->length++] = '\\';
+			}
 			o_addstr(output, arith_buf);
 			break;
 		}
@@ -6956,7 +6996,7 @@ static char *expand_string_to_string(con
 	} else {
 		if (HUSH_DEBUG)
 			if (list[1])
-				bb_error_msg_and_die("BUG in varexp2");
+				bb_simple_error_msg_and_die("BUG in varexp2");
 		/* actually, just move string 2*sizeof(char*) bytes back */
 		overlapping_strcpy((char*)list, list[0]);
 		if (do_unbackslash)
@@ -7217,7 +7257,7 @@ static void re_execute_shell(char ***to_
 	if (argv[0][0] == '/')
 		execve(argv[0], argv, pp);
 	xfunc_error_retval = 127;
-	bb_error_msg_and_die("can't re-execute the shell");
+	bb_simple_error_msg_and_die("can't re-execute the shell");
 }
 #endif  /* !BB_MMU */
 
@@ -7605,7 +7645,9 @@ static int save_fd_on_redirect(int fd, i
 		avoid_fd = 9;
 
 #if ENABLE_HUSH_INTERACTIVE
-	if (fd == G_interactive_fd) {
+	if (fd != 0 /* don't trigger for G_interactive_fd == 0 (that's "not interactive" flag) */
+	 && fd == G_interactive_fd
+	) {
 		/* Testcase: "ls -l /proc/$$/fd 255>&-" should work */
 		G_interactive_fd = xdup_CLOEXEC_and_close(G_interactive_fd, avoid_fd);
 		debug_printf_redir("redirect_fd %d: matches interactive_fd, moving it to %d\n", fd, G_interactive_fd);
@@ -7619,7 +7661,7 @@ static int save_fd_on_redirect(int fd, i
 		/* No need to move script fds.
 		 * For NOMMU case, it's actively wrong: we'd change ->fd
 		 * fields in memory for the parent, but parent's fds
-		 * aren't be moved, it would use wrong fd!
+		 * aren't moved, it would use wrong fd!
 		 * Reproducer: "cmd 3>FILE" in script.
 		 * If we would call move_HFILEs_on_redirect(), child would:
 		 *  fcntl64(3, F_DUPFD_CLOEXEC, 10)   = 10
@@ -7683,6 +7725,20 @@ static void restore_redirects(struct squ
 		}
 		free(sq);
 	}
+	if (G.HFILE_stdin
+	 && G.HFILE_stdin->fd != STDIN_FILENO
+	) {
+		/* Testcase: interactive "read r <FILE; echo $r; read r; echo $r".
+		 * Redirect moves ->fd to e.g. 10,
+		 * and it is not restored above (we do not restore script fds
+		 * after redirects, we just use new, "moved" fds).
+		 * However for stdin, get_user_input() -> read_line_input(),
+		 * and read builtin, depend on fd == STDIN_FILENO.
+		 */
+		debug_printf_redir("restoring %d to stdin\n", G.HFILE_stdin->fd);
+		xmove_fd(G.HFILE_stdin->fd, STDIN_FILENO);
+		G.HFILE_stdin->fd = STDIN_FILENO;
+	}
 
 	/* If moved, G_interactive_fd stays on new fd, not restoring it */
 }
@@ -7872,6 +7928,20 @@ static const struct built_in_command *fi
 	return find_builtin_helper(name, bltins2, &bltins2[ARRAY_SIZE(bltins2)]);
 }
 
+#if ENABLE_HUSH_JOB && EDITING_HAS_get_exe_name
+static const char * FAST_FUNC get_builtin_name(int i)
+{
+	if (/*i >= 0 && */ i < ARRAY_SIZE(bltins1)) {
+		return bltins1[i].b_cmd;
+	}
+	i -= ARRAY_SIZE(bltins1);
+	if (i < ARRAY_SIZE(bltins2)) {
+		return bltins2[i].b_cmd;
+	}
+	return NULL;
+}
+#endif
+
 static void remove_nested_vars(void)
 {
 	struct variable *cur;
@@ -7919,7 +7989,7 @@ static void leave_var_nest_level(void)
 	G.var_nest_level--;
 	debug_printf_env("var_nest_level-- %u\n", G.var_nest_level);
 	if (HUSH_DEBUG && (int)G.var_nest_level < 0)
-		bb_error_msg_and_die("BUG: nesting underflow");
+		bb_simple_error_msg_and_die("BUG: nesting underflow");
 
 	remove_nested_vars();
 }
@@ -8096,6 +8166,10 @@ static int run_function(const struct fun
 	IF_HUSH_LOCAL(leave_var_nest_level();)
 
 	G_flag_return_in_progress = sv_flg;
+# if ENABLE_HUSH_TRAP
+	debug_printf_exec("G.return_exitcode=-1\n");
+	G.return_exitcode = -1; /* invalidate stashed return value */
+# endif
 
 	restore_G_args(&sv, argv);
 
@@ -8684,9 +8758,9 @@ static int process_wait_result(struct pi
 		pi->cmds[i].pid = 0;
 		pi->alive_cmds--;
 		if (!pi->alive_cmds) {
-#if ENABLE_HUSH_BASH_COMPAT
+# if ENABLE_HUSH_BASH_COMPAT
 			G.dead_job_exitcode = job_exited_or_stopped(pi);
-#endif
+# endif
 			if (G_interactive_fd) {
 				printf(JOB_STATUS_FORMAT, pi->jobid,
 						"Done", pi->cmdtext);
@@ -8776,7 +8850,7 @@ static int checkjobs(struct pipe *fg_pip
 		childpid = waitpid(-1, &status, attributes);
 		if (childpid <= 0) {
 			if (childpid && errno != ECHILD)
-				bb_perror_msg("waitpid");
+				bb_simple_perror_msg("waitpid");
 #if ENABLE_HUSH_FAST
 			else { /* Until next SIGCHLD, waitpid's are useless */
 				G.we_have_children = (childpid == 0);
@@ -9308,7 +9382,7 @@ static NOINLINE int run_pipe(struct pipe
 		argv_expanded = NULL;
 		if (command->pid < 0) { /* [v]fork failed */
 			/* Clearly indicate, was it fork or vfork */
-			bb_perror_msg(BB_MMU ? "vfork"+1 : "vfork");
+			bb_simple_perror_msg(BB_MMU ? "vfork"+1 : "vfork");
 		} else {
 			pi->alive_cmds++;
 #if ENABLE_HUSH_JOB
@@ -9597,6 +9671,9 @@ static int run_list(struct pipe *pi)
 			debug_printf_exec(": builtin/func exitcode %d\n", rcode);
 			G.last_exitcode = rcode;
 			check_and_run_traps();
+#if ENABLE_HUSH_TRAP && ENABLE_HUSH_FUNCTIONS
+			rcode = G.last_exitcode; /* "return" in trap can change it, read back */
+#endif
 #if ENABLE_HUSH_LOOPS
 			/* Was it "break" or "continue"? */
 			if (G.flag_break_continue) {
@@ -9653,6 +9730,9 @@ static int run_list(struct pipe *pi)
  check_traps:
 			G.last_exitcode = rcode;
 			check_and_run_traps();
+#if ENABLE_HUSH_TRAP && ENABLE_HUSH_FUNCTIONS
+			rcode = G.last_exitcode; /* "return" in trap can change it, read back */
+#endif
 		}
 
 		/* Handle "set -e" */
@@ -9744,10 +9824,14 @@ static void install_sighandlers(unsigned
 		 */
 		if (sig == SIGCHLD)
 			continue;
-		/* bash re-enables SIGHUP which is SIG_IGNed on entry.
-		 * Try: "trap '' HUP; bash; echo RET" and type "kill -HUP $$"
+		/* Interactive bash re-enables SIGHUP which is SIG_IGNed on entry.
+		 * Try:
+		 * trap '' hup; bash; echo RET  # type "kill -hup $$", see SIGHUP having effect
+		 * trap '' hup; bash -c 'kill -hup $$; echo ALIVE'  # here SIGHUP is SIG_IGNed
 		 */
-		//if (sig == SIGHUP) continue; - TODO?
+		if (sig == SIGHUP && G_interactive_fd)
+			continue;
+		/* Unless one of the above signals, is it SIG_IGN? */
 		if (old_handler == SIG_IGN) {
 			/* oops... restore back to IGN, and record this fact */
 			install_sighandler(sig, old_handler);
@@ -9872,6 +9956,12 @@ int hush_main(int argc, char **argv)
 	INIT_G();
 	if (EXIT_SUCCESS != 0) /* if EXIT_SUCCESS == 0, it is already done */
 		G.last_exitcode = EXIT_SUCCESS;
+#if ENABLE_HUSH_TRAP
+# if ENABLE_HUSH_FUNCTIONS
+	G.return_exitcode = -1;
+# endif
+	G.pre_trap_exitcode = -1;
+#endif
 
 #if ENABLE_HUSH_FAST
 	G.count_SIGCHLD++; /* ensure it is != G.handled_SIGCHLD */
@@ -10214,8 +10304,6 @@ int hush_main(int argc, char **argv)
 				G_saved_tty_pgrp = 0;
 			}
 		}
-// TODO: track & disallow any attempts of user
-// to (inadvertently) close/redirect G_interactive_fd
 	}
 	debug_printf("interactive_fd:%d\n", G_interactive_fd);
 	if (G_interactive_fd) {
@@ -10253,6 +10341,9 @@ int hush_main(int argc, char **argv)
 
 # if ENABLE_FEATURE_EDITING
 		G.line_input_state = new_line_input_t(FOR_SHELL);
+#  if EDITING_HAS_get_exe_name
+		G.line_input_state->get_exe_name = get_builtin_name;
+#  endif
 # endif
 # if ENABLE_HUSH_SAVEHISTORY && MAX_HISTORY > 0
 		{
@@ -10381,8 +10472,7 @@ static int FAST_FUNC builtin_help(char *
 #if MAX_HISTORY && ENABLE_FEATURE_EDITING
 static int FAST_FUNC builtin_history(char **argv UNUSED_PARAM)
 {
-	if (G.line_input_state)
-		show_history(G.line_input_state);
+	show_history(G.line_input_state);
 	return EXIT_SUCCESS;
 }
 #endif
@@ -10516,8 +10606,13 @@ static int FAST_FUNC builtin_exit(char *
 
 	/* note: EXIT trap is run by hush_exit */
 	argv = skip_dash_dash(argv);
-	if (argv[0] == NULL)
+	if (argv[0] == NULL) {
+#if ENABLE_HUSH_TRAP
+		if (G.pre_trap_exitcode >= 0) /* "exit" in trap uses $? from before the trap */
+			hush_exit(G.pre_trap_exitcode);
+#endif
 		hush_exit(G.last_exitcode);
+	}
 	/* mimic bash: exit 123abc == exit 255 + error msg */
 	xfunc_error_retval = 255;
 	/* bash: exit -2 == exit 254, no error msg */
@@ -10537,10 +10632,10 @@ static int FAST_FUNC builtin_type(char *
 		if (0) {} /* make conditional compile easier below */
 		/*else if (find_alias(*argv))
 			type = "an alias";*/
-#if ENABLE_HUSH_FUNCTIONS
+# if ENABLE_HUSH_FUNCTIONS
 		else if (find_function(*argv))
 			type = "a function";
-#endif
+# endif
 		else if (find_builtin(*argv))
 			type = "a shell builtin";
 		else if ((path = find_in_path(*argv)) != NULL)
@@ -10595,11 +10690,11 @@ static int FAST_FUNC builtin_read(char *
 	 * Option string must start with "sr" to match BUILTIN_READ_xxx
 	 */
 	params.read_flags = getopt32(argv,
-#if BASH_READ_D
+# if BASH_READ_D
 		"!srn:p:t:u:d:", &params.opt_n, &params.opt_p, &params.opt_t, &params.opt_u, &params.opt_d
-#else
+# else
 		"!srn:p:t:u:", &params.opt_n, &params.opt_p, &params.opt_t, &params.opt_u
-#endif
+# endif
 	);
 	if ((uint32_t)params.read_flags == (uint32_t)-1)
 		return EXIT_FAILURE;
@@ -10618,7 +10713,7 @@ static int FAST_FUNC builtin_read(char *
 	}
 
 	if ((uintptr_t)r > 1) {
-		bb_error_msg("%s", r);
+		bb_simple_error_msg(r);
 		r = (char*)(uintptr_t)1;
 	}
 
@@ -10772,24 +10867,24 @@ static int FAST_FUNC builtin_export(char
 {
 	unsigned opt_unexport;
 
-#if ENABLE_HUSH_EXPORT_N
+# if ENABLE_HUSH_EXPORT_N
 	/* "!": do not abort on errors */
 	opt_unexport = getopt32(argv, "!n");
 	if (opt_unexport == (uint32_t)-1)
 		return EXIT_FAILURE;
 	argv += optind;
-#else
+# else
 	opt_unexport = 0;
 	argv++;
-#endif
+# endif
 
 	if (argv[0] == NULL) {
 		char **e = environ;
 		if (e) {
 			while (*e) {
-#if 0
+# if 0
 				puts(*e++);
-#else
+# else
 				/* ash emits: export VAR='VAL'
 				 * bash: declare -x VAR="VAL"
 				 * we follow ash example */
@@ -10802,7 +10897,7 @@ static int FAST_FUNC builtin_export(char
 				printf("export %.*s", (int)(p - s) + 1, s);
 				print_escaped(p + 1);
 				putchar('\n');
-#endif
+# endif
 			}
 			/*fflush_all(); - done after each builtin anyway */
 		}
@@ -10863,7 +10958,7 @@ static int FAST_FUNC builtin_unset(char
 	if (opts == (unsigned)-1)
 		return EXIT_FAILURE;
 	if (opts == 3) {
-		bb_error_msg("unset: -v and -f are exclusive");
+		bb_simple_error_msg("unset: -v and -f are exclusive");
 		return EXIT_FAILURE;
 	}
 	argv += optind;
@@ -11023,7 +11118,7 @@ Test that VAR is a valid variable name?
 
 	optstring = *++argv;
 	if (!optstring || !(var = *++argv)) {
-		bb_error_msg("usage: getopts OPTSTRING VAR [ARGS]");
+		bb_simple_error_msg("usage: getopts OPTSTRING VAR [ARGS]");
 		return EXIT_FAILURE;
 	}
 
@@ -11252,7 +11347,7 @@ static int FAST_FUNC builtin_trap(char *
 	}
 
 	if (!argv[1]) { /* no second arg */
-		bb_error_msg("trap: invalid arguments");
+		bb_simple_error_msg("trap: invalid arguments");
 		return EXIT_FAILURE;
 	}
 
@@ -11293,7 +11388,7 @@ static struct pipe *parse_jobspec(const
 		/* It is "%%", "%+" or "%" - current job */
 		jobnum = G.last_jobid;
 		if (jobnum == 0) {
-			bb_error_msg("no current job");
+			bb_simple_error_msg("no current job");
 			return NULL;
 		}
 	}
@@ -11370,7 +11465,7 @@ static int FAST_FUNC builtin_fg_bg(char
 			delete_finished_job(pi);
 			return EXIT_SUCCESS;
 		}
-		bb_perror_msg("kill (SIGCONT)");
+		bb_simple_perror_msg("kill (SIGCONT)");
 	}
 
 	if (argv[0][0] == 'f') {
@@ -11457,9 +11552,9 @@ static int FAST_FUNC builtin_kill(char *
 
 #if ENABLE_HUSH_WAIT
 /* http://www.opengroup.org/onlinepubs/9699919799/utilities/wait.html */
-#if !ENABLE_HUSH_JOB
-# define wait_for_child_or_signal(pipe,pid) wait_for_child_or_signal(pid)
-#endif
+# if !ENABLE_HUSH_JOB
+#  define wait_for_child_or_signal(pipe,pid) wait_for_child_or_signal(pid)
+# endif
 static int wait_for_child_or_signal(struct pipe *waitfor_pipe, pid_t waitfor_pid)
 {
 	int ret = 0;
@@ -11491,7 +11586,7 @@ static int wait_for_child_or_signal(stru
 /* Can't pass waitfor_pipe into checkjobs(): it won't be interruptible */
 		ret = checkjobs(NULL, waitfor_pid); /* waitpid(WNOHANG) inside */
 		debug_printf_exec("checkjobs:%d\n", ret);
-#if ENABLE_HUSH_JOB
+# if ENABLE_HUSH_JOB
 		if (waitfor_pipe) {
 			int rcode = job_exited_or_stopped(waitfor_pipe);
 			debug_printf_exec("job_exited_or_stopped:%d\n", rcode);
@@ -11501,7 +11596,7 @@ static int wait_for_child_or_signal(stru
 				break;
 			}
 		}
-#endif
+# endif
 		/* if ECHILD, there are no children (ret is -1 or 0) */
 		/* if ret == 0, no children changed state */
 		/* if ret != 0, it's exitcode+1 of exited waitfor_pid child */
@@ -11509,12 +11604,12 @@ static int wait_for_child_or_signal(stru
 			ret--;
 			if (ret < 0) /* if ECHILD, may need to fix "ret" */
 				ret = 0;
-#if ENABLE_HUSH_BASH_COMPAT
+# if ENABLE_HUSH_BASH_COMPAT
 			if (waitfor_pid == -1 && errno == ECHILD) {
 				/* exitcode of "wait -n" with no children is 127, not 0 */
 				ret = 127;
 			}
-#endif
+# endif
 			sigprocmask(SIG_SETMASK, &oldset, NULL);
 			break;
 		}
@@ -11522,6 +11617,16 @@ static int wait_for_child_or_signal(stru
 		/* It is vitally important for sigsuspend that SIGCHLD has non-DFL handler! */
 		/* Note: sigsuspend invokes signal handler */
 		sigsuspend(&oldset);
+		/* ^^^ add "sigdelset(&oldset, SIGCHLD)" before sigsuspend
+		 * to make sure SIGCHLD is not masked off?
+		 * It was reported that this:
+		 *	fn() { : | return; }
+		 *	shopt -s lastpipe
+		 *	fn
+		 *	exec hush SCRIPT
+		 * under bash 4.4.23 runs SCRIPT with SIGCHLD masked,
+		 * making "wait" commands in SCRIPT block forever.
+		 */
  restore:
 		sigprocmask(SIG_SETMASK, &oldset, NULL);
  check_sig:
@@ -11543,14 +11648,14 @@ static int FAST_FUNC builtin_wait(char *
 	int status;
 
 	argv = skip_dash_dash(argv);
-#if ENABLE_HUSH_BASH_COMPAT
+# if ENABLE_HUSH_BASH_COMPAT
 	if (argv[0] && strcmp(argv[0], "-n") == 0) {
 		/* wait -n */
 		/* (bash accepts "wait -n PID" too and ignores PID) */
 		G.dead_job_exitcode = -1;
 		return wait_for_child_or_signal(NULL, -1 /*no job, wait for one job*/);
 	}
-#endif
+# endif
 	if (argv[0] == NULL) {
 		/* Don't care about wait results */
 		/* Note 1: must wait until there are no more children */
@@ -11574,7 +11679,7 @@ static int FAST_FUNC builtin_wait(char *
 	do {
 		pid_t pid = bb_strtou(*argv, NULL, 10);
 		if (errno || pid <= 0) {
-#if ENABLE_HUSH_JOB
+# if ENABLE_HUSH_JOB
 			if (argv[0][0] == '%') {
 				struct pipe *wait_pipe;
 				ret = 127; /* bash compat for bad jobspecs */
@@ -11591,7 +11696,7 @@ static int FAST_FUNC builtin_wait(char *
 				/* else: parse_jobspec() already emitted error msg */
 				continue;
 			}
-#endif
+# endif
 			/* mimic bash message */
 			bb_error_msg("wait: '%s': not a pid or valid job spec", *argv);
 			ret = EXIT_FAILURE;
@@ -11613,7 +11718,7 @@ static int FAST_FUNC builtin_wait(char *
 					ret = G.last_bg_pid_exitcode;
 				} else {
 					/* Example: "wait 1". mimic bash message */
-					bb_error_msg("wait: pid %d is not a child of this shell", (int)pid);
+					bb_error_msg("wait: pid %u is not a child of this shell", (unsigned)pid);
 				}
 			} else {
 				/* ??? */
@@ -11699,6 +11804,12 @@ static int FAST_FUNC builtin_return(char
 	 * 255  <== we also do this
 	 */
 	rc = parse_numeric_argv1(argv, G.last_exitcode, 0);
+# if ENABLE_HUSH_TRAP
+	if (argv[1]) { /* "return ARG" inside a running trap sets $? */
+		debug_printf_exec("G.return_exitcode=%d\n", rc);
+		G.return_exitcode = rc;
+	}
+# endif
 	return rc;
 }
 #endif
diff -urpN busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap2.right busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap2.right
--- busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap2.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap2.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1 @@
+42:42
diff -urpN busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap2.tests busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap2.tests
--- busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap2.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap2.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,8 @@
+# "exit" in trap should not use last command's exitcode,
+# but exitcode on entering the trap.
+$THIS_SH -c '
+ trap "false;exit" term
+ kill $$ &
+ (sleep 1; exit 42)
+'
+echo 42:$?
diff -urpN busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap3.right busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap3.right
--- busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap3.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap3.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,2 @@
+TERM
+42:42
diff -urpN busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap3.tests busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap3.tests
--- busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap3.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap3.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,9 @@
+# "return" in trap should not use last command's exitcode,
+# but exitcode on entering the trap.
+trap "echo TERM;return" term
+f() {
+	(sleep 1; kill $$) &
+	until (exit 42) do (exit 42); done
+}
+f
+echo 42:$?
diff -urpN busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap4.right busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap4.right
--- busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap4.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap4.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,2 @@
+TERM
+11:11
diff -urpN busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap4.tests busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap4.tests
--- busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap4.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap4.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,8 @@
+# "return" in trap sets $? after trap
+trap "echo TERM;return 11" term
+f() {
+	(sleep 1; kill $$) &
+	until (exit 42) do (exit 42); done
+}
+f
+echo 11:$?
diff -urpN busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap5.right busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap5.right
--- busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap5.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap5.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,3 @@
+TERM
+Nested
+Zero:0
diff -urpN busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap5.tests busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap5.tests
--- busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap5.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap5.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,10 @@
+# "return" in trap sets $? after trap...
+# ...but not a nested one!
+g() { echo Nested; return 22; }
+trap "echo TERM;false;g" term
+f() {
+	(kill $$) &
+	sleep 1
+}
+f
+echo Zero:$?
diff -urpN busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap6.right busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap6.right
--- busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap6.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap6.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,2 @@
+INT
+42:42
diff -urpN busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap6.tests busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap6.tests
--- busybox-1.31.1/shell/hush_test/hush-misc/exitcode_trap6.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-misc/exitcode_trap6.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,10 @@
+# "exit" in trap should not use last command's exitcode,
+# but exitcode on entering the trap.
+# Nested trap should not interfere with this.
+$THIS_SH -c '
+ trap "echo INT" int
+ trap "kill -int $$;exit" term
+ kill $$ &
+ (sleep 1; exit 42)
+'
+echo 42:$?
diff -urpN busybox-1.31.1/shell/hush_test/hush-psubst/tick_in_heredoc.right busybox-1.32.0/shell/hush_test/hush-psubst/tick_in_heredoc.right
--- busybox-1.31.1/shell/hush_test/hush-psubst/tick_in_heredoc.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-psubst/tick_in_heredoc.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,5 @@
+1
+
+2
+
+3
diff -urpN busybox-1.31.1/shell/hush_test/hush-psubst/tick_in_heredoc.tests busybox-1.32.0/shell/hush_test/hush-psubst/tick_in_heredoc.tests
--- busybox-1.31.1/shell/hush_test/hush-psubst/tick_in_heredoc.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-psubst/tick_in_heredoc.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,7 @@
+cat <<END
+1
+$(echo "")
+2
+`echo ""`
+3
+END
diff -urpN busybox-1.31.1/shell/hush_test/hush-quoting/negative_arith.right busybox-1.32.0/shell/hush_test/hush-quoting/negative_arith.right
--- busybox-1.31.1/shell/hush_test/hush-quoting/negative_arith.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-quoting/negative_arith.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,2 @@
+tempfile0.tmp tempfile9.tmp
+tempfile0.tmp tempfile1.tmp tempfile9.tmp
diff -urpN busybox-1.31.1/shell/hush_test/hush-quoting/negative_arith.tests busybox-1.32.0/shell/hush_test/hush-quoting/negative_arith.tests
--- busybox-1.31.1/shell/hush_test/hush-quoting/negative_arith.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-quoting/negative_arith.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,8 @@
+>tempfile0.tmp
+>tempfile1.tmp
+>tempfile9.tmp
+# The [...] is interpreted as: "any of the chars 0, -, and 9"
+echo tempfile[0"$((-9))"].tmp
+# The [...] is [0-9], interpreted as: "any digit"
+echo tempfile[0$((-9))].tmp
+rm tempfile?.tmp
diff -urpN busybox-1.31.1/shell/hush_test/hush-redir/redir_stdin1.right busybox-1.32.0/shell/hush_test/hush-redir/redir_stdin1.right
--- busybox-1.31.1/shell/hush_test/hush-redir/redir_stdin1.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-redir/redir_stdin1.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,3 @@
+#Testing that stdin redirect is restored
+read2
+Ok:0
diff -urpN busybox-1.31.1/shell/hush_test/hush-redir/redir_stdin1.tests busybox-1.32.0/shell/hush_test/hush-redir/redir_stdin1.tests
--- busybox-1.31.1/shell/hush_test/hush-redir/redir_stdin1.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-redir/redir_stdin1.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,7 @@
+#Testing that stdin redirect is restored
+echo read2 | $THIS_SH -c 'read r <redir_stdin1.tests
+echo $r
+read r
+echo $r
+'
+echo Ok:$?
diff -urpN busybox-1.31.1/shell/hush_test/hush-vars/var_10.right busybox-1.32.0/shell/hush_test/hush-vars/var_10.right
--- busybox-1.31.1/shell/hush_test/hush-vars/var_10.right	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-vars/var_10.right	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,3 @@
+Zero:0
+One:1
+Done:0
diff -urpN busybox-1.31.1/shell/hush_test/hush-vars/var_10.tests busybox-1.32.0/shell/hush_test/hush-vars/var_10.tests
--- busybox-1.31.1/shell/hush_test/hush-vars/var_10.tests	1970-01-01 04:00:00.000000000 +0400
+++ busybox-1.32.0/shell/hush_test/hush-vars/var_10.tests	2020-06-26 22:47:44.000000000 +0400
@@ -0,0 +1,4 @@
+set -- : 2 3 4 5 6 7 8 9 ten eleven
+echo Zero$10
+echo One$11
+echo Done:$?
diff -urpN busybox-1.31.1/shell/math.c busybox-1.32.0/shell/math.c
--- busybox-1.31.1/shell/math.c	2019-10-21 18:54:40.000000000 +0400
+++ busybox-1.32.0/shell/math.c	2020-06-26 22:47:44.000000000 +0400
@@ -537,25 +537,23 @@ static arith_t strto_arith_t(const char
 	base = (unsigned)n;
 	n = 0;
 	nptr = *endptr + 1;
-	/* bash allows "N#" (empty "nnnn" part) */
 	for (;;) {
 		unsigned digit = (unsigned)*nptr - '0';
-		if (digit >= 10) {
-			/* *nptr is not 0..9 */
-			if (*nptr > 'z')
-				break; /* this rejects e.g. $((64#~)) */
+		if (digit >= 10 /* not 0..9 */
+		 && digit <= 'z' - '0' /* needed to reject e.g. $((64#~)) */
+		) {
 			/* in bases up to 36, case does not matter for a-z */
 			digit = (unsigned)(*nptr | 0x20) - ('a' - 10);
 			if (base > 36 && *nptr <= '_') {
-				/* otherwise, A-Z,@,_ are 36..61,62,63 */
-				if (*nptr == '@')
-					digit = 62;
-				else if (*nptr == '_')
+				/* otherwise, A-Z,@,_ are 36-61,62,63 */
+				if (*nptr == '_')
 					digit = 63;
+				else if (*nptr == '@')
+					digit = 62;
 				else if (digit < 36) /* A-Z */
 					digit += 36 - 10;
 				else
-					break; /* error, such as [ or \ */
+					break; /* error: one of [\]^ */
 			}
 			//bb_error_msg("ch:'%c'%d digit:%u", *nptr, *nptr, digit);
 			//if (digit < 10) - example where we need this?
@@ -567,6 +565,12 @@ static arith_t strto_arith_t(const char
 		n = n * base + digit;
 		nptr++;
 	}
+	/* Note: we do not set errno on bad chars, we just set a pointer
+	 * to the first invalid char. For example, this allows
+	 * "N#" (empty "nnnn" part): 64#+1 is a valid expression,
+	 * it means 64# + 1, whereas 64#~... is not, since ~ is not a valid
+	 * operator.
+	 */
 	*endptr = (char*)nptr;
 	return n;
 }
diff -urpN busybox-1.31.1/shell/shell_common.c busybox-1.32.0/shell/shell_common.c
--- busybox-1.31.1/shell/shell_common.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/shell/shell_common.c	2020-06-26 22:47:44.000000000 +0400
@@ -322,52 +322,91 @@ shell_builtin_read(struct builtin_read_p
 struct limits {
 	uint8_t cmd;            /* RLIMIT_xxx fit into it */
 	uint8_t factor_shift;   /* shift by to get rlim_{cur,max} values */
-	const char *name;
 };
 
 static const struct limits limits_tbl[] = {
-	{ RLIMIT_CORE,		9,	"core file size (blocks)" }, // -c
-	{ RLIMIT_DATA,		10,	"data seg size (kb)" },      // -d
-	{ RLIMIT_NICE,		0,	"scheduling priority" },     // -e
-	{ RLIMIT_FSIZE,		9,	"file size (blocks)" },      // -f
+	{ RLIMIT_CORE,		9,	}, // -c
+	{ RLIMIT_DATA,		10,	}, // -d
+	{ RLIMIT_NICE,		0,	}, // -e
+	{ RLIMIT_FSIZE,		9,	}, // -f
 #define LIMIT_F_IDX     3
 #ifdef RLIMIT_SIGPENDING
-	{ RLIMIT_SIGPENDING,	0,	"pending signals" },         // -i
+	{ RLIMIT_SIGPENDING,	0,	}, // -i
 #endif
 #ifdef RLIMIT_MEMLOCK
-	{ RLIMIT_MEMLOCK,	10,	"max locked memory (kb)" },  // -l
+	{ RLIMIT_MEMLOCK,	10,	}, // -l
 #endif
 #ifdef RLIMIT_RSS
-	{ RLIMIT_RSS,		10,	"max memory size (kb)" },    // -m
+	{ RLIMIT_RSS,		10,	}, // -m
 #endif
 #ifdef RLIMIT_NOFILE
-	{ RLIMIT_NOFILE,	0,	"open files" },              // -n
+	{ RLIMIT_NOFILE,	0,	}, // -n
 #endif
 #ifdef RLIMIT_MSGQUEUE
-	{ RLIMIT_MSGQUEUE,	0,	"POSIX message queues (bytes)" }, // -q
+	{ RLIMIT_MSGQUEUE,	0,	}, // -q
 #endif
 #ifdef RLIMIT_RTPRIO
-	{ RLIMIT_RTPRIO,	0,	"real-time priority" },      // -r
+	{ RLIMIT_RTPRIO,	0,	}, // -r
 #endif
 #ifdef RLIMIT_STACK
-	{ RLIMIT_STACK,		10,	"stack size (kb)" },         // -s
+	{ RLIMIT_STACK,		10,	}, // -s
 #endif
 #ifdef RLIMIT_CPU
-	{ RLIMIT_CPU,		0,	"cpu time (seconds)" },      // -t
+	{ RLIMIT_CPU,		0,	}, // -t
 #endif
 #ifdef RLIMIT_NPROC
-	{ RLIMIT_NPROC,		0,	"max user processes" },      // -u
+	{ RLIMIT_NPROC,		0,	}, // -u
 #endif
 #ifdef RLIMIT_AS
-	{ RLIMIT_AS,		10,	"virtual memory (kb)" },     // -v
+	{ RLIMIT_AS,		10,	}, // -v
 #endif
 #ifdef RLIMIT_LOCKS
-	{ RLIMIT_LOCKS,		0,	"file locks" },              // -x
+	{ RLIMIT_LOCKS,		0,	}, // -x
 #endif
 };
 // bash also shows:
 //pipe size            (512 bytes, -p) 8
 
+static const char limits_help[] ALIGN1 =
+	"core file size (blocks)"          // -c
+	"\0""data seg size (kb)"           // -d
+	"\0""scheduling priority"          // -e
+	"\0""file size (blocks)"           // -f
+#ifdef RLIMIT_SIGPENDING
+	"\0""pending signals"              // -i
+#endif
+#ifdef RLIMIT_MEMLOCK
+	"\0""max locked memory (kb)"       // -l
+#endif
+#ifdef RLIMIT_RSS
+	"\0""max memory size (kb)"         // -m
+#endif
+#ifdef RLIMIT_NOFILE
+	"\0""open files"                   // -n
+#endif
+#ifdef RLIMIT_MSGQUEUE
+	"\0""POSIX message queues (bytes)" // -q
+#endif
+#ifdef RLIMIT_RTPRIO
+	"\0""real-time priority"           // -r
+#endif
+#ifdef RLIMIT_STACK
+	"\0""stack size (kb)"              // -s
+#endif
+#ifdef RLIMIT_CPU
+	"\0""cpu time (seconds)"           // -t
+#endif
+#ifdef RLIMIT_NPROC
+	"\0""max user processes"           // -u
+#endif
+#ifdef RLIMIT_AS
+	"\0""virtual memory (kb)"          // -v
+#endif
+#ifdef RLIMIT_LOCKS
+	"\0""file locks"                   // -x
+#endif
+;
+
 static const char limit_chars[] ALIGN1 =
 			"c"
 			"d"
@@ -558,10 +597,12 @@ shell_builtin_ulimit(char **argv)
 	if (!(opts & (OPT_hard | OPT_soft)))
 		opts |= (OPT_hard | OPT_soft);
 	if (opts & OPT_all) {
+		const char *help = limits_help;
 		for (i = 0; i < ARRAY_SIZE(limits_tbl); i++) {
 			getrlimit(limits_tbl[i].cmd, &limit);
-			printf("%-32s(-%c) ", limits_tbl[i].name, limit_chars[i]);
+			printf("%-32s(-%c) ", help, limit_chars[i]);
 			printlim(opts, &limit, &limits_tbl[i]);
+			help += strlen(help) + 1;
 		}
 		return EXIT_SUCCESS;
 	}
@@ -592,7 +633,7 @@ shell_builtin_ulimit(char **argv)
 		getrlimit(limits_tbl[i].cmd, &limit);
 		if (!val_str) {
 			if (opt_cnt > 1)
-				printf("%-32s(-%c) ", limits_tbl[i].name, limit_chars[i]);
+				printf("%-32s(-%c) ", nth_string(limits_help, i), limit_chars[i]);
 			printlim(opts, &limit, &limits_tbl[i]);
 		} else {
 			rlim_t val = RLIM_INFINITY;
@@ -619,7 +660,7 @@ shell_builtin_ulimit(char **argv)
 				limit.rlim_cur = val;
 //bb_error_msg("setrlimit(%d, %lld, %lld)", limits_tbl[i].cmd, (long long)limit.rlim_cur, (long long)limit.rlim_max);
 			if (setrlimit(limits_tbl[i].cmd, &limit) < 0) {
-				bb_perror_msg("error setting limit");
+				bb_simple_perror_msg("error setting limit");
 				return EXIT_FAILURE;
 			}
 		}
diff -urpN busybox-1.31.1/sysklogd/klogd.c busybox-1.32.0/sysklogd/klogd.c
--- busybox-1.31.1/sysklogd/klogd.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/sysklogd/klogd.c	2020-06-26 22:47:44.000000000 +0400
@@ -244,7 +244,7 @@ int klogd_main(int argc UNUSED_PARAM, ch
 		if (n < 0) {
 			if (errno == EINTR)
 				continue;
-			bb_perror_msg(READ_ERROR);
+			bb_simple_perror_msg(READ_ERROR);
 			break;
 		}
 		start[n] = '\0';
diff -urpN busybox-1.31.1/sysklogd/logread.c busybox-1.32.0/sysklogd/logread.c
--- busybox-1.31.1/sysklogd/logread.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/sysklogd/logread.c	2020-06-26 22:47:44.000000000 +0400
@@ -88,7 +88,7 @@ static void error_exit(const char *str)
 }
 #else
 /* On Linux, shmdt is not mandatory on exit */
-# define error_exit(str) bb_perror_msg_and_die(str)
+# define error_exit(str) bb_simple_perror_msg_and_die(str)
 #endif
 
 /*
diff -urpN busybox-1.31.1/sysklogd/syslogd.c busybox-1.32.0/sysklogd/syslogd.c
--- busybox-1.31.1/sysklogd/syslogd.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/sysklogd/syslogd.c	2020-06-26 22:47:44.000000000 +0400
@@ -64,6 +64,14 @@
 //config:	help
 //config:	Supports restricted syslogd config. See docs/syslog.conf.txt
 //config:
+//config:config FEATURE_SYSLOGD_PRECISE_TIMESTAMPS
+//config:	bool "Include milliseconds in timestamps"
+//config:	default n
+//config:	depends on SYSLOGD
+//config:	help
+//config:	Includes milliseconds (HH:MM:SS.mmm) in timestamp when
+//config:	timestamps are added.
+//config:
 //config:config FEATURE_SYSLOGD_READ_BUFFER_SIZE
 //config:	int "Read buffer size in bytes"
 //config:	default 256
@@ -276,7 +284,7 @@ struct globals {
 	/* ...then copy to parsebuf, escaping control chars */
 	/* (can grow x2 max) */
 	char parsebuf[MAX_READ*2];
-	/* ...then sprintf into printbuf, adding timestamp (15 chars),
+	/* ...then sprintf into printbuf, adding timestamp (15 or 19 chars),
 	 * host (64), fac.prio (20) to the message */
 	/* (growth by: 15 + 64 + 20 + delims = ~110) */
 	char printbuf[MAX_READ*2 + 128];
@@ -572,12 +580,12 @@ static void ipcsyslog_init(void)
 
 	G.shmid = shmget(KEY_ID, G.shm_size, IPC_CREAT | 0644);
 	if (G.shmid == -1) {
-		bb_perror_msg_and_die("shmget");
+		bb_simple_perror_msg_and_die("shmget");
 	}
 
 	G.shbuf = shmat(G.shmid, NULL, 0);
 	if (G.shbuf == (void*) -1L) { /* shmat has bizarre error return */
-		bb_perror_msg_and_die("shmat");
+		bb_simple_perror_msg_and_die("shmat");
 	}
 
 	memset(G.shbuf, 0, G.shm_size);
@@ -592,7 +600,7 @@ static void ipcsyslog_init(void)
 			if (G.s_semid != -1)
 				return;
 		}
-		bb_perror_msg_and_die("semget");
+		bb_simple_perror_msg_and_die("semget");
 	}
 }
 
@@ -603,7 +611,7 @@ static void log_to_shmem(const char *msg
 	int len;
 
 	if (semop(G.s_semid, G.SMwdn, 3) == -1) {
-		bb_perror_msg_and_die("SMwdn");
+		bb_simple_perror_msg_and_die("SMwdn");
 	}
 
 	/* Circular Buffer Algorithm:
@@ -631,7 +639,7 @@ static void log_to_shmem(const char *msg
 		goto again;
 	}
 	if (semop(G.s_semid, G.SMwup, 1) == -1) {
-		bb_perror_msg_and_die("SMwup");
+		bb_simple_perror_msg_and_die("SMwup");
 	}
 	if (DEBUG)
 		printf("tail:%d\n", G.shbuf->tail);
@@ -832,12 +840,24 @@ static void timestamp_and_log(int pri, c
 		msg += 16;
 	}
 
+#if ENABLE_FEATURE_SYSLOGD_PRECISE_TIMESTAMPS
+	if (!timestamp) {
+		struct timeval tv;
+		gettimeofday(&tv, NULL);
+		now = tv.tv_sec;
+		timestamp = ctime(&now) + 4; /* skip day of week */
+		/* overwrite year by milliseconds, zero terminate */
+		sprintf(timestamp + 15, ".%03u", (unsigned)tv.tv_usec / 1000u);
+	} else {
+		timestamp[15] = '\0';
+	}
+#else
 	if (!timestamp) {
 		time(&now);
 		timestamp = ctime(&now) + 4; /* skip day of week */
 	}
-
 	timestamp[15] = '\0';
+#endif
 
 	if (option_mask32 & OPT_kmsg) {
 		log_to_kmsg(pri, msg);
diff -urpN busybox-1.31.1/testsuite/awk.tests busybox-1.32.0/testsuite/awk.tests
--- busybox-1.31.1/testsuite/awk.tests	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/testsuite/awk.tests	2020-06-26 22:47:44.000000000 +0400
@@ -85,7 +85,8 @@ testing "awk floating const with leading
 	"" "\n"
 
 # long field seps requiring regex
-testing "awk long field sep" "awk -F-- '{ print NF, length(\$NF), \$NF }'" \
+testing "awk long field sep" \
+	"awk -F-- '{ print NF, length(\$NF), \$NF }'" \
 	"2 0 \n3 0 \n4 0 \n5 0 \n" \
 	"" \
 	"a--\na--b--\na--b--c--\na--b--c--d--"
@@ -317,6 +318,26 @@ testing "awk length()" \
 	"3\n3\n3\n3\n" \
 	"" "qwe"
 
+testing "awk print length, 1" \
+	"awk '{ print length, 1 }'" \
+	"0 1\n" \
+	"" "\n"
+
+testing "awk print length 1" \
+	"awk '{ print length 1 }'" \
+	"01\n" \
+	"" "\n"
+
+testing "awk length == 0" \
+	"awk 'length == 0 { print \"foo\" }'" \
+	"foo\n" \
+	"" "\n"
+
+testing "awk if (length == 0)" \
+	"awk '{ if (length == 0) { print \"bar\" } }'" \
+	"bar\n" \
+	"" "\n"
+
 testing "awk -f and ARGC" \
 	"awk -f - input" \
 	"re\n2\n" \
@@ -369,5 +390,13 @@ testing 'awk negative field access' \
 	'' \
 	'anything'
 
+# was misinterpreted as (("str"++) i) instead of ("str" (++i))
+# (and was executed: "str"++ is "0", thus concatenating "0" and "1"):
+testing 'awk do not allow "str"++' \
+	'awk -v i=1 "BEGIN {print \"str\" ++i}"' \
+	"str2\n" \
+	'' \
+	'anything'
+
 
 exit $FAILCOUNT
diff -urpN busybox-1.31.1/testsuite/bc.tests busybox-1.32.0/testsuite/bc.tests
--- busybox-1.31.1/testsuite/bc.tests	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/testsuite/bc.tests	2020-06-26 22:47:44.000000000 +0400
@@ -187,6 +187,11 @@ testing "bc { print 1 }" \
 	"1" \
 	"" "{ print 1 }"
 
+testing "bc comparison 1" \
+	"bc" \
+	"1\n" \
+	"" "-10 < -9"
+
 testing "bc nested loops and breaks" \
 	"bc" \
 	"\
diff -urpN busybox-1.31.1/testsuite/cpio.tests busybox-1.32.0/testsuite/cpio.tests
--- busybox-1.31.1/testsuite/cpio.tests	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/testsuite/cpio.tests	2020-06-26 22:47:44.000000000 +0400
@@ -129,7 +129,7 @@ SKIP=
 
 optional FEATURE_CPIO_O
 testing "cpio uses by default uid/gid" \
-"echo $0 | cpio -o -H newc | cpio -tv 2>&1 | tail -n +2 | awk ' { print \$2 } '; echo \$?" \
+"echo $0 | cpio -o -H newc | cpio -tv 2>&1 | head -n1 | awk ' { print \$2 } '; echo \$?" \
 "\
 $user/$group
 0
@@ -138,7 +138,7 @@ SKIP=
 
 optional FEATURE_CPIO_O
 testing "cpio -R with create" \
-"echo $0 | cpio -o -H newc -R 1234:5678 | cpio -tv 2>&1 | tail -n +2 | awk ' { print \$2 } '; echo \$?" \
+"echo $0 | cpio -o -H newc -R 1234:5678 | cpio -tv 2>&1 | head -n1 | awk ' { print \$2 } '; echo \$?" \
 "\
 1234/5678
 0
@@ -147,7 +147,7 @@ SKIP=
 
 optional FEATURE_CPIO_O
 testing "cpio -R with extract" \
-"echo $0 | cpio -o -H newc | cpio -tv -R 8765:4321 2>&1 | tail -n +2 | awk ' { print \$2 } '; echo \$?" \
+"echo $0 | cpio -o -H newc | cpio -tv -R 8765:4321 2>&1 | head -n1 | awk ' { print \$2 } '; echo \$?" \
 "\
 8765/4321
 0
diff -urpN busybox-1.31.1/testsuite/grep.tests busybox-1.32.0/testsuite/grep.tests
--- busybox-1.31.1/testsuite/grep.tests	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/testsuite/grep.tests	2020-06-26 22:47:44.000000000 +0400
@@ -129,6 +129,12 @@ testing "grep -v -f EMPTY_FILE" \
 	"" \
 	"test\n"
 
+testing "grep -vxf EMPTY_FILE" \
+	"grep -vxf input" \
+	"test\n" \
+	"" \
+	"test\n"
+
 testing "grep -Fw matches only words" \
 	"grep -Fw foo input" \
 	"" \
@@ -184,6 +190,18 @@ testing "grep -x -v -e EXP1 -e EXP2 find
 	"" \
 	"  aa bb cc\n"
 
+testing "grep PATTERN can be a newline-delimited list" \
+	'grep -Fv "$(printf "foo\nbar\n")"' \
+	"baz\n" \
+	"" \
+	"foo\nbar\nbaz\n"
+
+testing "grep -e PATTERN can be a newline-delimited list" \
+	'grep -Fv -e "$(printf "foo\nbar\n")"' \
+	"baz\n" \
+	"" \
+	"foo\nbar\nbaz\n"
+
 # -r on symlink to dir should recurse into dir
 mkdir -p grep.testdir/foo
 echo bar > grep.testdir/foo/file
diff -urpN busybox-1.31.1/testsuite/mdev.tests busybox-1.32.0/testsuite/mdev.tests
--- busybox-1.31.1/testsuite/mdev.tests	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/testsuite/mdev.tests	2020-06-26 22:47:44.000000000 +0400
@@ -93,7 +93,7 @@ SKIP=
 # continuing to use directory structure from prev test
 rm -rf mdev.testdir/dev/*
 echo "sda 0:0 444 >disk/scsiA" >mdev.testdir/etc/mdev.conf
-optional STATIC FEATURE_MDEV_CONF FEATURE_MDEV_RENAME FEATURE_LS_RECURSIVE FEATURE_LS_TIMESTAMPS FEATURE_LS_USERNAME
+optional STATIC FEATURE_MDEV_CONF FEATURE_MDEV_RENAME FEATURE_LS_RECURSIVE FEATURE_LS_TIMESTAMPS FEATURE_LS_USERNAME FEATURE_LS_SORTFILES
 testing "mdev move/symlink rule '>bar/baz'" \
 	"env - PATH=$PATH ACTION=add DEVPATH=/block/sda chroot mdev.testdir /mdev 2>&1;
 	ls -lnR mdev.testdir/dev | $FILTER_LS2" \
@@ -111,7 +111,7 @@ SKIP=
 # continuing to use directory structure from prev test
 rm -rf mdev.testdir/dev/*
 echo "sda 0:0 444 >disk/" >mdev.testdir/etc/mdev.conf
-optional STATIC FEATURE_MDEV_CONF FEATURE_MDEV_RENAME FEATURE_LS_RECURSIVE FEATURE_LS_TIMESTAMPS FEATURE_LS_USERNAME
+optional STATIC FEATURE_MDEV_CONF FEATURE_MDEV_RENAME FEATURE_LS_RECURSIVE FEATURE_LS_TIMESTAMPS FEATURE_LS_USERNAME FEATURE_LS_SORTFILES
 testing "mdev move/symlink rule '>bar/'" \
 	"env - PATH=$PATH ACTION=add DEVPATH=/block/sda chroot mdev.testdir /mdev 2>&1;
 	ls -lnR mdev.testdir/dev | $FILTER_LS2" \
diff -urpN busybox-1.31.1/testsuite/patch.tests busybox-1.32.0/testsuite/patch.tests
--- busybox-1.31.1/testsuite/patch.tests	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/testsuite/patch.tests	2020-06-26 22:47:44.000000000 +0400
@@ -75,12 +75,12 @@ zxc
 testing "patch detects already applied hunk" \
 	'patch 2>&1; echo $?; cat input' \
 "\
+patching file input
 Possibly reversed hunk 1 at 4
 Hunk 1 FAILED 1/1.
  abc
 +def
  123
-patching file input
 1
 abc
 def
@@ -103,12 +103,12 @@ def
 testing "patch detects already applied hunk at the EOF" \
 	'patch 2>&1; echo $?; cat input' \
 "\
+patching file input
 Possibly reversed hunk 1 at 4
 Hunk 1 FAILED 1/1.
  abc
  123
 +456
-patching file input
 1
 abc
 123
diff -urpN busybox-1.31.1/testsuite/unexpand.tests busybox-1.32.0/testsuite/unexpand.tests
--- busybox-1.31.1/testsuite/unexpand.tests	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/testsuite/unexpand.tests	2020-06-26 22:47:44.000000000 +0400
@@ -31,6 +31,39 @@ testing "unexpand case 7" "unexpand" \
 testing "unexpand case 8" "unexpand" \
 	"a b\n" "" "a b\n" \
 
+testcase()
+{
+	testing "unexpand flags $*" "unexpand $*" \
+		"$want" "" '        a       b    c'
+}
+
+# tabs=8, Convert only leading sequences of blanks
+want='\ta       b    c'
+testcase
+testcase -f
+testcase -f -t8
+testcase -t8 -f
+testcase -t8 --first-only
+
+# tabs=8, Convert all blanks
+want='\ta\tb    c'
+testcase -a
+testcase -t8
+testcase -a -t8
+
+# tabs=4, Convert all blanks
+want='\t\ta\t\tb\t c'
+testcase -t4
+testcase -a -t4
+testcase -t4 -a
+
+# tabs=4, Convert only leading sequences of blanks
+want='\t\ta       b    c'
+testcase -t4 -f
+testcase -f -t4
+testcase -t4 --first-only
+testcase --first-only -t4
+
 test x"$CONFIG_UNICODE_SUPPORT" = x"y" \
 && test x"$CONFIG_UNICODE_USING_LOCALE" != x"y" \
 && testing "unexpand with unicode characher 0x394" "unexpand" \
diff -urpN busybox-1.31.1/testsuite/xargs.tests busybox-1.32.0/testsuite/xargs.tests
--- busybox-1.31.1/testsuite/xargs.tests	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/testsuite/xargs.tests	2020-06-26 22:47:44.000000000 +0400
@@ -41,4 +41,24 @@ testing "xargs -sNUM test 2" \
 	"echo 1 2 3 4 5 6 7 8 9 0\n""echo 1 2 3 4 5 6 7 8 9\n""echo 1 00\n" \
 	"" "2 3 4 5 6 7 8 9 0 2 3 4 5 6 7 8 9 00\n"
 
+# see that we don't get "argument line too long",
+# but do see the last word, 99999, instead
+optional FEATURE_XARGS_SUPPORT_QUOTES
+testing "xargs argument line too long" \
+	"seq 10000 99999 | sed -e 's/^/\"/' -e 's/$/\"/' | xargs echo | grep -o 99999; echo \$?" \
+	"99999\n0\n" \
+	"" ""
+
+testing "xargs -n1" \
+	"xargs -n1 echo" \
+	"1\n2\n3\n4\n5\n" \
+	"" "1 2 3 4 5\n"
+
+testing "xargs -n2" \
+	"xargs -n2 echo" \
+	"1 2\n3 4\n5\n" \
+	"" "1 2 3 4 5\n"
+
+SKIP=
+
 exit $FAILCOUNT
diff -urpN busybox-1.31.1/util-linux/acpid.c busybox-1.32.0/util-linux/acpid.c
--- busybox-1.31.1/util-linux/acpid.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/acpid.c	2020-06-26 22:47:44.000000000 +0400
@@ -148,7 +148,7 @@ static void process_event(const char *ev
 	const char *args[] = { "run-parts", handler, NULL };
 
 	// log the event
-	bb_error_msg("%s", event);
+	bb_simple_error_msg(event);
 
 	// spawn handler
 	// N.B. run-parts would require scripts to have #!/bin/sh
diff -urpN busybox-1.31.1/util-linux/dmesg.c busybox-1.32.0/util-linux/dmesg.c
--- busybox-1.31.1/util-linux/dmesg.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/dmesg.c	2020-06-26 22:47:44.000000000 +0400
@@ -74,7 +74,7 @@ int dmesg_main(int argc UNUSED_PARAM, ch
 	opts = getopt32(argv, "cs:+n:+r", &len, &level);
 	if (opts & OPT_n) {
 		if (klogctl(8, NULL, (long) level))
-			bb_perror_msg_and_die("klogctl");
+			bb_simple_perror_msg_and_die("klogctl");
 		return EXIT_SUCCESS;
 	}
 
@@ -88,7 +88,7 @@ int dmesg_main(int argc UNUSED_PARAM, ch
 	buf = xmalloc(len);
 	len = klogctl(3 + (opts & OPT_c), buf, len); /* read ring buffer */
 	if (len < 0)
-		bb_perror_msg_and_die("klogctl");
+		bb_simple_perror_msg_and_die("klogctl");
 	if (len == 0)
 		return EXIT_SUCCESS;
 
diff -urpN busybox-1.31.1/util-linux/eject.c busybox-1.32.0/util-linux/eject.c
--- busybox-1.31.1/util-linux/eject.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/eject.c	2020-06-26 22:47:44.000000000 +0400
@@ -70,7 +70,7 @@ static void eject_scsi(const char *dev)
 	sg_io_hdr_t io_hdr;
 
 	if ((ioctl(dev_fd, SG_GET_VERSION_NUM, &i) < 0) || (i < 30000))
-		bb_error_msg_and_die("not a sg device or old sg driver");
+		bb_simple_error_msg_and_die("not a sg device or old sg driver");
 
 	memset(&io_hdr, 0, sizeof(sg_io_hdr_t));
 	io_hdr.interface_id = 'S';
diff -urpN busybox-1.31.1/util-linux/fdformat.c busybox-1.32.0/util-linux/fdformat.c
--- busybox-1.31.1/util-linux/fdformat.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/fdformat.c	2020-06-26 22:47:44.000000000 +0400
@@ -117,7 +117,7 @@ int fdformat_main(int argc UNUSED_PARAM,
 			read_bytes = safe_read(fd, data, n);
 			if (read_bytes != n) {
 				if (read_bytes < 0) {
-					bb_perror_msg(bb_msg_read_error);
+					bb_simple_perror_msg(bb_msg_read_error);
 				}
 				bb_error_msg_and_die("problem reading cylinder %d, "
 					"expected %d, read %d", cyl, n, read_bytes);
diff -urpN busybox-1.31.1/util-linux/fdisk.c busybox-1.32.0/util-linux/fdisk.c
--- busybox-1.31.1/util-linux/fdisk.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/fdisk.c	2020-06-26 22:47:44.000000000 +0400
@@ -299,9 +299,6 @@ static int get_boot(enum action what);
 static int get_boot(void);
 #endif
 
-#define PLURAL   0
-#define SINGULAR 1
-
 static sector_t get_start_sect(const struct partition *p);
 static sector_t get_nr_sects(const struct partition *p);
 
@@ -347,6 +344,7 @@ static const char *const i386_sys_types[
 	"\xa8" "Darwin UFS",
 	"\xa9" "NetBSD",
 	"\xab" "Darwin boot",
+	"\xaf" "HFS / HFS+",
 	"\xb7" "BSDI fs",
 	"\xb8" "BSDI swap",
 	"\xbe" "Solaris boot",
@@ -393,15 +391,12 @@ static const char *const i386_sys_types[
 	"\xc6" "DRDOS/sec (FAT-16)",
 	"\xc7" "Syrinx",
 	"\xda" "Non-FS data",
-	"\xdb" "CP/M / CTOS / ...",/* CP/M or Concurrent CP/M or
-	                              Concurrent DOS or CTOS */
+	"\xdb" "CP/M / CTOS / ...",/* CP/M or Concurrent CP/M or Concurrent DOS or CTOS */
 	"\xde" "Dell Utility",     /* Dell PowerEdge Server utilities */
 	"\xdf" "BootIt",           /* BootIt EMBRM */
-	"\xe1" "DOS access",       /* DOS access or SpeedStor 12-bit FAT
-	                              extended partition */
+	"\xe1" "DOS access",       /* DOS access or SpeedStor 12-bit FAT extended partition */
 	"\xe3" "DOS R/O",          /* DOS R/O or SpeedStor */
-	"\xe4" "SpeedStor",        /* SpeedStor 16-bit FAT extended
-	                              partition < 1024 cyl. */
+	"\xe4" "SpeedStor",        /* SpeedStor 16-bit FAT extended partition <1024 cyl. */
 	"\xf1" "SpeedStor",
 	"\xf4" "SpeedStor",        /* SpeedStor large partition */
 	"\xfe" "LANstep",          /* SpeedStor >1024 cyl. or LANstep */
@@ -511,7 +506,7 @@ static sector_t bb_BLKGETSIZE_sectors(in
 			 * we support can't record more than 32 bit
 			 * sector counts or offsets
 			 */
-			bb_error_msg("device has more than 2^32 sectors, can't use all of them");
+			bb_simple_error_msg("device has more than 2^32 sectors, can't use all of them");
 			v64 = (uint32_t)-1L;
 		}
 		return v64;
@@ -591,18 +586,18 @@ partname(const char *dev, int pno, int l
 	return bufp;
 }
 
+#if ENABLE_FEATURE_SGI_LABEL || ENABLE_FEATURE_OSF_LABEL
 static ALWAYS_INLINE struct partition *
 get_part_table(int i)
 {
 	return ptes[i].part_table;
 }
+#endif
 
-static const char *
-str_units(int n)
-{      /* n==1: use singular */
-	if (n == 1)
-		return display_in_cyl_units ? "cylinder" : "sector";
-	return display_in_cyl_units ? "cylinders" : "sectors";
+static ALWAYS_INLINE const char *
+str_units(void)
+{
+	return display_in_cyl_units ? "cylinder" : "sector";
 }
 
 static int
@@ -1778,8 +1773,8 @@ change_units(void)
 {
 	display_in_cyl_units = !display_in_cyl_units;
 	update_units();
-	printf("Changing display/entry units to %s\n",
-		str_units(PLURAL));
+	printf("Changing display/entry units to %ss\n",
+		str_units());
 }
 
 static void
@@ -2030,8 +2025,7 @@ check_consistency(const struct partition
 static void
 list_disk_geometry(void)
 {
-	ullong bytes = ((ullong)total_number_of_sectors << 9);
-	ullong xbytes = bytes / (1024*1024);
+	ullong xbytes = total_number_of_sectors / (1024*1024 / 512);
 	char x = 'M';
 
 	if (xbytes >= 10000) {
@@ -2041,11 +2035,12 @@ list_disk_geometry(void)
 	}
 	printf("Disk %s: %llu %cB, %llu bytes, %"SECT_FMT"u sectors\n"
 		"%u cylinders, %u heads, %u sectors/track\n"
-		"Units: %s of %u * %u = %u bytes\n\n",
+		"Units: %ss of %u * %u = %u bytes\n"
+		"\n",
 		disk_device, xbytes, x,
-		bytes, total_number_of_sectors,
+		((ullong)total_number_of_sectors * 512), total_number_of_sectors,
 		g_cylinders, g_heads, g_sectors,
-		str_units(PLURAL),
+		str_units(),
 		units_per_sector, sector_size, units_per_sector * sector_size
 	);
 }
@@ -2486,7 +2481,7 @@ add_partition(int n, int sys)
 		for (i = 0; i < g_partitions; i++)
 			first[i] = (cround(first[i]) - 1) * units_per_sector;
 
-	snprintf(mesg, sizeof(mesg), "First %s", str_units(SINGULAR));
+	snprintf(mesg, sizeof(mesg), "First %s", str_units());
 	do {
 		temp = start;
 		for (i = 0; i < g_partitions; i++) {
@@ -2548,7 +2543,7 @@ add_partition(int n, int sys)
 	} else {
 		snprintf(mesg, sizeof(mesg),
 			 "Last %s or +size{,K,M,G,T}",
-			 str_units(SINGULAR)
+			 str_units()
 		);
 		stop = read_int(cround(start), cround(limit), cround(limit), cround(start), mesg);
 		if (display_in_cyl_units) {
diff -urpN busybox-1.31.1/util-linux/fdisk_aix.c busybox-1.32.0/util-linux/fdisk_aix.c
--- busybox-1.31.1/util-linux/fdisk_aix.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/fdisk_aix.c	2020-06-26 22:47:44.000000000 +0400
@@ -6,10 +6,10 @@
  */
 
 typedef struct {
-	unsigned int   magic;        /* expect AIX_LABEL_MAGIC */
-	unsigned int   fillbytes1[124];
-	unsigned int   physical_volume_id;
-	unsigned int   fillbytes2[124];
+	uint32_t magic;        /* expect AIX_LABEL_MAGIC */
+	uint32_t fillbytes1[124];
+	uint32_t physical_volume_id;
+	uint32_t fillbytes2[124];
 } aix_partition;
 
 #define AIX_LABEL_MAGIC         0xc9c2d4c1
@@ -17,20 +17,18 @@ typedef struct {
 #define AIX_INFO_MAGIC          0x00072959
 #define AIX_INFO_MAGIC_SWAPPED  0x59290700
 
-#define aixlabel ((aix_partition *)MBRbuffer)
-
-
 /*
-  Changes:
-  * 1999-03-20 Arnaldo Carvalho de Melo <acme@conectiva.com.br>
-  *     Internationalization
-  *
-  * 2003-03-20 Phillip Kesling <pkesling@sgi.com>
-  *      Some fixes
-*/
+ * Changes:
+ * 1999-03-20 Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *     Internationalization
+ *
+ * 2003-03-20 Phillip Kesling <pkesling@sgi.com>
+ *      Some fixes
+ */
 
-static smallint aix_other_endian; /* bool */
-static smallint aix_volumes = 1; /* max 15 */
+// Write-only vars, unfinished code?
+//static smallint aix_other_endian; /* bool */
+//static smallint aix_volumes = 1; /* max 15 */
 
 /*
  * only dealing with free blocks here
@@ -54,18 +52,20 @@ aix_info(void)
 static int
 check_aix_label(void)
 {
+	aix_partition *aixlabel = (void*)MBRbuffer;
+
 	if (aixlabel->magic != AIX_LABEL_MAGIC
 	 && aixlabel->magic != AIX_LABEL_MAGIC_SWAPPED
 	) {
-		current_label_type = 0;
-		aix_other_endian = 0;
+		current_label_type = LABEL_DOS;
+//		aix_other_endian = 0;
 		return 0;
 	}
-	aix_other_endian = (aixlabel->magic == AIX_LABEL_MAGIC_SWAPPED);
+//	aix_other_endian = (aixlabel->magic == AIX_LABEL_MAGIC_SWAPPED);
 	update_units();
 	current_label_type = LABEL_AIX;
 	g_partitions = 1016;
-	aix_volumes = 15;
+//	aix_volumes = 15;
 	aix_info();
 	/*aix_nolabel();*/              /* %% */
 	/*aix_label = 1;*/              /* %% */
diff -urpN busybox-1.31.1/util-linux/fdisk_gpt.c busybox-1.32.0/util-linux/fdisk_gpt.c
--- busybox-1.31.1/util-linux/fdisk_gpt.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/fdisk_gpt.c	2020-06-26 22:47:44.000000000 +0400
@@ -161,7 +161,7 @@ check_gpt_label(void)
 	if (!valid_part_table_flag(MBRbuffer)
 	 || first->sys_ind != LEGACY_GPT_TYPE
 	) {
-		current_label_type = 0;
+		current_label_type = LABEL_DOS;
 		return 0;
 	}
 
@@ -171,7 +171,7 @@ check_gpt_label(void)
 	gpt_hdr = (void *)pe.sectorbuffer;
 
 	if (gpt_hdr->magic != SWAP_LE64(GPT_MAGIC)) {
-		current_label_type = 0;
+		current_label_type = LABEL_DOS;
 		return 0;
 	}
 
@@ -194,7 +194,7 @@ check_gpt_label(void)
 	 || SWAP_LE32(gpt_hdr->hdr_size) > sector_size
 	) {
 		puts("\nwarning: unable to parse GPT disklabel\n");
-		current_label_type = 0;
+		current_label_type = LABEL_DOS;
 		return 0;
 	}
 
diff -urpN busybox-1.31.1/util-linux/fdisk_osf.c busybox-1.32.0/util-linux/fdisk_osf.c
--- busybox-1.31.1/util-linux/fdisk_osf.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/fdisk_osf.c	2020-06-26 22:47:44.000000000 +0400
@@ -470,7 +470,7 @@ xbsd_new_part(void)
 	end = xbsd_dlabel.d_secperunit - 1;
 #endif
 
-	snprintf(mesg, sizeof(mesg), "First %s", str_units(SINGULAR));
+	snprintf(mesg, sizeof(mesg), "First %s", str_units());
 	begin = read_int(bsd_cround(begin), bsd_cround(begin), bsd_cround(end),
 		0, mesg);
 
@@ -478,7 +478,7 @@ xbsd_new_part(void)
 		begin = (begin - 1) * xbsd_dlabel.d_secpercyl;
 
 	snprintf(mesg, sizeof(mesg), "Last %s or +size or +sizeM or +sizeK",
-		str_units(SINGULAR));
+		str_units());
 	end = read_int(bsd_cround(begin), bsd_cround(end), bsd_cround(end),
 		bsd_cround(begin), mesg);
 
diff -urpN busybox-1.31.1/util-linux/fdisk_sgi.c busybox-1.32.0/util-linux/fdisk_sgi.c
--- busybox-1.31.1/util-linux/fdisk_sgi.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/fdisk_sgi.c	2020-06-26 22:47:44.000000000 +0400
@@ -295,19 +295,19 @@ sgi_list_table(int xtra)
 			"%u cylinders, %u physical cylinders\n"
 			"%u extra sects/cyl, interleave %u:1\n"
 			"%s\n"
-			"Units = %s of %u * 512 bytes\n\n",
+			"Units = %ss of %u * 512 bytes\n\n",
 			disk_device, g_heads, g_sectors, g_cylinders,
 			SGI_SSWAP16(sgiparam.pcylcount),
 			SGI_SSWAP16(sgiparam.sparecyl),
 			SGI_SSWAP16(sgiparam.ilfact),
 			(char *)sgilabel,
-			str_units(PLURAL), units_per_sector);
+			str_units(), units_per_sector);
 	} else {
 		printf("\nDisk %s (SGI disk label): "
 			"%u heads, %u sectors, %u cylinders\n"
-			"Units = %s of %u * 512 bytes\n\n",
+			"Units = %ss of %u * 512 bytes\n\n",
 			disk_device, g_heads, g_sectors, g_cylinders,
-			str_units(PLURAL), units_per_sector );
+			str_units(), units_per_sector );
 	}
 
 	w = strlen(disk_device);
@@ -720,7 +720,7 @@ sgi_add_partition(int n, int sys)
 		printf("You got a partition overlap on the disk. Fix it first!\n");
 		return;
 	}
-	snprintf(mesg, sizeof(mesg), "First %s", str_units(SINGULAR));
+	snprintf(mesg, sizeof(mesg), "First %s", str_units());
 	while (1) {
 		if (sys == SGI_VOLUME) {
 			last = sgi_get_lastblock();
@@ -746,7 +746,7 @@ sgi_add_partition(int n, int sys)
 		printf("You will get a partition overlap on the disk. "
 				"Fix it first!\n");
 	}
-	snprintf(mesg, sizeof(mesg), " Last %s", str_units(SINGULAR));
+	snprintf(mesg, sizeof(mesg), " Last %s", str_units());
 	last = read_int(scround(first), scround(last)-1, scround(last)-1,
 			scround(first), mesg)+1;
 	if (display_in_cyl_units)
diff -urpN busybox-1.31.1/util-linux/fdisk_sun.c busybox-1.32.0/util-linux/fdisk_sun.c
--- busybox-1.31.1/util-linux/fdisk_sun.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/fdisk_sun.c	2020-06-26 22:47:44.000000000 +0400
@@ -491,7 +491,7 @@ add_sun_partition(int n, int sys)
 			return;
 		}
 	}
-	snprintf(mesg, sizeof(mesg), "First %s", str_units(SINGULAR));
+	snprintf(mesg, sizeof(mesg), "First %s", str_units());
 	while (1) {
 		if (whole_disk)
 			first = read_int(0, 0, 0, 0, mesg);
@@ -546,7 +546,7 @@ and is of type 'Whole disk'\n");
 	}
 	snprintf(mesg, sizeof(mesg),
 		"Last %s or +size or +sizeM or +sizeK",
-		str_units(SINGULAR));
+		str_units());
 	if (whole_disk)
 		last = read_int(scround(stop2), scround(stop2), scround(stop2),
 				0, mesg);
@@ -567,8 +567,8 @@ and is of type 'Whole disk'\n");
 "You haven't covered the whole disk with the 3rd partition,\n"
 "but your value %u %s covers some other partition.\n"
 "Your entry has been changed to %u %s\n",
-				scround(last), str_units(SINGULAR),
-				scround(stop), str_units(SINGULAR));
+				scround(last), str_units(),
+				scround(stop), str_units());
 			last = stop;
 		}
 	} else if (!whole_disk && last > stop)
@@ -636,20 +636,20 @@ sun_list_table(int xtra)
 		"%u cylinders, %u alternate cylinders, %u physical cylinders\n"
 		"%u extra sects/cyl, interleave %u:1\n"
 		"%s\n"
-		"Units = %s of %u * 512 bytes\n\n",
+		"Units = %ss of %u * 512 bytes\n\n",
 			disk_device, g_heads, g_sectors, SUN_SSWAP16(sunlabel->rspeed),
 			g_cylinders, SUN_SSWAP16(sunlabel->nacyl),
 			SUN_SSWAP16(sunlabel->pcylcount),
 			SUN_SSWAP16(sunlabel->sparecyl),
 			SUN_SSWAP16(sunlabel->ilfact),
 			(char *)sunlabel,
-			str_units(PLURAL), units_per_sector);
+			str_units(), units_per_sector);
 	else
 		printf(
 	"\nDisk %s (Sun disk label): %u heads, %u sectors, %u cylinders\n"
-	"Units = %s of %u * 512 bytes\n\n",
+	"Units = %ss of %u * 512 bytes\n\n",
 			disk_device, g_heads, g_sectors, g_cylinders,
-			str_units(PLURAL), units_per_sector);
+			str_units(), units_per_sector);
 
 	printf("%*s Flag    Start       End    Blocks   Id  System\n",
 		w + 1, "Device");
diff -urpN busybox-1.31.1/util-linux/flock.c busybox-1.32.0/util-linux/flock.c
--- busybox-1.31.1/util-linux/flock.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/flock.c	2020-06-26 22:47:44.000000000 +0400
@@ -73,7 +73,7 @@ int flock_main(int argc UNUSED_PARAM, ch
 	) {
 		argv++;
 		if (argv[1])
-			bb_error_msg_and_die("-c takes only one argument");
+			bb_simple_error_msg_and_die("-c takes only one argument");
 		opt |= OPT_c;
 	}
 
diff -urpN busybox-1.31.1/util-linux/fsck_minix.c busybox-1.32.0/util-linux/fsck_minix.c
--- busybox-1.31.1/util-linux/fsck_minix.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/fsck_minix.c	2020-06-26 22:47:44.000000000 +0400
@@ -321,7 +321,7 @@ static void die(const char *str)
 {
 	if (termios_set)
 		tcsetattr_stdin_TCSANOW(&sv_termios);
-	bb_error_msg_and_die("%s", str);
+	bb_simple_error_msg_and_die(str);
 }
 
 static void push_filename(const char *name)
diff -urpN busybox-1.31.1/util-linux/getopt.c busybox-1.32.0/util-linux/getopt.c
--- busybox-1.31.1/util-linux/getopt.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/getopt.c	2020-06-26 22:47:44.000000000 +0400
@@ -308,7 +308,7 @@ static struct option *add_long_options(s
 				}
 				tokptr[tlen] = '\0';
 				if (tlen == 0)
-					bb_error_msg_and_die("empty long option specified");
+					bb_simple_error_msg_and_die("empty long option specified");
 			}
 			long_options = xrealloc_vector(long_options, 4, long_nr);
 			long_options[long_nr].has_arg = arg_opt;
@@ -380,7 +380,7 @@ int getopt_main(int argc, char **argv)
 			puts(" --");
 			return 0;
 		}
-		bb_error_msg_and_die("missing optstring argument");
+		bb_simple_error_msg_and_die("missing optstring argument");
 	}
 
 	if (argv[1][0] != '-' || compatible) {
@@ -416,7 +416,7 @@ int getopt_main(int argc, char **argv)
 	if (!optstr) {
 		optstr = argv[++n];
 		if (!optstr)
-			bb_error_msg_and_die("missing optstring argument");
+			bb_simple_error_msg_and_die("missing optstring argument");
 	}
 
 	argv[n] = name ? name : argv[0];
diff -urpN busybox-1.31.1/util-linux/hwclock.c busybox-1.32.0/util-linux/hwclock.c
--- busybox-1.31.1/util-linux/hwclock.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/hwclock.c	2020-06-26 22:47:44.000000000 +0400
@@ -132,7 +132,7 @@ static void to_sys_clock(const char **pp
 	tv.tv_sec = read_rtc(pp_rtcname, NULL, utc);
 	tv.tv_usec = 0;
 	if (settimeofday(&tv, &tz))
-		bb_perror_msg_and_die("settimeofday");
+		bb_simple_perror_msg_and_die("settimeofday");
 }
 
 static void from_sys_clock(const char **pp_rtcname, int utc)
@@ -284,7 +284,7 @@ static void set_system_clock_timezone(in
 	if (!utc)
 		tv.tv_sec += tz.tz_minuteswest * 60;
 	if (settimeofday(&tv, &tz))
-		bb_perror_msg_and_die("settimeofday");
+		bb_simple_perror_msg_and_die("settimeofday");
 }
 
 //usage:#define hwclock_trivial_usage
diff -urpN busybox-1.31.1/util-linux/ipcs.c busybox-1.32.0/util-linux/ipcs.c
--- busybox-1.31.1/util-linux/ipcs.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/ipcs.c	2020-06-26 22:47:44.000000000 +0400
@@ -467,7 +467,7 @@ static void print_shm(int shmid)
 	struct ipc_perm *ipcp = &shmds.shm_perm;
 
 	if (shmctl(shmid, IPC_STAT, &shmds) == -1) {
-		bb_perror_msg("shmctl");
+		bb_simple_perror_msg("shmctl");
 		return;
 	}
 
@@ -493,7 +493,7 @@ static void print_msg(int msqid)
 	struct ipc_perm *ipcp = &buf.msg_perm;
 
 	if (msgctl(msqid, IPC_STAT, &buf) == -1) {
-		bb_perror_msg("msgctl");
+		bb_simple_perror_msg("msgctl");
 		return;
 	}
 
@@ -527,7 +527,7 @@ static void print_sem(int semid)
 
 	arg.buf = &semds;
 	if (semctl(semid, 0, IPC_STAT, arg)) {
-		bb_perror_msg("semctl");
+		bb_simple_perror_msg("semctl");
 		return;
 	}
 
@@ -555,7 +555,7 @@ static void print_sem(int semid)
 		zcnt = semctl(semid, i, GETZCNT, arg);
 		pid = semctl(semid, i, GETPID, arg);
 		if (val < 0 || ncnt < 0 || zcnt < 0 || pid < 0) {
-			bb_perror_msg_and_die("semctl");
+			bb_simple_perror_msg_and_die("semctl");
 		}
 		printf("%-10u %-10d %-10d %-10d %-10d\n", i, val, ncnt, zcnt, pid);
 	}
diff -urpN busybox-1.31.1/util-linux/last.c busybox-1.32.0/util-linux/last.c
--- busybox-1.31.1/util-linux/last.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/last.c	2020-06-26 22:47:44.000000000 +0400
@@ -100,7 +100,7 @@ int last_main(int argc UNUSED_PARAM, cha
 	pos = lseek(file, pos - sizeof(ut), SEEK_SET);
 	while ((n = full_read(file, &ut, sizeof(ut))) > 0) {
 		if (n != sizeof(ut)) {
-			bb_perror_msg_and_die("short read");
+			bb_simple_perror_msg_and_die("short read");
 		}
 		n = index_in_strings(_ut_lin, ut.ut_line);
 		if (n == _TILDE) { /* '~' */
diff -urpN busybox-1.31.1/util-linux/losetup.c busybox-1.32.0/util-linux/losetup.c
--- busybox-1.31.1/util-linux/losetup.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/losetup.c	2020-06-26 22:47:44.000000000 +0400
@@ -118,13 +118,13 @@ int losetup_main(int argc UNUSED_PARAM,
 
 		n = get_free_loop();
 		if (n == -1)
-			bb_error_msg_and_die("no free loop devices");
+			bb_simple_error_msg_and_die("no free loop devices");
 		if (n < 0) /* n == -2: no /dev/loop-control, use legacy method */
 			n = 0;
 		/* or: n >= 0: the number of next free loopdev, just verify it */
 		do {
 			if (n > MAX_LOOP_NUM)
-				bb_error_msg_and_die("no free loop devices");
+				bb_simple_error_msg_and_die("no free loop devices");
 			sprintf(dev, LOOP_FORMAT, n++);
 			s = query_loop(dev);
 			free(s);
diff -urpN busybox-1.31.1/util-linux/mdev.c busybox-1.32.0/util-linux/mdev.c
--- busybox-1.31.1/util-linux/mdev.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/mdev.c	2020-06-26 22:47:44.000000000 +0400
@@ -250,18 +250,24 @@
 
 #if DEBUG_LVL >= 1
 # define dbg1(...) do { if (G.verbose) bb_error_msg(__VA_ARGS__); } while(0)
+# define dbg1s(msg) do { if (G.verbose) bb_simple_error_msg(msg); } while(0)
 #else
 # define dbg1(...) ((void)0)
+# define dbg1s(msg) ((void)0)
 #endif
 #if DEBUG_LVL >= 2
 # define dbg2(...) do { if (G.verbose >= 2) bb_error_msg(__VA_ARGS__); } while(0)
+# define dbg2s(msg) do { if (G.verbose >= 2) bb_simple_error_msg(msg); } while(0)
 #else
 # define dbg2(...) ((void)0)
+# define dbg2s(msg) ((void)0)
 #endif
 #if DEBUG_LVL >= 3
 # define dbg3(...) do { if (G.verbose >= 3) bb_error_msg(__VA_ARGS__); } while(0)
+# define dbg3s(msg) do { if (G.verbose >= 3) bb_simple_error_msg(msg); } while(0)
 #else
 # define dbg3(...) ((void)0)
+# define dbg3s(msg) ((void)0)
 #endif
 
 
@@ -1021,7 +1027,7 @@ wait_for_seqfile(unsigned expected_seq)
 			/* seed file: write out seq ASAP */
 			xwrite_str(seq_fd, utoa(expected_seq));
 			xlseek(seq_fd, 0, SEEK_SET);
-			dbg2("first seq written");
+			dbg2s("first seq written");
 			break;
 		}
 		seqbufnum = atoll(seqbuf);
@@ -1165,7 +1171,7 @@ static void daemon_loop(char *temp, int
 
 		len = safe_read(fd, netbuf, sizeof(netbuf) - 1);
 		if (len < 0) {
-			bb_perror_msg_and_die("read");
+			bb_simple_perror_msg_and_die("read");
 		}
 		end = netbuf + len;
 		*end = '\0';
diff -urpN busybox-1.31.1/util-linux/mesg.c busybox-1.32.0/util-linux/mesg.c
--- busybox-1.31.1/util-linux/mesg.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/mesg.c	2020-06-26 22:47:44.000000000 +0400
@@ -65,7 +65,7 @@ int mesg_main(int argc UNUSED_PARAM, cha
 	 */
 
 	if (!isatty(STDIN_FILENO))
-		bb_error_msg_and_die("not a tty");
+		bb_simple_error_msg_and_die("not a tty");
 
 	xfstat(STDIN_FILENO, &sb, "stdin");
 	if (c == 0) {
diff -urpN busybox-1.31.1/util-linux/mkfs_ext2.c busybox-1.32.0/util-linux/mkfs_ext2.c
--- busybox-1.31.1/util-linux/mkfs_ext2.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/mkfs_ext2.c	2020-06-26 22:47:44.000000000 +0400
@@ -266,7 +266,7 @@ int mkfs_ext2_main(int argc UNUSED_PARAM
 	// N.B. what if we format a file? find_mount_point will return false negative since
 	// it is loop block device which is mounted!
 	if (find_mount_point(argv[0], 0))
-		bb_error_msg_and_die("can't format mounted filesystem");
+		bb_simple_error_msg_and_die("can't format mounted filesystem");
 
 	// get size in kbytes
 	kilobytes = get_volume_size_in_bytes(fd, argv[1], 1024, /*extend:*/ !(option_mask32 & OPT_n)) / 1024;
@@ -326,11 +326,11 @@ int mkfs_ext2_main(int argc UNUSED_PARAM
 	kilobytes >>= (blocksize_log2 - EXT2_MIN_BLOCK_LOG_SIZE);
 	nblocks = kilobytes;
 	if (nblocks != kilobytes)
-		bb_error_msg_and_die("block count doesn't fit in 32 bits");
+		bb_simple_error_msg_and_die("block count doesn't fit in 32 bits");
 #define kilobytes kilobytes_unused_after_this
 	// Experimentally, standard mke2fs won't work on images smaller than 60k
 	if (nblocks < 60)
-		bb_error_msg_and_die("need >= 60 blocks");
+		bb_simple_error_msg_and_die("need >= 60 blocks");
 
 	// How many reserved blocks?
 	if (reserved_percent > 50)
diff -urpN busybox-1.31.1/util-linux/mkfs_minix.c busybox-1.32.0/util-linux/mkfs_minix.c
--- busybox-1.31.1/util-linux/mkfs_minix.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/mkfs_minix.c	2020-06-26 22:47:44.000000000 +0400
@@ -262,7 +262,7 @@ static int get_free_block(void)
 	int blk;
 
 	if (G.used_good_blocks + 1 >= MAX_GOOD_BLOCKS)
-		bb_error_msg_and_die("too many bad blocks");
+		bb_simple_error_msg_and_die("too many bad blocks");
 	if (G.used_good_blocks)
 		blk = G.good_blocks_table[G.used_good_blocks - 1] + 1;
 	else
@@ -270,7 +270,7 @@ static int get_free_block(void)
 	while (blk < SB_ZONES && zone_in_use(blk))
 		blk++;
 	if (blk >= SB_ZONES)
-		bb_error_msg_and_die("not enough good blocks");
+		bb_simple_error_msg_and_die("not enough good blocks");
 	G.good_blocks_table[G.used_good_blocks] = blk;
 	G.used_good_blocks++;
 	return blk;
@@ -342,7 +342,7 @@ static void make_bad_inode(void)
 				goto end_bad;
 		}
 	}
-	bb_error_msg_and_die("too many bad blocks");
+	bb_simple_error_msg_and_die("too many bad blocks");
  end_bad:
 	if (ind)
 		write_block(ind, (char *) ind_block);
@@ -398,7 +398,7 @@ static void make_bad_inode2(void)
 		}
 	}
 	/* Could make triple indirect block here */
-	bb_error_msg_and_die("too many bad blocks");
+	bb_simple_error_msg_and_die("too many bad blocks");
  end_bad:
 	if (ind)
 		write_block(ind, (char *) ind_block);
@@ -514,7 +514,7 @@ static void check_blocks(void)
 		if (got == try)
 			continue;
 		if (G.currently_testing < SB_FIRSTZONE)
-			bb_error_msg_and_die("bad blocks before data-area: cannot make fs");
+			bb_simple_error_msg_and_die("bad blocks before data-area: cannot make fs");
 		mark_zone(G.currently_testing);
 		G.badblocks++;
 		G.currently_testing++;
@@ -588,7 +588,7 @@ static void setup_tables(void)
 		SB_ZMAPS = sb_zmaps;
 		/* new SB_ZMAPS, need to recalc NORM_FIRSTZONE */
 	} while (--i);
-	bb_error_msg_and_die("incompatible size/inode count, try different -i N");
+	bb_simple_error_msg_and_die("incompatible size/inode count, try different -i N");
  got_it:
 
 	SB_FIRSTZONE = norm_firstzone;
@@ -623,10 +623,10 @@ int mkfs_minix_main(int argc UNUSED_PARA
 	G.magic = MINIX1_SUPER_MAGIC2;
 
 	if (INODE_SIZE1 * MINIX1_INODES_PER_BLOCK != BLOCK_SIZE)
-		bb_error_msg_and_die("bad inode size");
+		bb_simple_error_msg_and_die("bad inode size");
 #if ENABLE_FEATURE_MINIX2
 	if (INODE_SIZE2 * MINIX2_INODES_PER_BLOCK != BLOCK_SIZE)
-		bb_error_msg_and_die("bad inode size");
+		bb_simple_error_msg_and_die("bad inode size");
 #endif
 
 	opt = getopt32(argv, "ci:l:n:+v", &str_i, &listfile, &G.namelen);
@@ -644,7 +644,7 @@ int mkfs_minix_main(int argc UNUSED_PARA
 #if ENABLE_FEATURE_MINIX2
 		version2 = 1;
 #else
-		bb_error_msg_and_die("not compiled with minix v2 support");
+		bb_simple_error_msg_and_die("not compiled with minix v2 support");
 #endif
 	}
 
@@ -654,14 +654,14 @@ int mkfs_minix_main(int argc UNUSED_PARA
 
 	/* Check if it is mounted */
 	if (find_mount_point(G.device_name, 0))
-		bb_error_msg_and_die("can't format mounted filesystem");
+		bb_simple_error_msg_and_die("can't format mounted filesystem");
 
 	xmove_fd(xopen(G.device_name, O_RDWR), dev_fd);
 
 	G.total_blocks = get_volume_size_in_bytes(dev_fd, argv[1], 1024, /*extend:*/ 1) / 1024;
 
 	if (G.total_blocks < 10)
-		bb_error_msg_and_die("must have at least 10 blocks");
+		bb_simple_error_msg_and_die("must have at least 10 blocks");
 
 	if (version2) {
 		G.magic = MINIX2_SUPER_MAGIC2;
diff -urpN busybox-1.31.1/util-linux/mkfs_reiser.c busybox-1.32.0/util-linux/mkfs_reiser.c
--- busybox-1.31.1/util-linux/mkfs_reiser.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/mkfs_reiser.c	2020-06-26 22:47:44.000000000 +0400
@@ -178,7 +178,7 @@ int mkfs_reiser_main(int argc UNUSED_PAR
 	// N.B. what if we format a file? find_mount_point will return false negative since
 	// it is loop block device which is mounted!
 	if (find_mount_point(argv[0], 0))
-		bb_error_msg_and_die("can't format mounted filesystem");
+		bb_simple_error_msg_and_die("can't format mounted filesystem");
 
 	// open the device, get size in blocks
 	blocks = get_volume_size_in_bytes(fd, argv[1], blocksize, /*extend:*/ 1) / blocksize;
diff -urpN busybox-1.31.1/util-linux/mkfs_vfat.c busybox-1.32.0/util-linux/mkfs_vfat.c
--- busybox-1.31.1/util-linux/mkfs_vfat.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/mkfs_vfat.c	2020-06-26 22:47:44.000000000 +0400
@@ -278,7 +278,7 @@ int mkfs_vfat_main(int argc UNUSED_PARAM
 	if (!S_ISBLK(st.st_mode)) {
 		if (!S_ISREG(st.st_mode)) {
 			if (!argv[1])
-				bb_error_msg_and_die("image size must be specified");
+				bb_simple_error_msg_and_die("image size must be specified");
 		}
 		// not a block device, skip bad sectors check
 		opts &= ~OPT_c;
@@ -399,7 +399,7 @@ int mkfs_vfat_main(int argc UNUSED_PARAM
 	// "mkdosfs -v -F 32 image5k 5" is the minimum:
 	// 2 sectors for FATs and 2 data sectors
 	if ((off_t)(volume_size_sect - reserved_sect) < 4)
-		bb_error_msg_and_die("the image is too small for FAT32");
+		bb_simple_error_msg_and_die("the image is too small for FAT32");
 	sect_per_fat = 1;
 	while (1) {
 		while (1) {
@@ -439,7 +439,7 @@ int mkfs_vfat_main(int argc UNUSED_PARAM
 		}
  next:
 		if (sect_per_clust == 128)
-			bb_error_msg_and_die("can't make FAT32 with >128 sectors/cluster");
+			bb_simple_error_msg_and_die("can't make FAT32 with >128 sectors/cluster");
 		sect_per_clust *= 2;
 		sect_per_fat = (sect_per_fat / 2) | 1;
 	}
diff -urpN busybox-1.31.1/util-linux/mkswap.c busybox-1.32.0/util-linux/mkswap.c
--- busybox-1.31.1/util-linux/mkswap.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/mkswap.c	2020-06-26 22:47:44.000000000 +0400
@@ -75,7 +75,7 @@ static void mkswap_selinux_setcontext(in
 	}
 	return;
  error:
-	bb_perror_msg_and_die("SELinux relabeling failed");
+	bb_simple_perror_msg_and_die("SELinux relabeling failed");
 }
 #else
 # define mkswap_selinux_setcontext(fd, path) ((void)0)
diff -urpN busybox-1.31.1/util-linux/mount.c busybox-1.32.0/util-linux/mount.c
--- busybox-1.31.1/util-linux/mount.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/mount.c	2020-06-26 22:47:44.000000000 +0400
@@ -483,7 +483,7 @@ static void FAST_FUNC update_mtab_entry_
 
 	mountTable = setmntent(bb_path_mtab_file, "r");
 	if (!mountTable) {
-		bb_perror_msg(bb_path_mtab_file);
+		bb_simple_perror_msg(bb_path_mtab_file);
 		return;
 	}
 
@@ -511,7 +511,7 @@ static void FAST_FUNC update_mtab_entry_
 		}
 		endmntent(mountTable);
 	} else if (errno != EROFS)
-		bb_perror_msg(bb_path_mtab_file);
+		bb_simple_perror_msg(bb_path_mtab_file);
 
 	if (ENABLE_FEATURE_CLEAN_UP) {
 		for (i = 0; i < count; i++) {
@@ -739,7 +739,7 @@ static int mount_it_now(struct mntent *m
 	// Abort entirely if permission denied.
 
 	if (rc && errno == EPERM)
-		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 
 	// If the mount was successful, and we're maintaining an old-style
 	// mtab file by hand, add the new entry to it now.
@@ -751,7 +751,7 @@ static int mount_it_now(struct mntent *m
 		int i;
 
 		if (!mountTable) {
-			bb_perror_msg(bb_path_mtab_file);
+			bb_simple_perror_msg(bb_path_mtab_file);
 			goto ret;
 		}
 
@@ -1288,18 +1288,18 @@ static NOINLINE int nfsmount(struct mnte
 	s = strchr(hostname, ',');
 	if (s) {
 		*s = '\0';
-		bb_error_msg("warning: multiple hostnames not supported");
+		bb_simple_error_msg("warning: multiple hostnames not supported");
 	}
 
 	server_addr.sin_family = AF_INET;
 	if (!inet_aton(hostname, &server_addr.sin_addr)) {
 		hp = gethostbyname(hostname);
 		if (hp == NULL) {
-			bb_herror_msg("%s", hostname);
+			bb_simple_herror_msg(hostname);
 			goto fail;
 		}
 		if (hp->h_length != (int)sizeof(struct in_addr)) {
-			bb_error_msg_and_die("only IPv4 is supported");
+			bb_simple_error_msg_and_die("only IPv4 is supported");
 		}
 		memcpy(&server_addr.sin_addr, hp->h_addr_list[0], sizeof(struct in_addr));
 	}
@@ -1389,7 +1389,7 @@ static NOINLINE int nfsmount(struct mnte
 				else if (is_prefixed_with(opteq, "udp"))
 					tcp = 0;
 				else
-					bb_error_msg("warning: unrecognized proto= option");
+					bb_simple_error_msg("warning: unrecognized proto= option");
 				continue;
 			case 20: // "addr" - ignore
 				continue;
@@ -1522,7 +1522,7 @@ static NOINLINE int nfsmount(struct mnte
 				if (nfs_mount_version >= 3)
 					nolock = !val;
 				else
-					bb_error_msg("warning: option nolock is not supported");
+					bb_simple_error_msg("warning: option nolock is not supported");
 				break;
 			case 11: //rdirplus
 				nordirplus = !val;
@@ -1590,11 +1590,11 @@ static NOINLINE int nfsmount(struct mnte
 		} else {
 			hp = gethostbyname(mounthost);
 			if (hp == NULL) {
-				bb_herror_msg("%s", mounthost);
+				bb_simple_herror_msg(mounthost);
 				goto fail;
 			}
 			if (hp->h_length != (int)sizeof(struct in_addr)) {
-				bb_error_msg_and_die("only IPv4 is supported");
+				bb_simple_error_msg_and_die("only IPv4 is supported");
 			}
 			mount_server_addr.sin_family = AF_INET;
 			memcpy(&mount_server_addr.sin_addr, hp->h_addr_list[0], sizeof(struct in_addr));
@@ -1767,18 +1767,18 @@ static NOINLINE int nfsmount(struct mnte
 	/* Create nfs socket for kernel */
 	if (tcp) {
 		if (nfs_mount_version < 3) {
-			bb_error_msg("NFS over TCP is not supported");
+			bb_simple_error_msg("NFS over TCP is not supported");
 			goto fail;
 		}
 		fsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
 	} else
 		fsock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
 	if (fsock < 0) {
-		bb_perror_msg("nfs socket");
+		bb_simple_perror_msg("nfs socket");
 		goto fail;
 	}
 	if (bindresvport(fsock, 0) < 0) {
-		bb_perror_msg("nfs bindresvport");
+		bb_simple_perror_msg("nfs bindresvport");
 		goto fail;
 	}
 	if (port == 0) {
@@ -2047,9 +2047,9 @@ static int singlemount(struct mntent *mp
 			);
 			if (loopfd < 0) {
 				if (errno == EPERM || errno == EACCES)
-					bb_error_msg(bb_msg_perm_denied_are_you_root);
+					bb_simple_error_msg(bb_msg_perm_denied_are_you_root);
 				else
-					bb_perror_msg("can't setup loop device");
+					bb_simple_perror_msg("can't setup loop device");
 				return errno;
 			}
 
@@ -2255,7 +2255,7 @@ int mount_main(int argc UNUSED_PARAM, ch
 		// argument when we get it.
 		if (argv[1]) {
 			if (nonroot)
-				bb_error_msg_and_die(bb_msg_you_must_be_root);
+				bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 			mtpair->mnt_fsname = argv[0];
 			mtpair->mnt_dir = argv[1];
 			mtpair->mnt_type = fstype;
@@ -2272,7 +2272,7 @@ int mount_main(int argc UNUSED_PARAM, ch
 
 	cmdopt_flags = parse_mount_options(cmdopts, NULL);
 	if (nonroot && (cmdopt_flags & ~MS_SILENT)) // Non-root users cannot specify flags
-		bb_error_msg_and_die(bb_msg_you_must_be_root);
+		bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 
 	// If we have a shared subtree flag, don't worry about fstab or mtab.
 	if (ENABLE_FEATURE_MOUNT_FLAGS
@@ -2337,7 +2337,7 @@ int mount_main(int argc UNUSED_PARAM, ch
 			// No, mount -a won't mount anything,
 			// even user mounts, for mere humans
 			if (nonroot)
-				bb_error_msg_and_die(bb_msg_you_must_be_root);
+				bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 
 			// Does type match? (NULL matches always)
 			if (!fstype_matches(mtcur->mnt_type, fstype))
@@ -2417,7 +2417,7 @@ int mount_main(int argc UNUSED_PARAM, ch
 			// fstab must have "users" or "user"
 			l = parse_mount_options(mtcur->mnt_opts, NULL);
 			if (!(l & MOUNT_USERS))
-				bb_error_msg_and_die(bb_msg_you_must_be_root);
+				bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 		}
 
 		//util-linux-2.12 does not do this check.
diff -urpN busybox-1.31.1/util-linux/nologin.c busybox-1.32.0/util-linux/nologin.c
--- busybox-1.31.1/util-linux/nologin.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/nologin.c	2020-06-26 22:47:44.000000000 +0400
@@ -7,7 +7,7 @@
 //config:
 //config:config NOLOGIN_DEPENDENCIES
 //config:	bool "Enable dependencies for nologin"
-//config:	default y
+//config:	default n  # Y default makes it harder to select single-applet test
 //config:	depends on NOLOGIN
 //config:	select CAT
 //config:	select ECHO
diff -urpN busybox-1.31.1/util-linux/nsenter.c busybox-1.32.0/util-linux/nsenter.c
--- busybox-1.31.1/util-linux/nsenter.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/nsenter.c	2020-06-26 22:47:44.000000000 +0400
@@ -257,7 +257,7 @@ int nsenter_main(int argc UNUSED_PARAM,
 
 	if (opts & OPT_setgid) {
 		if (setgroups(0, NULL) < 0 && setgroups_failed)
-			bb_perror_msg_and_die("setgroups");
+			bb_simple_perror_msg_and_die("setgroups");
 		xsetgid(gid);
 	}
 	if (opts & OPT_setuid)
diff -urpN busybox-1.31.1/util-linux/rdate.c busybox-1.32.0/util-linux/rdate.c
--- busybox-1.31.1/util-linux/rdate.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/rdate.c	2020-06-26 22:47:44.000000000 +0400
@@ -33,7 +33,7 @@ enum { RFC_868_BIAS = 2208988800UL };
 
 static void socket_timeout(int sig UNUSED_PARAM)
 {
-	bb_error_msg_and_die("timeout connecting to time server");
+	bb_simple_error_msg_and_die("timeout connecting to time server");
 }
 
 static time_t askremotedate(const char *host)
@@ -94,10 +94,14 @@ int rdate_main(int argc UNUSED_PARAM, ch
 
 	if (!(flags & 2)) { /* no -p (-s may be present) */
 		if (time(NULL) == remote_time)
-			bb_error_msg("current time matches remote time");
-		else
-			if (stime(&remote_time) < 0)
-				bb_perror_msg_and_die("can't set time of day");
+			bb_simple_error_msg("current time matches remote time");
+		else {
+			struct timespec ts;
+			ts.tv_sec = remote_time;
+			ts.tv_nsec = 0;
+			if (clock_settime(CLOCK_REALTIME, &ts) < 0)
+				bb_simple_perror_msg_and_die("can't set time of day");
+		}
 	}
 
 	if (flags != 1) /* not lone -s */
diff -urpN busybox-1.31.1/util-linux/readprofile.c busybox-1.32.0/util-linux/readprofile.c
--- busybox-1.31.1/util-linux/readprofile.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/readprofile.c	2020-06-26 22:47:44.000000000 +0400
@@ -142,7 +142,7 @@ int readprofile_main(int argc UNUSED_PAR
 				small++;
 		}
 		if (big > small) {
-			bb_error_msg("assuming reversed byte order, "
+			bb_simple_error_msg("assuming reversed byte order, "
 				"use -n to force native byte order");
 			BUILD_BUG_ON(sizeof(*p) > 8);
 			for (p = buf; p < buf+len; p++) {
@@ -204,7 +204,7 @@ int readprofile_main(int argc UNUSED_PAR
 		}
 
 		if (indx >= len)
-			bb_error_msg_and_die("profile address out of range. "
+			bb_simple_error_msg_and_die("profile address out of range. "
 					"Wrong map file?");
 
 		this = 0;
diff -urpN busybox-1.31.1/util-linux/rtcwake.c busybox-1.32.0/util-linux/rtcwake.c
--- busybox-1.31.1/util-linux/rtcwake.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/rtcwake.c	2020-06-26 22:47:44.000000000 +0400
@@ -230,7 +230,7 @@ int rtcwake_main(int argc UNUSED_PARAM,
 		do {
 			ssize_t ret = safe_read(fd, &data, sizeof(data));
 			if (ret < 0) {
-				bb_perror_msg("rtc read");
+				bb_simple_perror_msg("rtc read");
 				break;
 			}
 		} while (!(data & RTC_AF));
diff -urpN busybox-1.31.1/util-linux/setpriv.c busybox-1.32.0/util-linux/setpriv.c
--- busybox-1.31.1/util-linux/setpriv.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/setpriv.c	2020-06-26 22:47:44.000000000 +0400
@@ -164,7 +164,7 @@ static void set_inh_caps(char *capstring
 	}
 
 	if (capset(&caps.header, caps.data) != 0)
-		bb_perror_msg_and_die("capset");
+		bb_simple_perror_msg_and_die("capset");
 }
 
 static void set_ambient_caps(char *string)
@@ -178,10 +178,10 @@ static void set_ambient_caps(char *strin
 		idx = parse_cap(cap);
 		if (cap[0] == '+') {
 			if (prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, idx, 0, 0) < 0)
-				bb_perror_msg("cap_ambient_raise");
+				bb_simple_perror_msg("cap_ambient_raise");
 		} else {
 			if (prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_LOWER, idx, 0, 0) < 0)
-				bb_perror_msg("cap_ambient_lower");
+				bb_simple_perror_msg("cap_ambient_lower");
 		}
 		cap = strtok(NULL, ",");
 	}
@@ -236,7 +236,7 @@ static int dump(void)
 		unsigned idx = CAP_TO_INDEX(i);
 		if (idx >= caps.u32s) {
 			printf("\nindex: %u u32s: %u capability: %u\n", idx, caps.u32s, i);
-			bb_error_msg_and_die("unsupported capability");
+			bb_simple_error_msg_and_die("unsupported capability");
 		}
 		if (caps.data[idx].inheritable & CAP_TO_MASK(i)) {
 			printf_cap(fmt, i);
diff -urpN busybox-1.31.1/util-linux/switch_root.c busybox-1.32.0/util-linux/switch_root.c
--- busybox-1.31.1/util-linux/switch_root.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/switch_root.c	2020-06-26 22:47:44.000000000 +0400
@@ -117,7 +117,7 @@ static void drop_capset(int cap_idx)
 	getcaps(&caps);
 	caps.data[CAP_TO_INDEX(cap_idx)].inheritable &= ~CAP_TO_MASK(cap_idx);
 	if (capset(&caps.header, caps.data) != 0)
-		bb_perror_msg_and_die("capset");
+		bb_simple_perror_msg_and_die("capset");
 }
 
 static void drop_bounding_set(int cap_idx)
@@ -253,7 +253,7 @@ int switch_root_main(int argc UNUSED_PAR
 	if ((unsigned)stfs.f_type != RAMFS_MAGIC
 	 && (unsigned)stfs.f_type != TMPFS_MAGIC
 	) {
-		bb_error_msg_and_die("root filesystem is not ramfs/tmpfs");
+		bb_simple_error_msg_and_die("root filesystem is not ramfs/tmpfs");
 	}
 
 	if (!dry_run) {
@@ -263,7 +263,7 @@ int switch_root_main(int argc UNUSED_PAR
 		// Overmount / with newdir and chroot into it
 		if (mount(".", "/", NULL, MS_MOVE, NULL)) {
 			// For example, fails when newroot is not a mountpoint
-			bb_perror_msg_and_die("error moving root");
+			bb_simple_perror_msg_and_die("error moving root");
 		}
 	}
 	xchroot(".");
diff -urpN busybox-1.31.1/util-linux/taskset.c busybox-1.32.0/util-linux/taskset.c
--- busybox-1.31.1/util-linux/taskset.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/taskset.c	2020-06-26 22:47:44.000000000 +0400
@@ -20,6 +20,14 @@
 //config:	Needed for machines with more than 32-64 CPUs:
 //config:	affinity parameter 0xHHHHHHHHHHHHHHHHHHHH can be arbitrarily long
 //config:	in this case. Otherwise, it is limited to sizeof(long).
+//config:
+//config:config FEATURE_TASKSET_CPULIST
+//config:	bool "CPU list support (-c option)"
+//config:	default y
+//config:	depends on FEATURE_TASKSET_FANCY
+//config:	help
+//config:	Add support for taking/printing affinity as CPU list when '-c'
+//config:	option is used. For example, it prints '0-3,7' instead of mask '8f'.
 
 //applet:IF_TASKSET(APPLET_NOEXEC(taskset, taskset, BB_DIR_USR_BIN, BB_SUID_DROP, taskset))
 
@@ -108,26 +116,120 @@ static unsigned long *get_aff(int pid, u
 	return mask;
 }
 
+#if ENABLE_FEATURE_TASKSET_CPULIST
+/*
+ * Parse the CPU list and set the mask accordingly.
+ *
+ * The list element can be either a CPU index or a range of CPU indices.
+ * Example: "1,3,5-7". Stride can be specified: "0-7:2" is "0,2,4,6".
+ * Note: leading and trailing whitespace is not allowed.
+ *  util-linux 2.31 allows leading and sometimes trailing whitespace:
+ *  ok:     taskset -c ' 1,  2'
+ *  ok:     taskset -c ' 1 , 2'
+ *  ok:     taskset -c ' 1-7: 2 ,8'
+ *  not ok: taskset -c ' 1 '
+ *  not ok: taskset -c ' 1-7: 2 '
+ */
+static void parse_cpulist(ul *mask, unsigned max, char *s)
+{
+	char *aff = s;
+	for (;;) {
+		unsigned bit, end;
+		unsigned stride = 1;
+
+		bit = end = bb_strtou(s, &s, 10);
+		if (*s == '-') {
+			s++;
+			end = bb_strtou(s, &s, 10);
+			if (*s == ':') {
+				s++;
+				stride = bb_strtou(s, &s, 10);
+			}
+		}
+		if ((*s != ',' && *s != '\0')
+		 || bit > end
+		 || end == UINT_MAX /* bb_strtou returns this on malformed / ERANGE numbers */
+		 || (stride - 1) > (UINT_MAX / 4)
+		/* disallow 0, malformed input, and too large stride prone to overflows */
+		) {
+			bb_error_msg_and_die("bad affinity '%s'", aff);
+		}
+		while (bit <= end && bit < max) {
+			mask[bit / BITS_UL] |= (1UL << (bit & MASK_UL));
+			bit += stride;
+		}
+		if (*s == '\0')
+			break;
+		s++;
+	}
+}
+static void print_cpulist(const ul *mask, unsigned mask_size_in_bytes)
+{
+	const ul *mask_end;
+	const char *delim;
+	unsigned pos;
+	ul bit;
+
+	mask_end = mask + mask_size_in_bytes / sizeof(mask[0]);
+	delim = "";
+	pos = 0;
+	bit = 1;
+	for (;;) {
+		if (*mask & bit) {
+			unsigned onebit = pos + 1;
+			printf("%s%u", delim, pos);
+			do {
+				pos++;
+				bit <<= 1;
+				if (bit == 0) {
+					mask++;
+					if (mask >= mask_end)
+						break;
+					bit = 1;
+				}
+			} while (*mask & bit);
+			if (onebit != pos)
+				printf("-%u", pos - 1);
+			delim = ",";
+		}
+		pos++;
+		bit <<= 1;
+		if (bit == 0) {
+			mask++;
+			if (mask >= mask_end)
+				break;
+			bit = 1;
+		}
+	}
+	bb_putchar('\n');
+}
+#endif
+
 int taskset_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int taskset_main(int argc UNUSED_PARAM, char **argv)
 {
 	ul *mask;
 	unsigned mask_size_in_bytes;
 	pid_t pid = 0;
-	unsigned opt_p;
 	const char *current_new;
 	char *aff;
+	unsigned opts;
+	enum {
+		OPT_p = 1 << 0,
+		OPT_c = (1 << 1) * ENABLE_FEATURE_TASKSET_CPULIST,
+	};
 
 	/* NB: we mimic util-linux's taskset: -p does not take
 	 * an argument, i.e., "-pN" is NOT valid, only "-p N"!
 	 * Indeed, util-linux-2.13-pre7 uses:
 	 * getopt_long(argc, argv, "+pchV", ...), not "...p:..." */
 
-	opt_p = getopt32(argv, "^+" "p" "\0" "-1" /* at least 1 arg */);
+	opts = getopt32(argv, "^+" "p"IF_FEATURE_TASKSET_CPULIST("c")
+			"\0" "-1" /* at least 1 arg */);
 	argv += optind;
 
 	aff = *argv++;
-	if (opt_p) {
+	if (opts & OPT_p) {
 		char *pid_str = aff;
 		if (*argv) { /* "-p <aff> <pid> ...rest.is.ignored..." */
 			pid_str = *argv; /* NB: *argv != NULL in this case */
@@ -144,8 +246,14 @@ int taskset_main(int argc UNUSED_PARAM,
 	current_new = "current";
  print_aff:
 	mask = get_aff(pid, &mask_size_in_bytes);
-	if (opt_p) {
-		printf("pid %d's %s affinity mask: "TASKSET_PRINTF_MASK"\n",
+	if (opts & OPT_p) {
+#if ENABLE_FEATURE_TASKSET_CPULIST
+		if (opts & OPT_c) {
+			printf("pid %d's %s affinity list: ", pid, current_new);
+			print_cpulist(mask, mask_size_in_bytes);
+		} else
+#endif
+			printf("pid %d's %s affinity mask: "TASKSET_PRINTF_MASK"\n",
 				pid, current_new, from_mask(mask, mask_size_in_bytes));
 		if (*argv == NULL) {
 			/* Either it was just "-p <pid>",
@@ -158,17 +266,27 @@ int taskset_main(int argc UNUSED_PARAM,
 	}
 	memset(mask, 0, mask_size_in_bytes);
 
-	/* Affinity was specified, translate it into mask */
-	/* it is always in hex, skip "0x" if it exists */
-	if (aff[0] == '0' && (aff[1]|0x20) == 'x')
-		aff += 2;
-
 	if (!ENABLE_FEATURE_TASKSET_FANCY) {
+		/* Affinity was specified, translate it into mask */
+		/* it is always in hex, skip "0x" if it exists */
+		if (aff[0] == '0' && (aff[1]|0x20) == 'x')
+			aff += 2;
 		mask[0] = xstrtoul(aff, 16);
-	} else {
+	}
+#if ENABLE_FEATURE_TASKSET_CPULIST
+	else if (opts & OPT_c) {
+		parse_cpulist(mask, mask_size_in_bytes * 8, aff);
+	}
+#endif
+	else {
 		unsigned i;
 		char *last_char;
 
+		/* Affinity was specified, translate it into mask */
+		/* it is always in hex, skip "0x" if it exists */
+		if (aff[0] == '0' && (aff[1]|0x20) == 'x')
+			aff += 2;
+
 		i = 0; /* bit pos in mask[] */
 
 		/* aff is ASCII hex string, accept very long masks in this form.
diff -urpN busybox-1.31.1/util-linux/uevent.c busybox-1.32.0/util-linux/uevent.c
--- busybox-1.31.1/util-linux/uevent.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/uevent.c	2020-06-26 22:47:44.000000000 +0400
@@ -75,12 +75,12 @@ int uevent_main(int argc UNUSED_PARAM, c
 					MAP_PRIVATE | MAP_ANON,
 					/* ignored: */ -1, 0);
 		if (netbuf == MAP_FAILED)
-			bb_perror_msg_and_die("mmap");
+			bb_simple_perror_msg_and_die("mmap");
 
 		// Here we block, possibly for a very long time
 		len = safe_read(fd, netbuf, BUFFER_SIZE - 1);
 		if (len < 0)
-			bb_perror_msg_and_die("read");
+			bb_simple_perror_msg_and_die("read");
 		end = netbuf + len;
 		*end = '\0';
 
diff -urpN busybox-1.31.1/util-linux/unshare.c busybox-1.32.0/util-linux/unshare.c
--- busybox-1.31.1/util-linux/unshare.c	2019-06-10 14:50:53.000000000 +0400
+++ busybox-1.32.0/util-linux/unshare.c	2020-06-26 22:47:44.000000000 +0400
@@ -239,7 +239,7 @@ int unshare_main(int argc UNUSED_PARAM,
 	if (setgrp_str) {
 		if (strcmp(setgrp_str, "allow") == 0) {
 			if (opts & OPT_map_root) {
-				bb_error_msg_and_die(
+				bb_simple_error_msg_and_die(
 					"--setgroups=allow and --map-root-user "
 					"are mutually exclusive"
 				);
