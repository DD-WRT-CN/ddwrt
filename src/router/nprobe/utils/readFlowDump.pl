#!/usr/bin/perl -w
#
# NetFlow v1/v5/v9 client that reads a dump file generated by nProbe
#
# (C) 2003-05 - Deri Luca <deri@ntop.org>
#
#
# This application has been strongly inspired by:
# ftp://ftp.mcs.anl.gov/pub/systems/software/netflowdb-0.1.0.tar.gz
#

use strict;
use Data::Dumper;
#use init_scripts;
use Getopt::Std;
use DBI;
use File::Glob ':glob';
use vars (qw($opt_d $opt_u $opt_p $opt_c $opt_f $opt_f $opt_v $opt_i $opt_T $opt_V $opt_r));

getopts('d:vf:csit:T:V:u:p:r:');

our $fields = "ipSrc, ipDst, pktSent, bytesSent, startTime, endTime, srcPort, dstPort, tcpFlags, proto, tos";
our $dbh;
our $table; 	# table to store data in if -t (and probably -o) is used
our $move = "mv -f" ;

# Unix
our $backupDir = "/tmp/backup";
our $dumperFile = "/tmp/dumper";

# Win32
# our $backupDir = "c:/temp/flows/backup";
# our $dumperFile = "c:/temp/flows/dumper";

my $num = $#ARGV;
my $debug = $opt_v || 0;
my $rrdDir = $opt_r || "";
my $numFlow = 1;
my $deleteFlows = 1;
my $enable_sql_insert = 1;
my $len;
my %hostStats;
my %knownHosts;
my @protocolLabels;
my $backupDir;
my $procSuffix = ".processing";
my @rrdWhiteListArray;
my @rrdBlackListArray;
my @flowTemplates = ();
my $basetime = 0;
my $sql = "";
my $cur = 0;
my ($read, $hver, $hcount, $hsysuptime, $hunix_secs, $hunix_nsecs, $hflow_sequence);
my $startTime;

#############################################
# Granularity of the RRD file (i.e. how often
# RRD keeps data). Default: 1 entry each 300 sec = 5 min
#############################################
my $step     = 300; # seconds

#############################################
# How often readFlowDump inserts data into RRD.
# Default: 1 minute
#############################################
my $scanStep = 60; # seconds

our $nf_version = $opt_V || 5;
our $db_DSN;
our $db_user;
our $db_pass;

if($rrdDir ne "") {
    use RRDs;
}

if(($nf_version != 1) && ($nf_version != 5) && ($nf_version != 9)) {
    die "Sorry: only netflow v1/v5/v9 are supported\n";
}

# Defaults

$table =  $opt_T  || 'flows';
$db_DSN = $opt_d  || 'dbi:mysql:dbname=netflow';
#$db_DSN = $opt_d  ||  || die "Cannot open output file $file\n";'dbi:Pg:dbname=netflow';
$db_user = $opt_u || 'root';
$db_pass = $opt_p || '';
my $probeId = $opt_i || '0';
my %protocols;
my %prefs;

if ($num != 0) {
    print "\n";
    print "Usage: readFlowDump.pl [options] <dump_file/dump_dir>\n";
    print "\n";
    print "The program will parse all the binary netflow capture files matched by the dump_files\n";
    print "   -r <dir> will create RRD files into the specified directory\n";
    print "   -c will output data in CSV format to stdout\n";
    print "   -s will output data in SQL format\n";
    print "   -f <file> will output the results into the file instead of STDOUT\n";
    print "   -v will provide verbose output\n";
    print "   -V <1|5> specifies the netflow version [Default: $nf_version]\n";
    print "   <dump_file> It can either be a directory or a file:\n";
    print "       - file: The file has the following record format <flow lenght><flow>\n";
    print "               and it is read by the application and processed according to\n";
    print "               the specified options.\n";
    print "       - dir:  All the files stored in the directory with the .nf extesions\n";
    print "               will be processed (see the file item above) and deleted after\n";
    print "               they have been processed. Use this option to start this program\n";
    print "               from the cron in order to periodically process temporary files.\n";
    print "\n";
    print "Following options are only for inputting the data into the SQL database\n";
    print "   -i sets the source probeId  [Default: '$probeId']\n";
    print "   -d sets the database handle [Default: '$db_DSN']\n";
    print "                               (Use 'dbi:Pg:dbname=netflow' for Postgres)\n";
    print "   -T <SQL table name>         [Default: '$table']\n";
    print "   -u <SQL database user>      [Default: '$db_user']\n";
    print "   -p <SQL database password>  [Default: '$db_pass']\n";
    print "\n";
    print "Example\n";
    print "  readFlowDump.pl -V 1 myfile\n";
    print "  Will save into the default database the myfile flow that contains NetFlow v1 flows.\n";
    print "\n";
    exit 0;
}

if ($opt_f) {
    open (OUT,"<$opt_f") || die "Cannot open output file $opt_f specified by the -f flag - aborting\n";
    select OUT;
}

if ($opt_c) {
    print "Source,Destination,Packets,Octets,Start,End,Source Port,destination port,TCP flags,Protocol,TOS,Broadcast\n";
}

if (!$opt_c) {
    if($debug) {
	print "connect($db_DSN,$db_user,$db_pass)\n";
    }

    $dbh = DBI->connect($db_DSN,$db_user,$db_pass) || die "Cannot open database connection ($db_DSN,$db_user,$db_pass,$table)\n" ;

    $sql = "SELECT * FROM proto";
    $cur = $dbh->prepare($sql) || die "error preparing $sql - ", $dbh->errstr;
    $cur->execute() || die "error executing $sql - ", $dbh->errstr;

    while (my ($label, $ports, $proto) = $cur->fetchrow) {
	my @allports;

	@allports = split(/,/, $ports);

	for(my $i=0; $i<=$#allports; $i++) {
	    my $thePort = $allports[$i];

	    if($thePort =~ /-/) {
		# Port range
		my ($from, $to) = split(/-/, $thePort);

		for(my $j=$from; $j <= $to; $j++) {
		    $protocols{$proto}{$j} = $label;
		}
	    } else {
		# Single port
		$protocols{$proto}{$thePort} = $label;
	    }
	    if($debug) { print "Found protocol $label\n"; }
	}
	push(@protocolLabels, $label);
    }
    $cur->finish();

    #######################
    #
    # Read prefs
    #
    #######################

    $sql = "SELECT * FROM prefs";
    $cur = $dbh->prepare($sql) || die "error preparing $sql - ", $dbh->errstr;
    $cur->execute()            || die "error executing $sql - ", $dbh->errstr;

    while(my ($name, $value) = $cur->fetchrow) {
	$prefs{$name} = $value;
    }

    $cur->finish();


    #######################
    #
    # Handle prefs
    #
    #######################

    if(defined($prefs{'rrdWhiteList'})) { @rrdWhiteListArray = split(/,/, $prefs{'rrdWhiteList'}); }
    if(defined($prefs{'rrdBlackList'})) { @rrdBlackListArray = split(/,/, $prefs{'rrdBlackList'}); }
}


#######################
#
# Read NFv9 template dumps
#
#######################

if($nf_version == 9) {
    readTemplates();
}

#######################

my $numRecord = 1;

foreach (@ARGV) {
    my @list = bsd_glob($_);
    my $file;
    foreach $file (@list) {
	my $dir;

	if(-f $file) {
	    processFile($file);
	} else {
	    $dir = $file;
	    if($debug) { print "DIRECTORY --> '$dir'\n"; }

	    $backupDir = "$dir/backup";
	    opendir(DIR, $dir);
	    my @files = grep(/\.nf|\.flow/, sort(readdir(DIR)));
	    closedir(DIR);

	    foreach my $f(@files) {
		if($debug) { print "--> '$dir/$f'\n"; }

		if(($f =~ /nf$/) ||  ($f =~ /flow$/)) {
		    my($fileToProcess) = $dir."/".$f;
		    processFile($fileToProcess);
		}
	    }
	}
    }
}

#########################

sub processFile {
    my %flow_data;	# keeps the keys for all flows in order to find companion flows,
    my %trans_keys;     # assume no duplicate flow key in each file
    my $file = shift(@_);
    my $goAhead = 1;

    undef(%hostStats);
    undef(%knownHosts);

    if($debug) { print STDERR "Processing $file\n"; }

    initHost('global'); # Global stats

    my $fileEnd = $file;
    $fileEnd =~ s/^.*[\\\/]//;	# keep file name only

    $startTime = $fileEnd;
    $startTime =~ s/.flow//;
    if($startTime =~ /-/) { die "Wrong file name ($file)\n"; }

    $startTime -= ($startTime%60); # Round to minute
    $startTime += 60; # We assume that the file is a 1 minute dump

    if(!$debug) {
	rename($file, $file.$procSuffix);
	open(IN, $file.$procSuffix) || die "Unable to open file $file.$procSuffix \n";
    } else {
	open(IN, $file) || die "Unable to open file $file \n";
    }
    binmode IN,  ":raw";

    my @entries;		# in case this gets input to a database
    while($goAhead) {
	my ($buf,$rcvval, $sql);
	my @recvdFlow;

	# Flow header
	if($nf_version == 1) {
	    if(read(IN, $len, 4) == 0) { last; }
	    $read = read(IN, $buf, $len);

	    if($read == 0) { last; }
	    if($read == $len) {
		#
		# No flow lenght before the flow
		#
		@recvdFlow=unpack("a16 a48 a48 a48 a48 a48 a48 a48 a48 a48 a48 a48 ".
				  "a48 a48 a48 a48 a48 a48 a48 a48 a48 a48 a48 ".
				  "a48 a48 a48",$buf);
		($hver, $hcount, $hsysuptime, $hunix_secs, $hunix_nsecs) = unpack("n n N N N",shift(@recvdFlow));

		print STDERR "-> buf len = " .length($buf) . " ver = $hver count = $hcount uptime = $hsysuptime\n" if $debug;
	    }
	} elsif($nf_version == 5) {
	    my $flowLen;

	    $read = read(IN, $len, 4);

	    if($read == 0) { last; }

	    $flowLen = int($len);
	    if($len < 30) { last; }

	    $read = read(IN, $buf, $flowLen);

	    if($read == 0) { last; }
	    if($read == $flowLen) {
		#
		# Flow length before the flow
		#

		print STDERR "Read $read bytes from $len requested\n" if $debug;

		@recvdFlow=unpack("a24 a48 a48 a48 a48 a48 a48 a48 a48 a48 a48 a48".
				  " a48 a48 a48 a48 a48 a48 a48 a48 a48 a48 a48".
				  " a48 a48 a48 a48 a48 a48 a48 a48",$buf);
		($hver, $hcount, $hsysuptime, $hunix_secs, $hunix_nsecs, $hflow_sequence) =
		    unpack("n n N N N N x4",shift(@recvdFlow));

		if($debug) {
		    print STDERR "\nFound $len bytes flow\n";
		    print STDERR "-> buf len = " .length($buf) .
			" ver = $hver count = $hcount uptime = $hsysuptime sequence = $hflow_sequence\n";
		}
	    }
	} else {
	    my $flowLen;

	    $read = read(IN, $len, 4);

	    if($read == 0) { last; }

	    $flowLen = int($len);
	    if($len < 30) { last; }

	    $read = read(IN, $buf, $flowLen);

	    if($read == 0) { last; }
	    if($read == $flowLen) {
		#
		# Flow length before the flow
		#

		if($debug) {
		    print STDERR "Read $read bytes from $len requested\n" if $debug;		    
		    print STDERR "===> '".unpack("H".$read, $buf)."' [len=$read]\n\n";
		}

		my($hver, $hcount, $hsysuptime, $timestamp, $hflow_sequence, $hflow_sourceid) = unpack("n n N N N N", $buf);

		if($debug) {
		    print STDERR "\nFound $len bytes flow\n";
		    print STDERR "-> buf len = " .length($buf) .
			" [ver = $hver][count = $hcount][uptime = $hsysuptime][sequence = $hflow_sequence][sourceId = $hflow_sourceid]\n";
		}

		my $displ = 20;

		for(my $i=0; $i<$hcount; $i++) {
		    my ($flowset, $length, $templateId, $fieldCount) = unpack("n n n n", substr($buf, $displ));

		    if($debug) {
			print STDERR "-> (flowset=$flowset, length=$length, templateId=$templateId, fieldCount=$fieldCount)\n";
		    }


		    if($flowset == 0) {
			# 0 = template flowset
			$displ += 8;

			$flowTemplates[$templateId]{'fieldCount'} = $fieldCount;

			for(my $j=0; $j<$fieldCount; $j++) {
			    ($flowTemplates[$templateId]{'flowset'}[$j]{'fieldType'},
			     $flowTemplates[$templateId]{'flowset'}[$j]{'fieldLen'}) = unpack("n n", substr($buf, $displ));
			    $displ += 4;

			    if($debug) {
				print STDERR "  ($j) -> (fieldType=".$flowTemplates[$templateId]{'flowset'}[$j]{'fieldType'}.
				    ", fieldLen=".$flowTemplates[$templateId]{'flowset'}[$j]{'fieldLen'}.")\n";
			    }
			} # for
		    } elsif($flowset == 1) {
			# Options flowset
			$displ += $length; # skip
		    } else {
			if(defined($flowTemplates[$flowset]{'fieldCount'})) {
			    # $this is a known template
			    print "====> ".$flowTemplates[$flowset]{'fieldCount'}."[$flowset][len=".($length-4)."]\n";
			    if(!handleV9Flow($flowset, substr($buf, $displ+4, $length-4), $length-4)) {
				last;
			    }
			} else {
			    $displ += $length;
			}
		    }
		}
	    }
	}

	if(($hver != 9) && ($read == $len)) {
	    next if (($hver != 5) && ($hver != 1)); # We handle NetFlow 1/5/9 only

	    if($hver == 5) {
		# No checks on v1 as flows are definitively wrong due
		# to bugs in the probe (e.g. Extreme Networks probe)
		if ($hcount != ((length($buf)-24)/48)) { # This packet doesn't seem to be ok
		    print STDERR "Packet does not seem OK\n";
		    next;
		}
	    }

	    $basetime=$hunix_secs+int($hunix_nsecs/1000000000)-int($hsysuptime/1000);

	    my $aFlow=shift(@recvdFlow);

	    while(defined($aFlow) && ($hcount > 0)) # This loop ends
	    {
		my ($fsrc,$fdst,$fnext,$fin,$fout,$fpkts,$focts,$fstrt,$fend,$fsrcp,
		    $fdstp,$ftcp,$fprot,$ftos,$fsas,$fdas,$fsmsk,$fdmsk,
		    $srcip, $dstip, $start, $end, $pad, $startT, $endT);
		my $cur;

		$goAhead = 1;

		if($hver == 1) {
		    ($fsrc, $fdst, $fnext, $fin, $fout, $fpkts, $focts,
		     $fstrt, $fend, $fsrcp, $fdstp, $pad, $fprot, $ftos, $ftcp)
			= unpack("N3 n2 N4 n3 c3", $aFlow);
		} elsif($hver == 5) {
		    if(length($aFlow) < 48) {   # This flow is too small
			print STDERR "Flow size is $aFlow which is too small, skipping\n" if $debug;
			$goAhead = 0;
		    } else {
			($fsrc,$fdst,$fnext,$fin,$fout,$fpkts,$focts,$fstrt,$fend,$fsrcp,
			 $fdstp,$ftcp,$fprot,$ftos,$fsas,$fdas,$fsmsk,$fdmsk)
			    = unpack("N3 n2 N4 n2 x C3 n2 C2 x2", $aFlow);
		    }
		}

		if($goAhead) {
		    $goAhead = processFlow($fsrc,$fdst,$fnext,$fin,$fout,$fpkts,$focts,$fstrt,$fend,$fsrcp,
					   $fdstp,$ftcp,$fprot,$ftos,$fsas,$fdas,$fsmsk,$fdmsk);
		} 

		if($goAhead) { last; }

		$numFlow++, $hcount--;
		$aFlow=shift(@recvdFlow);
	    }
	}
    } # while


    if($debug) { print STDERR "Done with $file\n"; }
    close(IN);

    if((!$debug) && $deleteFlows) {
	my $cmd = "$move -f $file$procSuffix $backupDir";
	#print "\n\n======> ".$cmd."\n\n";
	system($cmd);
	#unlink($file.$procSuffix);
    } else {
	rename($file.$procSuffix, $file);
    }

    if($rrdDir ne "") {
	foreach my $key (keys %hostStats) {
	    saveHost($key, $startTime);
	}
    }
}

saveTemplates();


#########################

sub timestr {
    my $t=shift(@_);
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime($t);
    $mon++; # localtime() returns 0=Jan, 1=Feb, etc
    $year+=1900; # $year is the number of years since 1900,
    # that is, $year is 123 in year 2023.
    return(sprintf("%4.4d-%2.2d-%2.2d %2.2d:%2.2d:%2.2d",$year,$mon,$mday,$hour,$min,$sec));
}

#########################

sub num2ip {
    my $a = shift(@_);
    return(sprintf("%d.%d.%d.%d",
		   ($a&0xff000000)>>24, ($a&0x00ff0000)>>16,
		   ($a&0x0000ff00)>>8, ($a&0x000000ff)));
}

##########

sub initHost {
    my $host = shift(@_);
    my $i;

    if($host eq 'global') {
	$hostStats{'global'}{'totPkt'}   = 0;
	$hostStats{'global'}{'totBytes'} = 0;
	$hostStats{'global'}{'totIcmp'}  = 0;
	$hostStats{'global'}{'totTcp'}   = 0;
	$hostStats{'global'}{'totUdp'}   = 0;
	$hostStats{'global'}{'totOther'} = 0;
	$hostStats{'global'}{'totIcmpFlows'} = 0;
	$hostStats{'global'}{'totTcpFlows'} = 0;
	$hostStats{'global'}{'totUdpFlows'} = 0;
	$hostStats{'global'}{'totOtherFlows'} = 0;

	for($i=0; $i<=$#protocolLabels; $i++) {
	    $hostStats{'global'}{$protocolLabels[$i]}{'sent'} = 0;
	    $hostStats{'global'}{$protocolLabels[$i]}{'rcvd'} = 0;
	}
    } else {
	if(!$knownHosts{$host}) {
	    $hostStats{$host}{'firstSeen'}  = time()+9999999;
	    $hostStats{$host}{'peers'}      = ();
	    $hostStats{$host}{'lastSeen'}   = 0;
	    $hostStats{$host}{'pktSent'}    = 0;
	    $hostStats{$host}{'bytesSent'}  = 0;
	    $hostStats{$host}{'tcpSent'}    = 0;
	    $hostStats{$host}{'udpSent'}    = 0;
	    $hostStats{$host}{'icmpSent'}   = 0;
	    $hostStats{$host}{'otherSent'}  = 0;
	    $hostStats{$host}{'pktRcvd'}    = 0;
	    $hostStats{$host}{'bytesRcvd'}  = 0;
	    $hostStats{$host}{'tcpRcvd'}    = 0;
	    $hostStats{$host}{'udpRcvd'}    = 0;
	    $hostStats{$host}{'icmpRcvd'}   = 0;
	    $hostStats{$host}{'otherRcvd'}  = 0;
	    $hostStats{$host}{'tcpFlowsSent'}   = 0; $hostStats{$host}{'tcpFlowsRcvd'}   = 0;
	    $hostStats{$host}{'udpFlowsSent'}   = 0; $hostStats{$host}{'udpFlowsRcvd'}   = 0;
	    $hostStats{$host}{'icmpFlowsSent'}  = 0; $hostStats{$host}{'icmpFlowsRcvd'}  = 0;
	    $hostStats{$host}{'otherFlowsSent'} = 0; $hostStats{$host}{'otherFlowsRcvd'} = 0;
	    $hostStats{$host}{'tcpServerConn'}           = 0;
	    $hostStats{$host}{'tcpClientConn'}           = 0;
	    $hostStats{$host}{'tcpServerConnRefused'}    = 0;
	    $hostStats{$host}{'tcpClientConnRefused'}    = 0;
	    $hostStats{$host}{'tcpConnReset'}            = 0; # unknown direction: either client or server reset
	    $hostStats{$host}{'tcpClientConnUnsucceeded'} = 0;

	    for($i=0; $i<=$#protocolLabels; $i++) {
		$hostStats{$host}{$protocolLabels[$i]}{'sent'}                    = 0;
		$hostStats{$host}{$protocolLabels[$i]}{'rcvd'}                    = 0;
		$hostStats{$host}{$protocolLabels[$i]}{'numFlows'}                = 0;
		$hostStats{$host}{$protocolLabels[$i]}{'tcpServerConn'}           = 0;
		$hostStats{$host}{$protocolLabels[$i]}{'tcpClientConn'}           = 0;
		$hostStats{$host}{$protocolLabels[$i]}{'tcpServerConnRefused'}    = 0;
		$hostStats{$host}{$protocolLabels[$i]}{'tcpClientConnRefused'}    = 0;
		$hostStats{$host}{$protocolLabels[$i]}{'tcpConnReset'}            = 0;
		$hostStats{$host}{$protocolLabels[$i]}{'tcpClientConnUnsucceeded'} = 0;
	    }
	    $knownHosts{$host} = 1;
	}
   }
}

##########

sub isMonitoredHost {
    my $key     = shift(@_);

    if(($#rrdWhiteListArray != -1) && (!match(\@rrdWhiteListArray, $key))) {
	if($debug) { print $key." discarded (has NOT matched the white list)\n"; }
	return(0);
    }

    if(($#rrdBlackListArray != -1) &&  match(\@rrdBlackListArray, $key))   {
	if($debug) { print $key." discarded (has matched the black list)\n"; }
	return(0);
    }

    return(1);
}

##########

sub saveHost {
    my $key     = shift(@_);
    my $endTime = shift(@_);
    my ($rrd, $value, $ERROR, @arg);

    if($key ne 'global') {

	if(!isMonitoredHost($key)) { return; }

	if($debug) { print $key." accepted!\n"; }

	if($debug) {
	    print "$key: [ls=".$hostStats{$key}{'lastSeen'}."]"
		."[sent=".$hostStats{$key}{'pktSent'}."/".$hostStats{$key}{'bytesSent'}."]"
		."[rcvd=".$hostStats{$key}{'pktRcvd'}."/".$hostStats{$key}{'bytesRcvd'}."]\n";
	}
    }

    if($rrdDir ne "") {
	my $baseDir;
	my $_scanStep = 1;

	if($debug) { print "Saving $key to $rrdDir\n"; }
	if($key eq 'global') {
	    $baseDir = "$rrdDir/global";
	} else {
	    my($a, $b, $c, $d) = split(/\./, $key);

	    $baseDir = "$rrdDir/$a/$b/$c/$d";
	}

	#################################
	# [1] Global stats
	#################################
	system("mkdir -p $baseDir");
	$rrd = $baseDir."/protocols.rrd";

	if(!(-e $rrd)) {
	    @arg = ();
	    push(@arg, $rrd);
	    push(@arg, "--start");
	    push(@arg, "$endTime-1d");
	    push(@arg, "--step");
	    push(@arg, $step);

	    if($key eq 'global') {
		push(@arg, "DS:totPkt:GAUGE:$step:0:U");
		push(@arg, "DS:totBytes:GAUGE:$step:0:U");
		push(@arg, "DS:totIcmp:GAUGE:$step:0:U");
		push(@arg, "DS:totTcp:GAUGE:$step:0:U");
		push(@arg, "DS:totUdp:GAUGE:$step:0:U");
		push(@arg, "DS:totOther:GAUGE:$step:0:U");
		push(@arg, "DS:totIcmpFlows:GAUGE:$step:0:U");
		push(@arg, "DS:totTcpFlows:GAUGE:$step:0:U");
		push(@arg, "DS:totUdpFlows:GAUGE:$step:0:U");
		push(@arg, "DS:totOtherFlows:GAUGE:$step:0:U");
	    } else {
		push(@arg, "DS:peers:GAUGE:$step:0:U");
		push(@arg, "DS:pktSent:GAUGE:$step:0:U");
		push(@arg, "DS:pktRcvd:GAUGE:$step:0:U");
		push(@arg, "DS:bytesSent:GAUGE:$step:0:U");
		push(@arg, "DS:bytesRcvd:GAUGE:$step:0:U");
		push(@arg, "DS:tcpSent:GAUGE:$step:0:U");
		push(@arg, "DS:tcpRcvd:GAUGE:$step:0:U");
		push(@arg, "DS:udpSent:GAUGE:$step:0:U");
		push(@arg, "DS:udpRcvd:GAUGE:$step:0:U");
		push(@arg, "DS:icmpSent:GAUGE:$step:0:U");
		push(@arg, "DS:icmpRcvd:GAUGE:$step:0:U");
		push(@arg, "DS:otherSent:GAUGE:$step:0:U");
		push(@arg, "DS:otherRcvd:GAUGE:$step:0:U");
		push(@arg, "DS:tcpFlowsSent:GAUGE:$step:0:U");
		push(@arg, "DS:tcpFlowsRcvd:GAUGE:$step:0:U");
		push(@arg, "DS:udpFlowsSent:GAUGE:$step:0:U");
		push(@arg, "DS:udpFlowsRcvd:GAUGE:$step:0:U");
		push(@arg, "DS:icmpFlowsSent:GAUGE:$step:0:U");
		push(@arg, "DS:icmpFlowsRcvd:GAUGE:$step:0:U");
		push(@arg, "DS:otherFlowsSent:GAUGE:$step:0:U");
		push(@arg, "DS:otherFlowsRcvd:GAUGE:$step:0:U");
		push(@arg, "DS:srvConn:GAUGE:$step:0:U");
		push(@arg, "DS:clntConn:GAUGE:$step:0:U");
		push(@arg, "DS:srvConnRef:GAUGE:$step:0:U");
		push(@arg, "DS:clntConnRef:GAUGE:$step:0:U");
		push(@arg, "DS:connReset:GAUGE:$step:0:U");
		push(@arg, "DS:clntConUns:GAUGE:$step:0:U");
		push(@arg, "DS:dloadAvgBw:GAUGE:$step:0:U");
		push(@arg, "DS:uploadAvgBw:GAUGE:$step:0:U");
		push(@arg, "DS:dloadKbWait:GAUGE:$step:0:U");
		push(@arg, "DS:uploadKbWait:GAUGE:$step:0:U");
	    }

	    push(@arg, "RRA:AVERAGE:0.5:1:600");
	    push(@arg, "RRA:AVERAGE:0.5:6:700");
	    push(@arg, "RRA:AVERAGE:0.5:24:775");
	    push(@arg, "RRA:MAX:0.5:1:600");
	    push(@arg, "RRA:MAX:0.5:6:700");
	    push(@arg, "RRA:MAX:0.5:24:775");

	    RRDs::create(@arg);

	    if($ERROR = RRDs::error) {
		print "$0: unable to create `$rrd': $ERROR\n";
		return;
	    }
	}

	if($key eq 'global') {
	    $value = $endTime.":"
		.($hostStats{$key}{'totPkt'}/$_scanStep).":"
		.($hostStats{$key}{'totBytes'}/$_scanStep).":"
		.($hostStats{$key}{'totIcmp'}/$_scanStep).":"
		.($hostStats{$key}{'totTcp'}/$_scanStep).":"
		.($hostStats{$key}{'totUdp'}/$_scanStep).":"
		.($hostStats{$key}{'totOther'}/$_scanStep).":"
		.($hostStats{$key}{'totIcmpFlows'}/$_scanStep).":"
		.($hostStats{$key}{'totTcpFlows'}/$_scanStep).":"
		.($hostStats{$key}{'totUdpFlows'}/$_scanStep).":"
		.($hostStats{$key}{'totOtherFlows'}/$_scanStep);

	    #print "--> $endTime = ".($hostStats{$key}{'totBytes'}/$_scanStep)."  [tot/60]\n";
	    #print "--> $endTime = ".($hostStats{$key}{'totBytes'})."  [tot]\n";
	} else {
	    my $peers = $hostStats{$key}{'peers'};
	    my @numPeers = keys %$peers;
	    my $totPeers = $#numPeers+1;

	    $value = $endTime.":"
		.($totPeers/$_scanStep).":"
		.($hostStats{$key}{'pktSent'}/$_scanStep).":"
		.($hostStats{$key}{'pktRcvd'}/$_scanStep).":"
		.($hostStats{$key}{'bytesSent'}/$_scanStep).":"
		.($hostStats{$key}{'bytesRcvd'}/$_scanStep).":"
		.($hostStats{$key}{'tcpSent'}/$_scanStep).":"
		.($hostStats{$key}{'tcpRcvd'}/$_scanStep).":"
		.($hostStats{$key}{'udpSent'}/$_scanStep).":"
		.($hostStats{$key}{'udpRcvd'}/$_scanStep).":"
		.($hostStats{$key}{'icmpSent'}/$_scanStep).":"
		.($hostStats{$key}{'icmpRcvd'}/$_scanStep).":"
		.($hostStats{$key}{'otherSent'}/$_scanStep).":"
		.($hostStats{$key}{'otherRcvd'}/$_scanStep).":"
		.($hostStats{$key}{'tcpFlowsSent'}/$_scanStep).":"
		.($hostStats{$key}{'tcpFlowsRcvd'}/$_scanStep).":"
		.($hostStats{$key}{'udpFlowsSent'}/$_scanStep).":"
		.($hostStats{$key}{'udpFlowsRcvd'}/$_scanStep).":"
		.($hostStats{$key}{'icmpFlowsSent'}/$_scanStep).":"
		.($hostStats{$key}{'icmpFlowsRcvd'}/$_scanStep).":"
		.($hostStats{$key}{'otherFlowsSent'}/$_scanStep).":"
		.($hostStats{$key}{'otherFlowsRcvd'}/$_scanStep).":"
		.($hostStats{$key}{'tcpServerConn'}/$_scanStep).":"
		.($hostStats{$key}{'tcpClientConn'}/$_scanStep).":"
		.($hostStats{$key}{'tcpServerConnRefused'}/$_scanStep).":"
		.($hostStats{$key}{'tcpClientConnRefused'}/$_scanStep).":"
		.($hostStats{$key}{'tcpConnReset'}/$_scanStep).":"
		.($hostStats{$key}{'tcpClientConnUnsucceeded'}/$_scanStep).":";

	    # dloadAvgBw
	    $value .= (($hostStats{$key}{'bytesRcvd'}/$scanStep)/$_scanStep).":";

	    # uploadAvgBw
	    $value .= (($hostStats{$key}{'bytesSent'}/$scanStep)/$_scanStep).":";

	    if($debug) {
		print "$key: dload=".((8*$hostStats{$key}{'bytesRcvd'}/$scanStep)/$_scanStep);
		print "/upload=".((8*$hostStats{$key}{'bytesSent'}/$scanStep)/$_scanStep)."\n";
	    }

	    # dloadKbWait
	    if($hostStats{$key}{'bytesRcvd'} == 0) {
		$value .= "0:";
	    } else {
		$value .= (((1024*$scanStep)/$hostStats{$key}{'bytesRcvd'})/$_scanStep).":";
	    }

	    # uploadKbWait
	    if($hostStats{$key}{'bytesSent'} == 0) {
		$value .= "0";
	    } else {
		$value .= (((1024*$scanStep)/$hostStats{$key}{'bytesSent'})/$_scanStep);
	    }
	}

	#print "--> $key = ".$value."\n";

        if($debug) { print $value."\n"; }
	RRDs::update $rrd, $value;
        if ($ERROR = RRDs::error) {
            print "$0: unable to update `$rrd': $ERROR [$value]\n";
        }

	#################################
	# [2] Protocol stats
	#################################
	for(my $i=0; $i<=$#protocolLabels; $i++) {
	    my $sent = $hostStats{$key}{$protocolLabels[$i]}{'sent'} || 0;
	    my $rcvd = $hostStats{$key}{$protocolLabels[$i]}{'rcvd'} || 0;

	    if(($sent > 0) || ($rcvd > 0)) {
		$rrd = $baseDir."/".$protocolLabels[$i].".rrd";

		if(!(-e $rrd)) {
		    @arg = ();
		    push(@arg, $rrd);
		    push(@arg, "--start");
		    push(@arg, "$endTime-1d");
		    push(@arg, "--step");
		    push(@arg, $step);
		    push(@arg, "DS:sent:GAUGE:$step:0:U");
		    push(@arg, "DS:rcvd:GAUGE:$step:0:U");
		    if($key ne "global") {
			push(@arg, "DS:srvConn:GAUGE:$step:0:U");
			push(@arg, "DS:clntConn:GAUGE:$step:0:U");
			push(@arg, "DS:srvConnRef:GAUGE:$step:0:U");
			push(@arg, "DS:clntConnRef:GAUGE:$step:0:U");
			push(@arg, "DS:connReset:GAUGE:$step:0:U");
			push(@arg, "DS:clntConUns:GAUGE:$step:0:U");
			push(@arg, "DS:dloadAvgBw:GAUGE:$step:0:U");
			push(@arg, "DS:uploadAvgBw:GAUGE:$step:0:U");
			push(@arg, "DS:dloadKbWait:GAUGE:$step:0:U");
			push(@arg, "DS:uploadKbWait:GAUGE:$step:0:U");
		    }
		    push(@arg, "RRA:AVERAGE:0.5:1:600");
		    push(@arg, "RRA:AVERAGE:0.5:6:700");
		    push(@arg, "RRA:AVERAGE:0.5:24:775");
		    push(@arg, "RRA:MAX:0.5:1:600");
		    push(@arg, "RRA:MAX:0.5:6:700");
		    push(@arg, "RRA:MAX:0.5:24:775");

		    RRDs::create(@arg);

		    if($ERROR = RRDs::error) {
			print "$0: unable to create `$rrd': $ERROR\n";
			return;
		    }
		}

		$value = $endTime.":".($sent/$_scanStep).":".($rcvd/$_scanStep);

		if($key ne "global") {
		    $value .= ":"
			.($hostStats{$key}{$protocolLabels[$i]}{'tcpServerConn'}/$_scanStep).":"
			.($hostStats{$key}{$protocolLabels[$i]}{'tcpClientConn'}/$_scanStep).":"
			.($hostStats{$key}{$protocolLabels[$i]}{'tcpServerConnRefused'}/$_scanStep).":"
			.($hostStats{$key}{$protocolLabels[$i]}{'tcpClientConnRefused'}/$_scanStep).":"
			.($hostStats{$key}{$protocolLabels[$i]}{'tcpConnReset'}/$_scanStep).":"
			.($hostStats{$key}{$protocolLabels[$i]}{'tcpClientConnUnsucceeded'}/$_scanStep).":";

		    # dloadAvgBw
		    $value .= (($hostStats{$key}{$protocolLabels[$i]}{'rcvd'}/$scanStep)/$_scanStep).":";

		    # uploadAvgBw
		    $value .= (($hostStats{$key}{$protocolLabels[$i]}{'sent'}/$scanStep)/$_scanStep).":";

		    # dloadKbWait
		    if($hostStats{$key}{$protocolLabels[$i]}{'rcvd'} == 0) {
			$value .= "0:";
		    } else {
			$value .= (((1024*$scanStep)/$hostStats{$key}{$protocolLabels[$i]}{'rcvd'})/$_scanStep).":";
		    }

		    # uploadKbWait
		    if($hostStats{$key}{$protocolLabels[$i]}{'sent'} == 0) {
			$value .= "0";
		    } else {
			$value .= (((1024*$scanStep)/$hostStats{$key}{$protocolLabels[$i]}{'sent'})/$_scanStep);
		    }
		}

		if($debug) { print $value."\n"; }
		RRDs::update $rrd, $value;
		if ($ERROR = RRDs::error) {
		    print "$0: unable to update `$rrd': $ERROR\n";
		}
	    }
	}
    }
}

#####################################

sub match {
    my $_networks = shift(@_);
    my $address  = shift(@_);
    my @net = @$_networks;


    for(my $i=0; $i <= $#net; $i++) {
	if(contains($address, $net[$i])) {
	    return(1);
	}
    }

    return(0);
}

#####################################

sub contains {
    my $address  = shift(@_);
    my $network  = shift(@_);
    my ($_addr, $_net, $_mask);

    if($address =~ /(\d+)\.(\d+)\.(\d+)\.(\d+)/) {
	$_addr = ($1 << 24) + ($2 << 16) + ($3 << 8) + $4;
    } else {
	return(0);
    }

    my ($a, $b) = split(/\//, $network);

    if($a =~ /(\d+)\.(\d+)\.(\d+)\.(\d+)/) {
	$_net =  ($1 << 24) + ($2 << 16) + ($3 << 8) + $4;
    } else {
	return(0);
    }

    if($b =~ /(\d+)\.(\d+)\.(\d+)\.(\d+)/) {
	$_mask = ($1 << 24) + ($2 << 16) + ($3 << 8) + $4;
    } elsif($b =~ /(\d+)/) {
	$_mask = ~((0xFFFFFFFF >> $1) & 0xFFFFFFFF);
    } else {
	return(0);
    }

    return(($_addr & $_mask) == $_net);
}

###

sub hasBits {
    my $value  = shift(@_);
    my $mask  = shift(@_);

    if(($value & $mask) == $mask) {
	return(1);
    } else {
	return(0);
    }
}

##########

sub processFlow {
    my($fsrc,$fdst,$fnext,$fin,$fout,$fpkts,$focts,$fstrt,$fend,$fsrcp,
       $fdstp,$ftcp,$fprot,$ftos,$fsas,$fdas,$fsmsk,$fdmsk) = @_;
    my $goAhead = 1;

    if($debug) {
	print STDERR "(IP_SRC_ADDR=$fsrc,IP_DST_ADDR=$fdst,IP_NEXT_HOP=$fnext,INPUT_SNMP=$fin,OUTPUT_SNMP=$fout,PKTS=$fpkts,BYTES=$focts,FIRST_SWITCHED=$fstrt,LAST_SWITCHED=$fend,L4_SRC_PORT=$fsrcp,L4_DST_PORT=$fdstp,TCP_FLAGS=$ftcp,PROT=$fprot,TOS=$ftos,SRC_AS=$fsas,DST_AS=$fdas,SRC_MASK=$fsmsk,DST_MASK=$fdmsk)\n";

    }
      
    if($goAhead) {
	if($fpkts < 1) {   # This flow is too small
	    print STDERR "Flow packets $fpkts which is too small, skipping\n" if $debug;
	    $goAhead = 0;
	}

	if($goAhead) {
	    if(($fpkts*1514) < $focts) {
		# Strange number of packets/octets
		print STDERR "Bad flow packets/octets [pkts=$fpkts][octs=$focts], skipping\n" if $debug;
		$goAhead = 0;
	    }

	    if($goAhead) {
		my($processed, $duration, $monitored);
		my $srcip = num2ip($fsrc);
		my $dstip = num2ip($fdst);
		my $startT = int($basetime+($fstrt/1000));
		my $start = timestr($startT);
		my $endT = int($basetime+($fend/1000));
		my $end = timestr($endT);
		
		if($focts == 0) { $focts = $fpkts * 512; }

		if($fprot != 6) {
		    # !TCP
		    $processed = 1; # This record needs to be aggregated later
		    $duration = 1+$endT-$startT;
		} else {
		    if(hasBits($ftcp, (0x02 # SYN
				       ))) {
			# We need to aggregate the center of long standing
			# connections. If a connection contains only the
			# above flags then it's just the beginning.

			$processed = 1;
		    } else {
			$processed = 0;
		    }
		    $duration = 0;
		}

		if(isMonitoredHost($srcip) || isMonitoredHost($dstip)) { $monitored = 1; } else { $monitored = 0; }

		if($monitored) {
		    $sql = "INSERT INTO $table (periodStart, probeId, ipSrc, ipDst, pktSent, bytesSent, startTime, endTime, srcPort, ".
			"dstPort, proto, tcpFlags, tos, processed, duration) VALUES ('".$startTime."', '".$probeId."', '".$srcip."', '".$dstip."', ".
			"'$fpkts', '$focts', '".int($basetime+($fstrt/1000))."', '".int($basetime+($fend/1000)).
			"', '$fsrcp', '$fdstp', '$fprot', '$ftcp', '$ftos', '$processed', '$duration')";
		    print "[$numRecord] $sql\n" if $debug;
		}

		if($monitored && ($rrdDir ne "")) {
		    my $protoName;
		    my $tcpConnSucceeded = 0;
		    my $tcpConnRefused   = 0;
		    my $tcpConnReset     = 0;
		    my $tcpConnUnsucceeded = 0;
		    my $timeDiff = $fend-$fstrt+1;

		    if($fprot == 6) {
			# TCP
			if(hasBits($ftcp, (0x01 | 0x02 | 0x10))) { $tcpConnSucceeded  = 1;  }
			elsif(hasBits($ftcp, (0x02 | 0x10)))     { $tcpConnSucceeded  = 1;  }
			elsif(hasBits($ftcp, 0x02))              { $tcpConnUnsucceeded = 1; }
			elsif(hasBits($ftcp, (0x04 | 0x10)))     { $tcpConnRefused = 1;     }
			elsif(hasBits($ftcp, 0x04))              { $tcpConnReset = 1;       }

			if($debug) {
			    print "--> $ftcp ";
			    if(hasBits($ftcp, 0x01)) { print "FIN "; }
			    if(hasBits($ftcp, 0x02)) { print "SYN "; }
			    if(hasBits($ftcp, 0x04)) { print "RST "; }
			    if(hasBits($ftcp, 0x08)) { print "PUSH ";}
			    if(hasBits($ftcp, 0x10)) { print "ACK "; }
			    if(hasBits($ftcp, 0x20)) { print "URG "; }

			    print "\n";
			    print "--> [tcpConnSucceeded=$tcpConnSucceeded][tcpConnRefused=$tcpConnRefused]"
				."[tcpConnReset=$tcpConnReset][tcpConnUnsucceeded=$tcpConnUnsucceeded]\n";
			}
		    }

		    $hostStats{'global'}{'totPkt'}   += $fpkts;
		    $hostStats{'global'}{'totBytes'} += $focts;

		    #print "--> $focts [tot=".$hostStats{'global'}{'totBytes'}."]\n";

		    if($monitored) {
			initHost($srcip);
			$hostStats{$srcip}{'peers'}{$dstip} = 1;
			$hostStats{$srcip}{'pktSent'}   += $fpkts;
			$hostStats{$srcip}{'bytesSent'} += $focts;
			if($hostStats{$srcip}{'firstSeen'} > $startT) { $hostStats{$srcip}{'firstSeen'} = $startT; }
			if($hostStats{$srcip}{'lastSeen'} < $endT)    { $hostStats{$srcip}{'lastSeen'}  = $endT;   }

			if($tcpConnSucceeded) {
			    if($fsrcp < $fdstp) {
				$hostStats{$srcip}{'tcpServerConn'}++;
			    } else {
				$hostStats{$srcip}{'tcpClientConn'}++;
			    }
			} elsif($tcpConnRefused)  {
			    if($fsrcp < $fdstp) {
				$hostStats{$srcip}{'tcpServerConnRefused'}++;
			    } else {
				$hostStats{$srcip}{'tcpClientConnRefused'}++;
			    }
			} elsif($tcpConnReset)    {
			    $hostStats{$srcip}{'tcpConnReset'}++;
			} elsif($tcpConnUnsucceeded) {
			    $hostStats{$srcip}{'tcpClientConnUnsucceeded'}++;
			}
		    }

		    $protoName = $protocols{$fprot}{$fsrcp};
		    if(!defined($protoName)) { $protoName = ""; }
		    if($protoName ne "") {
			$hostStats{'global'}{$protoName}{'sent'}    += $focts;

			if($monitored) {
			    $hostStats{$srcip}{$protoName}{'sent'}      += $focts;
			    $hostStats{$dstip}{$protoName}{'rcvd'}      += $focts;

			    if($tcpConnSucceeded) {
				if($fsrcp < $fdstp) {
				    $hostStats{$srcip}{$protoName}{'tcpServerConn'}++;
				} else {
				    $hostStats{$srcip}{$protoName}{'tcpClientConn'}++;
				}
			    } elsif($tcpConnRefused)  {
				if($fsrcp < $fdstp) {
				    $hostStats{$srcip}{$protoName}{'tcpServerConnRefused'}++;
				} else {
				    $hostStats{$srcip}{$protoName}{'tcpClientConnRefused'}++;
				}
			    } elsif($tcpConnReset)    {
				$hostStats{$srcip}{$protoName}{'tcpConnReset'}++;
			    } elsif($tcpConnUnsucceeded) {
				$hostStats{$srcip}{$protoName}{'tcpClientConnUnsucceeded'}++;
			    }
			}
		    }

		    #######################################

		    if($monitored) {
			initHost($dstip);
			$hostStats{$dstip}{'peers'}{$srcip} = 1;
			$hostStats{$dstip}{'pktRcvd'}   += $fpkts;
			$hostStats{$dstip}{'bytesRcvd'} += $focts;
			if($hostStats{$dstip}{'firstSeen'} > $startT) { $hostStats{$dstip}{'firstSeen'} = $startT; }
			if($hostStats{$dstip}{'lastSeen'} < $endT)    { $hostStats{$dstip}{'lastSeen'}  = $endT;   }
		    }

		    # Don't set flags (e.g. tcpConnReset) otherwise we'll count
		    # data twice

		    $protoName = $protocols{$fprot}{$fdstp};
		    if(!defined($protoName)) { $protoName = ""; }
		    if($protoName ne "") {
			$hostStats{'global'}{$protoName}{'rcvd'} += $focts;
			if($monitored) {
			    $hostStats{$srcip}{$protoName}{'rcvd'}   += $focts;
			    $hostStats{$dstip}{$protoName}{'sent'}   += $focts;
			}
		    }

		    #######################################

		    if($fprot == 1) {
			if($monitored) {
			    $hostStats{$srcip}{'icmpSent'}  += $focts;
			    $hostStats{$srcip}{'icmpFlowsSent'}++;
			    $hostStats{$dstip}{'icmpRcvd'}  += $focts;
			    $hostStats{$dstip}{'icmpFlowsRcvd'}++;
			}
			$hostStats{'global'}{'totIcmp'} += $focts;
			$hostStats{'global'}{'totIcmpFlows'}++;
		    } elsif($fprot == 6) {
			if($monitored) {
			    $hostStats{$srcip}{'tcpSent'}  += $focts;
			    $hostStats{$srcip}{'tcpFlowsSent'}++;
			    $hostStats{$dstip}{'tcpRcvd'}  += $focts;
			    $hostStats{$dstip}{'tcpFlowsRcvd'}++;
			}
			$hostStats{'global'}{'totTcp'} += $focts;
			$hostStats{'global'}{'totTcpFlows'}++;
		    } elsif($fprot == 17) {
			if($monitored) {
			    $hostStats{$srcip}{'udpSent'}  += $focts;
			    $hostStats{$srcip}{'udpFlowsSent'}++;
			    $hostStats{$dstip}{'udpRcvd'}  += $focts;
			    $hostStats{$dstip}{'udpFlowsRcvd'}++;
			}
			$hostStats{'global'}{'totUdp'} += $focts;
			$hostStats{'global'}{'totUdpFlows'}++;
		    } else {
			if($monitored) {
			    $hostStats{$srcip}{'otherSent'}  += $focts;
			    $hostStats{$srcip}{'otherFlowsSent'}++;
			    $hostStats{$dstip}{'otherRcvd'}  += $focts;
			    $hostStats{$dstip}{'otherFlowsRcvd'}++;
			}
			$hostStats{'global'}{'totOther'} += $focts;
			$hostStats{'global'}{'totOtherFlows'}++;
		    }
		}

		$numRecord++;

		if ($opt_c) {
		    if($hver == 5) {
			print "$srcip,$dstip,$fpkts,$focts,$start,$end,$fsrcp,$fdstp,$ftcp,$fprot,$ftos\n";
		    }
		}

		if($monitored && $enable_sql_insert) {
		    if($debug) { print "SQL: [$numFlow] $sql\n"; }
		    if (!$opt_c) {
			$cur = $dbh->prepare($sql) || die "error preparing $sql - ", $dbh->errstr;
			$cur->execute() || die "error executing $sql - ", $dbh->errstr;
		    }

		    if (!$opt_c) {
			if($debug && ($hver == 5)) {
			    print $fprot.") [".timestr($basetime+($fstrt/1000))." - ".timestr($basetime+($fend/1000)). "] ";
			    print num2ip($fsrc).":".$fsrcp." -> ".num2ip($fdst).":".$fdstp." [pkt=$fpkts/bytes=$focts]\n";
			}
		    }
		}
	    }
	}
    }

    return($goAhead);
}

###

sub handleV9Flow {
    my($flowset, $data, $len) = @_;
    my $offset = 0;
    my $LAST_SWITCHED = 0;
    my $FIRST_SWITCHED = 0;
    my $BYTES = 0;
    my $PKTS = 0;
    my $INPUT_SNMP = 0;
    my $OUTPUT_SNMP = 0;
    my $IP_SRC_ADDR  = 0;
    my $IP_DST_ADDR = 0;
    my $PROT = 0;
    my $TOS = 0;
    my $L4_SRC_PORT = 0;
    my $L4_DST_PORT = 0;
    my $TCP_FLAGS = 0;
    my $SRC_AS = 0;
    my $DST_AS = 0;
    my $DST_MASK = 0;
    my $SRC_MASK = 0;
    my $IP_NEXT_HOP = 0;

    if($debug) {
	print STDERR "=> '".unpack("H".$len, $data)."' [len=$len]\n\n";
    }

    for(my $j=0; $j<$flowTemplates[$flowset]{'fieldCount'}; $j++) {
	my($fType, $fLen) = ($flowTemplates[$flowset]{'flowset'}[$j]{'fieldType'},
			     $flowTemplates[$flowset]{'flowset'}[$j]{'fieldLen'});

	if($debug) {
	    my $elems = substr($data, $offset, $fLen);
	    print STDERR "[fType=$fType][fLen=$fLen][offset=$offset][".unpack("H".$fLen, $elems);	    
	    print STDERR "]\n\n";
	}

	if($fType == 21) {
	    if($fLen != 4) { return(0); }
	    $LAST_SWITCHED = unpack("N", substr($data, $offset, 4)); 
	} elsif($fType == 22) {
	    if($fLen != 4) { return(0); }
	    $FIRST_SWITCHED = unpack("N", substr($data, $offset, 4));
	} elsif($fType == 1) {
	    if($fLen != 4) { return(0); }
	    $BYTES = unpack("N", substr($data, $offset, 4));
	} elsif($fType == 2) {
	    if($fLen != 4) { return(0); }
	    $PKTS = unpack("N", substr($data, $offset, 4));
	} elsif($fType == 10) {
	    if($fLen != 2) { return(0); }
	    $INPUT_SNMP = unpack("n", substr($data, $offset, 2));
	} elsif($fType == 14) {
	    if($fLen != 2) { return(0); }
	    $OUTPUT_SNMP = unpack("n", substr($data, $offset, 2));
	} elsif($fType == 8) {
	    if($fLen != 4) { return(0); }
	    $IP_SRC_ADDR = unpack("N", substr($data, $offset, 4));
	} elsif($fType == 12) {
	    if($fLen != 4) { return(0); }
	    $IP_DST_ADDR = unpack("N", substr($data, $offset, 4));
	} elsif($fType == 4) {
	    if($fLen != 1) { return(0); }
	    $PROT = unpack("c", substr($data, $offset, 1));
	} elsif($fType == 6) {
	    if($fLen != 1) { return(0); }
	    $TCP_FLAGS = unpack("c", substr($data, $offset, 1));
	} elsif($fType == 5) {
	    if($fLen != 1) { return(0); }
	    $TOS = unpack("c", substr($data, $offset, 1));
	} elsif($fType == 7) {
	    if($fLen != 2) { return(0); }
	    $L4_SRC_PORT = unpack("n", substr($data, $offset, 2));
	} elsif($fType == 11) {
	    if($fLen != 2) { return(0); }
	    $L4_DST_PORT = unpack("n", substr($data, $offset, 2));
	} elsif($fType == 16) {
	    if($fLen != 2) { return(0); }
	    $SRC_AS = unpack("n", substr($data, $offset, 2));
	} elsif($fType == 17) {
	    if($fLen != 2) { return(0); }
	    $DST_AS = unpack("n", substr($data, $offset, 2)); 
	} elsif($fType == 13) {
	    if($fLen != 1) { return(0); }
	    $DST_MASK = unpack("c", substr($data, $offset, 1));
	} elsif($fType == 9) {
	    if($fLen != 1) { return(0); }
	    $SRC_MASK = unpack("c", substr($data, $offset, 1));
	} elsif($fType == 15) {
	    if($fLen != 4) { return(0); }
	    $IP_NEXT_HOP = unpack("N", substr($data, $offset, 4));
	}
	
	# Other fields are ignored

	if($debug) {
	    #print STDERR "$fType - $fLen\n";
	}

	$offset += $fLen;
    } # for

    if($debug) {
	print STDERR "\n\n[IP_SRC_ADDR=$IP_SRC_ADDR,IP_DST_ADDR=$IP_DST_ADDR,IP_NEXT_HOP=$IP_NEXT_HOP,".
	    "INPUT_SNMP=$INPUT_SNMP,OUTPUT_SNMP=$OUTPUT_SNMP,PKTS=$PKTS,BYTES=$BYTES,FIRST_SWITCHED=$FIRST_SWITCHED,".
	    "LAST_SWITCHED=$LAST_SWITCHED,L4_SRC_PORT=$L4_SRC_PORT,L4_DST_POR=$L4_DST_PORT,TCP_FLAGS=$TCP_FLAGS,".
	    "PROT=$PROT,TOS=$TOS,SRC_AS=$SRC_AS,DST_AS=$DST_AS,SRC_MASK=$SRC_MASK,DST_MASK=$DST_MASK]\n\n";
    }

    $hver = 9;
    return(processFlow($IP_SRC_ADDR,$IP_DST_ADDR,$IP_NEXT_HOP,$INPUT_SNMP,$OUTPUT_SNMP,
		       $PKTS,$BYTES,$FIRST_SWITCHED,$LAST_SWITCHED,$L4_SRC_PORT,
		       $L4_DST_PORT,$TCP_FLAGS,$PROT,$TOS,$SRC_AS,$DST_AS,$SRC_MASK,$DST_MASK));
}

############

sub readTemplates {
    if($nf_version == 9) {
	if(open(IN, $dumperFile)) {
	    my $buf;
	    my $read = read(IN, $buf, 99999);
	    eval($buf);
	    print $flowTemplates[257];
	    close(IN);
	} else {
	    #die "Cannot open input file $template_file\n";
	}
    }
}

##

sub saveTemplates {
    if($nf_version == 9) {
	if(open(OUT,"> $dumperFile")) {
	    print OUT Data::Dumper->Dump([\@flowTemplates], [qw(*flowTemplates)]);
	    #print OUT Dumper(\@flowTemplates);
	    close(OUT);
	} else {
	    die "Cannot open template output file\n";
	}
    }
}

############
