.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.46.1.
.TH DDRESCUE "1" "October 2014" "ddrescue 1.19" "User Commands"
.SH NAME
ddrescue \- data recovery tool
.SH SYNOPSIS
.B ddrescue
[\fI\,options\/\fR] \fI\,infile outfile \/\fR[\fI\,logfile\/\fR]
.SH DESCRIPTION
GNU ddrescue \- Data recovery tool.
Copies data from one file or block device to another,
trying to rescue the good parts first in case of read errors.
.PP
You should use a logfile unless you know what you are doing.
If you reboot, check the device names before restarting ddrescue.
Do not use options '\-F' or '\-G' without reading the manual first.
.SH OPTIONS
.TP
\fB\-h\fR, \fB\-\-help\fR
display this help and exit
.TP
\fB\-V\fR, \fB\-\-version\fR
output version information and exit
.TP
\fB\-a\fR, \fB\-\-min\-read\-rate=\fR<bytes>
minimum read rate of good areas in bytes/s
.TP
\fB\-A\fR, \fB\-\-try\-again\fR
mark non\-trimmed, non\-scraped as non\-tried
.TP
\fB\-b\fR, \fB\-\-sector\-size=\fR<bytes>
sector size of input device [default 512]
.TP
\fB\-B\fR, \fB\-\-binary\-prefixes\fR
show binary multipliers in numbers [SI]
.TP
\fB\-c\fR, \fB\-\-cluster\-size=\fR<sectors>
sectors to copy at a time [128]
.TP
\fB\-C\fR, \fB\-\-complete\-only\fR
do not read new data beyond logfile limits
.TP
\fB\-d\fR, \fB\-\-direct\fR
use direct disc access for input file
.TP
\fB\-D\fR, \fB\-\-synchronous\fR
use synchronous writes for output file
.TP
\fB\-e\fR, \fB\-\-max\-errors\fR=\fI\,[\/\fR+]<n>
maximum number of [new] error areas allowed
.TP
\fB\-E\fR, \fB\-\-max\-error\-rate=\fR<bytes>
maximum allowed rate of read errors per second
.TP
\fB\-f\fR, \fB\-\-force\fR
overwrite output device or partition
.TP
\fB\-F\fR, \fB\-\-fill\-mode=\fR<types>
fill given type blocks with infile data (?*/\-+)
.TP
\fB\-G\fR, \fB\-\-generate\-mode\fR
generate approximate logfile from partial copy
.TP
\fB\-H\fR, \fB\-\-test\-mode=\fR<file>
set map of good/bad blocks from given logile
.TP
\fB\-i\fR, \fB\-\-input\-position=\fR<bytes>
starting position of domain in input file [0]
.TP
\fB\-I\fR, \fB\-\-verify\-input\-size\fR
verify input file size with size in logfile
.TP
\fB\-K\fR, \fB\-\-skip\-size=\fR<min>[,<max>]
initial size to skip on read error [64 KiB]
.TP
\fB\-L\fR, \fB\-\-loose\-domain\fR
accept an incomplete domain logfile
.TP
\fB\-m\fR, \fB\-\-domain\-logfile=\fR<file>
restrict domain to finished blocks in file
.TP
\fB\-M\fR, \fB\-\-retrim\fR
mark all failed blocks as non\-trimmed
.TP
\fB\-n\fR, \fB\-\-no\-scrape\fR
skip the scraping phase
.TP
\fB\-N\fR, \fB\-\-no\-trim\fR
skip the trimming phase
.TP
\fB\-o\fR, \fB\-\-output\-position=\fR<bytes>
starting position in output file [ipos]
.TP
\fB\-O\fR, \fB\-\-reopen\-on\-error\fR
reopen input file after every read error
.TP
\fB\-p\fR, \fB\-\-preallocate\fR
preallocate space on disc for output file
.TP
\fB\-P\fR, \fB\-\-data\-preview[=\fR<lines>]
show some lines of the latest data read [3]
.TP
\fB\-q\fR, \fB\-\-quiet\fR
suppress all messages
.TP
\fB\-r\fR, \fB\-\-retry\-passes=\fR<n>
exit after <n> retry passes (\fB\-1\fR=\fI\,infinity\/\fR) [0]
.TP
\fB\-R\fR, \fB\-\-reverse\fR
reverse the direction of all passes
.TP
\fB\-s\fR, \fB\-\-size=\fR<bytes>
maximum size of input data to be copied
.TP
\fB\-S\fR, \fB\-\-sparse\fR
use sparse writes for output file
.TP
\fB\-t\fR, \fB\-\-truncate\fR
truncate output file to zero size
.TP
\fB\-T\fR, \fB\-\-timeout=\fR<interval>
maximum time since last successful read
.TP
\fB\-u\fR, \fB\-\-unidirectional\fR
run all passes in the same direction
.TP
\fB\-v\fR, \fB\-\-verbose\fR
be verbose (a 2nd \fB\-v\fR gives more)
.TP
\fB\-w\fR, \fB\-\-ignore\-write\-errors\fR
make fill mode ignore write errors
.TP
\fB\-x\fR, \fB\-\-extend\-outfile=\fR<bytes>
extend outfile size to be at least this long
.TP
\fB\-X\fR, \fB\-\-exit\-on\-error\fR
exit after the first read error
.TP
\fB\-1\fR, \fB\-\-log\-rates=\fR<file>
log rates and error sizes in file
.TP
\fB\-2\fR, \fB\-\-log\-reads=\fR<file>
log all read operations in file
.TP
\fB\-\-ask\fR
ask for confirmation before starting the copy
.TP
\fB\-\-cpass=\fR<n>[,<n>]
select what copying pass(es) to run
.TP
\fB\-\-pause=\fR<interval>
time to wait between passes [0]
.PP
Numbers may be in decimal, hexadecimal or octal, and may be followed by a
multiplier: s = sectors, k = 1000, Ki = 1024, M = 10^6, Mi = 2^20, etc...
Time intervals have the format 1[.5][smhd] or 1/2[smhd].
.PP
Exit status: 0 for a normal exit, 1 for environmental problems (file
not found, invalid flags, I/O errors, etc), 2 to indicate a corrupt or
invalid input file, 3 for an internal consistency error (eg, bug) which
caused ddrescue to panic.
.SH "REPORTING BUGS"
Report bugs to bug\-ddrescue@gnu.org
.br
Ddrescue home page: http://www.gnu.org/software/ddrescue/ddrescue.html
.br
General help using GNU software: http://www.gnu.org/gethelp
.SH COPYRIGHT
Copyright \(co 2014 Antonio Diaz Diaz.
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>
.br
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
.SH "SEE ALSO"
The full documentation for
.B ddrescue
is maintained as a Texinfo manual.  If the
.B info
and
.B ddrescue
programs are properly installed at your site, the command
.IP
.B info ddrescue
.PP
should give you access to the complete manual.
