<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 1.0.9">
 <TITLE>BIRD User's Guide: Protocols</TITLE>
 <LINK HREF="bird-7.html" REL=next>
 <LINK HREF="bird-5.html" REL=previous>
 <LINK HREF="bird.html#toc6" REL=contents>
</HEAD>
<BODY>
<A HREF="bird-7.html">Next</A>
<A HREF="bird-5.html">Previous</A>
<A HREF="bird.html#toc6">Contents</A>
<HR>
<H2><A NAME="protocols"></A> <A NAME="s6">6.</A> <A HREF="bird.html#toc6">Protocols</A></H2>

<H2><A NAME="babel"></A> <A NAME="ss6.1">6.1</A> <A HREF="bird.html#toc6.1">Babel</A>
</H2>

<H3><A NAME="babel-intro"></A> Introduction</H3>

<P>The Babel protocol
(<A HREF="http://www.rfc-editor.org/info/rfc6126">RFC 6126</A>) is a loop-avoiding distance-vector routing protocol that is
robust and efficient both in ordinary wired networks and in wireless mesh
networks. Babel is conceptually very simple in its operation and "just works"
in its default configuration, though some configuration is possible and in some
cases desirable.
<P>
<P>While the Babel protocol is dual stack (i.e., can carry both IPv4 and IPv6
routes over the same IPv6 transport), BIRD presently implements only the IPv6
subset of the protocol. No Babel extensions are implemented, but the BIRD
implementation can coexist with implementations using the extensions (and will
just ignore extension messages).
<P>
<P>The Babel protocol implementation in BIRD is currently in alpha stage.
<P>
<H3><A NAME="babel-config"></A> Configuration</H3>

<P>Babel supports no global configuration options apart from those common to all
other protocols, but supports the following per-interface configuration options:
<P>
<HR>
<PRE>
protocol babel [&lt;name>] {
        interface &lt;interface pattern> {
                type &lt;wired|wireless>;
                rxcost &lt;number>;
                hello interval &lt;number>;
                update interval &lt;number>;
                port &lt;number>;
                tx class|dscp &lt;number>;
                tx priority &lt;number>;
                rx buffer &lt;number>;
                tx length &lt;number>;
                check link &lt;switch>;
        };
}
</PRE>
<HR>
<P>
<DL>
<DT><CODE>
<A NAME="babel-type"></A> type wired|wireless </CODE><DD><P>This option specifies the interface type: Wired or wireless. Wired
interfaces are considered more reliable, and so the default hello
interval is higher, and a neighbour is considered unreachable after only
a small number of "hello" packets are lost. On wireless interfaces,
hello packets are sent more often, and the ETX link quality estimation
technique is used to compute the metrics of routes discovered over this
interface. This technique will gradually degrade the metric of routes
when packets are lost rather than the more binary up/down mechanism of
wired type links. Default: <CODE>wired</CODE>.
<P>
<DT><CODE>
<A NAME="babel-rxcost"></A> rxcost <I>num</I></CODE><DD><P>This specifies the RX cost of the interface. The route metrics will be
computed from this value with a mechanism determined by the interface
<CODE>type</CODE>. Default: 96 for wired interfaces, 256 for wireless.
<P>
<DT><CODE>
<A NAME="babel-hello"></A> hello interval <I>num</I></CODE><DD><P>Interval at which periodic "hello" messages are sent on this interface,
in seconds. Default: 4 seconds.
<P>
<DT><CODE>
<A NAME="babel-update"></A> update interval <I>num</I></CODE><DD><P>Interval at which periodic (full) updates are sent. Default: 4 times the
hello interval.
<P>
<DT><CODE>
<A NAME="babel-port"></A> port <I>number</I></CODE><DD><P>This option selects an UDP port to operate on. The default is to operate
on port 6696 as specified in the Babel RFC.
<P>
<DT><CODE>
<A NAME="babel-tx-class"></A> tx class|dscp|priority <I>number</I></CODE><DD><P>These options specify the ToS/DiffServ/Traffic class/Priority of the
outgoing Babel packets. See 
<A HREF="bird-3.html#proto-tx-class">tx class</A> common
option for detailed description.
<P>
<DT><CODE>
<A NAME="babel-rx-buffer"></A> rx buffer <I>number</I></CODE><DD><P>This option specifies the size of buffers used for packet processing.
The buffer size should be bigger than maximal size of received packets.
The default value is the interface MTU, and the value will be clamped to a
minimum of 512 bytes + IP packet overhead.
<P>
<DT><CODE>
<A NAME="babel-tx-length"></A> tx length <I>number</I></CODE><DD><P>This option specifies the maximum length of generated Babel packets. To
avoid IP fragmentation, it should not exceed the interface MTU value.
The default value is the interface MTU value, and the value will be
clamped to a minimum of 512 bytes + IP packet overhead.
<P>
<DT><CODE>
<A NAME="babel-check-link"></A> check link <I>switch</I></CODE><DD><P>If set, the hardware link state (as reported by OS) is taken into
consideration. When the link disappears (e.g. an ethernet cable is
unplugged), neighbors are immediately considered unreachable and all
routes received from them are withdrawn. It is possible that some
hardware drivers or platforms do not implement this feature. Default:
yes.
</DL>
<P>
<H3><A NAME="babel-attr"></A> Attributes</H3>

<P>Babel defines just one attribute: the internal babel metric of the route. It
is exposed as the <CODE>babel_metric</CODE> attribute and has range from 1 to infinity
(65535).
<P>
<H3><A NAME="babel-exam"></A> Example</H3>

<P>
<HR>
<PRE>
protocol babel {
        interface "eth*" {
                type wired;
        };
        interface "wlan0", "wlan1" {
                type wireless;
                hello interval 1;
                rxcost 512;
        };
        interface "tap0";

        # This matches the default of babeld: redistribute all addresses
        # configured on local interfaces, plus re-distribute all routes received
        # from other babel peers.

        export where (source = RTS_DEVICE) || (source = RTS_BABEL);
}
</PRE>
<HR>
<P>
<P>
<H2><A NAME="bfd"></A> <A NAME="ss6.2">6.2</A> <A HREF="bird.html#toc6.2">BFD</A>
</H2>

<H3><A NAME="bfd-intro"></A> Introduction</H3>

<P>Bidirectional Forwarding Detection (BFD) is not a routing protocol itself, it
is an independent tool providing liveness and failure detection. Routing
protocols like OSPF and BGP use integrated periodic "hello" messages to monitor
liveness of neighbors, but detection times of these mechanisms are high (e.g. 40
seconds by default in OSPF, could be set down to several seconds). BFD offers
universal, fast and low-overhead mechanism for failure detection, which could be
attached to any routing protocol in an advisory role.
<P>
<P>BFD consists of mostly independent BFD sessions. Each session monitors an
unicast bidirectional path between two BFD-enabled routers. This is done by
periodically sending control packets in both directions. BFD does not handle
neighbor discovery, BFD sessions are created on demand by request of other
protocols (like OSPF or BGP), which supply appropriate information like IP
addresses and associated interfaces. When a session changes its state, these
protocols are notified and act accordingly (e.g. break an OSPF adjacency when
the BFD session went down).
<P>
<P>BIRD implements basic BFD behavior as defined in <A HREF="http://www.rfc-editor.org/info/rfc5880">RFC 5880</A> (some
advanced features like the echo mode or authentication are not implemented), IP
transport for BFD as defined in <A HREF="http://www.rfc-editor.org/info/rfc5881">RFC 5881</A> and <A HREF="http://www.rfc-editor.org/info/rfc5883">RFC 5883</A> and
interaction with client protocols as defined in <A HREF="http://www.rfc-editor.org/info/rfc5882">RFC 5882</A>.
<P>
<P>Note that BFD implementation in BIRD is currently a new feature in
development, expect some rough edges and possible UI and configuration changes
in the future. Also note that we currently support at most one protocol instance.
<P>
<P>BFD packets are sent with a dynamic source port number. Linux systems use by
default a bit different dynamic port range than the IANA approved one
(49152-65535). If you experience problems with compatibility, please adjust
<CODE>/proc/sys/net/ipv4/ip_local_port_range</CODE>
<P>
<H3><A NAME="bfd-config"></A> Configuration</H3>

<P>BFD configuration consists mainly of multiple definitions of interfaces.
Most BFD config options are session specific. When a new session is requested
and dynamically created, it is configured from one of these definitions. For
sessions to directly connected neighbors, <CODE>interface</CODE> definitions are chosen
based on the interface associated with the session, while <CODE>multihop</CODE>
definition is used for multihop sessions. If no definition is relevant, the
session is just created with the default configuration. Therefore, an empty BFD
configuration is often sufficient.
<P>
<P>Note that to use BFD for other protocols like OSPF or BGP, these protocols
also have to be configured to request BFD sessions, usually by <CODE>bfd</CODE> option.
<P>
<P>Some of BFD session options require <I>time</I> value, which has to be specified
with the appropriate unit: <I>num</I> <CODE>s</CODE>|<CODE>ms</CODE>|<CODE>us</CODE>. Although microseconds
are allowed as units, practical minimum values are usually in order of tens of
milliseconds.
<P>
<HR>
<PRE>
protocol bfd [&lt;name&gt;] {
        interface &lt;interface pattern&gt; {
                interval &lt;time&gt;;
                min rx interval &lt;time&gt;;
                min tx interval &lt;time&gt;;
                idle tx interval &lt;time&gt;;
                multiplier &lt;num&gt;;
                passive &lt;switch&gt;;
                authentication none;
                authentication simple;
                authentication [meticulous] keyed md5|sha1;
                password "&lt;text&gt;";
                password "&lt;text&gt;" {
                        id &lt;num&gt;;
                        generate from "&lt;date&gt;";
                        generate to "&lt;date&gt;";
                        accept from "&lt;date&gt;";
                        accept to "&lt;date&gt;";
                        from "&lt;date&gt;";
                        to "&lt;date&gt;";
                };
        };
        multihop {
                interval &lt;time&gt;;
                min rx interval &lt;time&gt;;
                min tx interval &lt;time&gt;;
                idle tx interval &lt;time&gt;;
                multiplier &lt;num&gt;;
                passive &lt;switch&gt;;
        };
        neighbor &lt;ip&gt; [dev "&lt;interface&gt;"] [local &lt;ip&gt;] [multihop &lt;switch&gt;];
}
</PRE>
<HR>
<P>
<DL>
<DT><CODE>
<A NAME="bfd-iface"></A> interface <I>pattern</I> [, <I>...</I>] { <I>options</I> }</CODE><DD><P>Interface definitions allow to specify options for sessions associated
with such interfaces and also may contain interface specific options.
See 
<A HREF="bird-3.html#proto-iface">interface</A> common option for a detailed
description of interface patterns. Note that contrary to the behavior of
<CODE>interface</CODE> definitions of other protocols, BFD protocol would accept
sessions (in default configuration) even on interfaces not covered by
such definitions.
<P>
<DT><CODE>
<A NAME="bfd-multihop"></A> multihop { <I>options</I> }</CODE><DD><P>Multihop definitions allow to specify options for multihop BFD sessions,
in the same manner as <CODE>interface</CODE> definitions are used for directly
connected sessions. Currently only one such definition (for all multihop
sessions) could be used.
<P>
<DT><CODE>
<A NAME="bfd-neighbor"></A> neighbor <I>ip</I> [dev "<I>interface</I>"] [local <I>ip</I>] [multihop <I>switch</I>]</CODE><DD><P>BFD sessions are usually created on demand as requested by other
protocols (like OSPF or BGP). This option allows to explicitly add
a BFD session to the specified neighbor regardless of such requests.
<P>The session is identified by the IP address of the neighbor, with
optional specification of used interface and local IP. By default
the neighbor must be directly connected, unless the session is
configured as multihop. Note that local IP must be specified for
multihop sessions.
</DL>
<P>
<P>Session specific options (part of <CODE>interface</CODE> and <CODE>multihop</CODE> definitions):
<P>
<DL>
<DT><CODE>
<A NAME="bfd-interval"></A> interval <I>time</I></CODE><DD><P>BFD ensures availability of the forwarding path associated with the
session by periodically sending BFD control packets in both
directions. The rate of such packets is controlled by two options,
<CODE>min rx interval</CODE> and <CODE>min tx interval</CODE> (see below). This option
is just a shorthand to set both of these options together.
<P>
<DT><CODE>
<A NAME="bfd-min-rx-interval"></A> min rx interval <I>time</I></CODE><DD><P>This option specifies the minimum RX interval, which is announced to the
neighbor and used there to limit the neighbor's rate of generated BFD
control packets. Default: 10 ms.
<P>
<DT><CODE>
<A NAME="bfd-min-tx-interval"></A> min tx interval <I>time</I></CODE><DD><P>This option specifies the desired TX interval, which controls the rate
of generated BFD control packets (together with <CODE>min rx interval</CODE>
announced by the neighbor). Note that this value is used only if the BFD
session is up, otherwise the value of <CODE>idle tx interval</CODE> is used
instead. Default: 100 ms.
<P>
<DT><CODE>
<A NAME="bfd-idle-tx-interval"></A> idle tx interval <I>time</I></CODE><DD><P>In order to limit unnecessary traffic in cases where a neighbor is not
available or not running BFD, the rate of generated BFD control packets
is lower when the BFD session is not up. This option specifies the
desired TX interval in such cases instead of <CODE>min tx interval</CODE>.
Default: 1 s.
<P>
<DT><CODE>
<A NAME="bfd-multiplier"></A> multiplier <I>num</I></CODE><DD><P>Failure detection time for BFD sessions is based on established rate of
BFD control packets (<CODE>min rx/tx interval</CODE>) multiplied by this
multiplier, which is essentially (ignoring jitter) a number of missed
packets after which the session is declared down. Note that rates and
multipliers could be different in each direction of a BFD session.
Default: 5.
<P>
<DT><CODE>
<A NAME="bfd-passive"></A> passive <I>switch</I></CODE><DD><P>Generally, both BFD session endpoints try to establish the session by
sending control packets to the other side. This option allows to enable
passive mode, which means that the router does not send BFD packets
until it has received one from the other side. Default: disabled.
<P>
<DT><CODE>authentication none</CODE><DD><P>No passwords are sent in BFD packets. This is the default value.
<P>
<DT><CODE>authentication simple</CODE><DD><P>Every packet carries 16 bytes of password. Received packets lacking this
password are ignored. This authentication mechanism is very weak.
<P>
<DT><CODE>authentication [meticulous] keyed md5|sha1</CODE><DD><P>An authentication code is appended to each packet. The cryptographic
algorithm is keyed MD5 or keyed SHA-1. Note that the algorithm is common
for all keys (on one interface), in contrast to OSPF or RIP, where it
is a per-key option. Passwords (keys) are not sent open via network.
<P>The <CODE>meticulous</CODE> variant means that cryptographic sequence numbers
are increased for each sent packet, while in the basic variant they are
increased about once per second. Generally, the <CODE>meticulous</CODE> variant
offers better resistance to replay attacks but may require more
computation.
<P>
<DT><CODE>password "<I>text</I>"</CODE><DD><P>Specifies a password used for authentication. See 
<A HREF="bird-3.html#proto-iface">interface</A><@@ref>dsc-passpassword</A> common option for detailed description. Note that
password option <CODE>algorithm</CODE> is not available in BFD protocol. The
algorithm is selected by <CODE>authentication</CODE> option for all passwords.
<P>
</DL>
<P>
<H3><A NAME="bfd-exam"></A> Example</H3>

<P>
<HR>
<PRE>
protocol bfd {
        interface "eth*" {
                min rx interval 20 ms;
                min tx interval 50 ms;
                idle tx interval 300 ms;
        };
        interface "gre*" {
                interval 200 ms;
                multiplier 10;
                passive;
        };
        multihop {
                interval 200 ms;
                multiplier 10;
        };

        neighbor 192.168.1.10;
        neighbor 192.168.2.2 dev "eth2";
        neighbor 192.168.10.1 local 192.168.1.1 multihop;
}
</PRE>
<HR>
<P>
<P>
<H2><A NAME="bgp"></A> <A NAME="ss6.3">6.3</A> <A HREF="bird.html#toc6.3">BGP</A>
</H2>

<P>The Border Gateway Protocol is the routing protocol used for backbone level
routing in the today's Internet. Contrary to other protocols, its convergence
does not rely on all routers following the same rules for route selection,
making it possible to implement any routing policy at any router in the network,
the only restriction being that if a router advertises a route, it must accept
and forward packets according to it.
<P>
<P>BGP works in terms of autonomous systems (often abbreviated as AS). Each AS
is a part of the network with common management and common routing policy. It is
identified by a unique 16-bit number (ASN). Routers within each AS usually
exchange AS-internal routing information with each other using an interior
gateway protocol (IGP, such as OSPF or RIP). Boundary routers at the border of
the AS communicate global (inter-AS) network reachability information with their
neighbors in the neighboring AS'es via exterior BGP (eBGP) and redistribute
received information to other routers in the AS via interior BGP (iBGP).
<P>
<P>Each BGP router sends to its neighbors updates of the parts of its routing
table it wishes to export along with complete path information (a list of AS'es
the packet will travel through if it uses the particular route) in order to
avoid routing loops.
<P>
<P>BIRD supports all requirements of the BGP4 standard as defined in
<A HREF="http://www.rfc-editor.org/info/rfc4271">RFC 4271</A> It also supports the community attributes (<A HREF="http://www.rfc-editor.org/info/rfc1997">RFC 1997</A>),
capability negotiation (<A HREF="http://www.rfc-editor.org/info/rfc5492">RFC 5492</A>), MD5 password authentication (<A HREF="http://www.rfc-editor.org/info/rfc2385">RFC 2385</A>), extended communities (<A HREF="http://www.rfc-editor.org/info/rfc4360">RFC 4360</A>), route reflectors (<A HREF="http://www.rfc-editor.org/info/rfc4456">RFC 4456</A>), graceful restart (<A HREF="http://www.rfc-editor.org/info/rfc4724">RFC 4724</A>), multiprotocol extensions
(<A HREF="http://www.rfc-editor.org/info/rfc4760">RFC 4760</A>), 4B AS numbers (<A HREF="http://www.rfc-editor.org/info/rfc4893">RFC 4893</A>), and 4B AS numbers in
extended communities (<A HREF="http://www.rfc-editor.org/info/rfc5668">RFC 5668</A>).
<P>
<P>For IPv6, it uses the standard multiprotocol extensions defined in
<A HREF="http://www.rfc-editor.org/info/rfc4760">RFC 4760</A> and applied to IPv6 according to <A HREF="http://www.rfc-editor.org/info/rfc2545">RFC 2545</A>.
<P>
<H3><A NAME="bgp-route-select-rules"></A> Route selection rules</H3>

<P>BGP doesn't have any simple metric, so the rules for selection of an optimal
route among multiple BGP routes with the same preference are a bit more complex
and they are implemented according to the following algorithm. It starts the
first rule, if there are more "best" routes, then it uses the second rule to
choose among them and so on.
<P>
<UL>
<LI>Prefer route with the highest Local Preference attribute.</LI>
<LI>Prefer route with the shortest AS path.</LI>
<LI>Prefer IGP origin over EGP and EGP origin over incomplete.</LI>
<LI>Prefer the lowest value of the Multiple Exit Discriminator.</LI>
<LI>Prefer routes received via eBGP over ones received via iBGP.</LI>
<LI>Prefer routes with lower internal distance to a boundary router.</LI>
<LI>Prefer the route with the lowest value of router ID of the
advertising router.</LI>
</UL>
<P>
<H3><A NAME="bgp-igp-routing-table"></A> IGP routing table</H3>

<P>BGP is mainly concerned with global network reachability and with routes to
other autonomous systems. When such routes are redistributed to routers in the
AS via BGP, they contain IP addresses of a boundary routers (in route attribute
NEXT_HOP). BGP depends on existing IGP routing table with AS-internal routes to
determine immediate next hops for routes and to know their internal distances to
boundary routers for the purpose of BGP route selection. In BIRD, there is
usually one routing table used for both IGP routes and BGP routes.
<P>
<H3><A NAME="bgp-config"></A> Configuration</H3>

<P>Each instance of the BGP corresponds to one neighboring router. This allows
to set routing policy and all the other parameters differently for each neighbor
using the following configuration parameters:
<P>
<DL>
<DT><CODE>
<A NAME="bgp-local"></A> local [<I>ip</I>] as <I>number</I></CODE><DD><P>Define which AS we are part of. (Note that contrary to other IP routers,
BIRD is able to act as a router located in multiple AS'es simultaneously,
but in such cases you need to tweak the BGP paths manually in the filters
to get consistent behavior.) Optional <CODE>ip</CODE> argument specifies a source
address, equivalent to the <CODE>source address</CODE> option (see below). This
parameter is mandatory.
<P>
<DT><CODE>
<A NAME="bgp-neighbor"></A> neighbor [<I>ip</I>] [port <I>number</I>] [as <I>number</I>]</CODE><DD><P>Define neighboring router this instance will be talking to and what AS
it is located in. In case the neighbor is in the same AS as we are, we
automatically switch to iBGP. Optionally, the remote port may also be
specified. The parameter may be used multiple times with different
sub-options (e.g., both <CODE>neighbor 10.0.0.1 as 65000;</CODE> and
<CODE>neighbor 10.0.0.1; neighbor as 65000;</CODE> are valid). This parameter is
mandatory.
<P>
<DT><CODE>
<A NAME="bgp-iface"></A> interface <I>string</I></CODE><DD><P>Define interface we should use for link-local BGP IPv6 sessions.
Interface can also be specified as a part of <CODE>neighbor address</CODE>
(e.g., <CODE>neighbor fe80::1234%eth0 as 65000;</CODE>). It is an error to use
this parameter for non link-local sessions.
<P>
<DT><CODE>
<A NAME="bgp-direct"></A> direct</CODE><DD><P>Specify that the neighbor is directly connected. The IP address of the
neighbor must be from a directly reachable IP range (i.e. associated
with one of your router's interfaces), otherwise the BGP session
wouldn't start but it would wait for such interface to appear. The
alternative is the <CODE>multihop</CODE> option. Default: enabled for eBGP.
<P>
<DT><CODE>
<A NAME="bgp-multihop"></A> multihop [<I>number</I>]</CODE><DD><P>Configure multihop BGP session to a neighbor that isn't directly
connected. Accurately, this option should be used if the configured
neighbor IP address does not match with any local network subnets. Such
IP address have to be reachable through system routing table. The
alternative is the <CODE>direct</CODE> option. For multihop BGP it is
recommended to explicitly configure the source address to have it
stable. Optional <CODE>number</CODE> argument can be used to specify the number
of hops (used for TTL). Note that the number of networks (edges) in a
path is counted; i.e., if two BGP speakers are separated by one router,
the number of hops is 2. Default: enabled for iBGP.
<P>
<DT><CODE>
<A NAME="bgp-source-address"></A> source address <I>ip</I></CODE><DD><P>Define local address we should use for next hop calculation and as a
source address for the BGP session. Default: the address of the local
end of the interface our neighbor is connected to.
<P>
<DT><CODE>
<A NAME="bgp-next-hop-self"></A> next hop self</CODE><DD><P>Avoid calculation of the Next Hop attribute and always advertise our own
source address as a next hop. This needs to be used only occasionally to
circumvent misconfigurations of other routers. Default: disabled.
<P>
<DT><CODE>
<A NAME="bgp-next-hop-keep"></A> next hop keep</CODE><DD><P>Forward the received Next Hop attribute even in situations where the
local address should be used instead, like when the route is sent to an
interface with a different subnet. Default: disabled.
<P>
<DT><CODE>
<A NAME="bgp-missing-lladdr"></A> missing lladdr self|drop|ignore</CODE><DD><P>Next Hop attribute in BGP-IPv6 sometimes contains just the global IPv6
address, but sometimes it has to contain both global and link-local IPv6
addresses. This option specifies what to do if BIRD have to send both
addresses but does not know link-local address. This situation might
happen when routes from other protocols are exported to BGP, or when
improper updates are received from BGP peers. <CODE>self</CODE> means that BIRD
advertises its own local address instead. <CODE>drop</CODE> means that BIRD
skips that prefixes and logs error. <CODE>ignore</CODE> means that BIRD ignores
the problem and sends just the global address (and therefore forms
improper BGP update). Default: <CODE>self</CODE>, unless BIRD is configured as a
route server (option <CODE>rs client</CODE>), in that case default is <CODE>ignore</CODE>,
because route servers usually do not forward packets themselves.
<P>
<DT><CODE>
<A NAME="bgp-gateway"></A> gateway direct|recursive</CODE><DD><P>For received routes, their <CODE>gw</CODE> (immediate next hop) attribute is
computed from received <CODE>bgp_next_hop</CODE> attribute. This option
specifies how it is computed. Direct mode means that the IP address from
<CODE>bgp_next_hop</CODE> is used if it is directly reachable, otherwise the
neighbor IP address is used. Recursive mode means that the gateway is
computed by an IGP routing table lookup for the IP address from
<CODE>bgp_next_hop</CODE>. Note that there is just one level of indirection in
recursive mode - the route obtained by the lookup must not be recursive
itself, to prevent mutually recursive routes.
<P>Recursive mode is the behavior specified by the BGP
standard. Direct mode is simpler, does not require any routes in a
routing table, and was used in older versions of BIRD, but does not
handle well nontrivial iBGP setups and multihop. Recursive mode is
incompatible with 
<A HREF="bird-2.html#dsc-table-sorted">sorted tables</A>. Default:
<CODE>direct</CODE> for direct sessions, <CODE>recursive</CODE> for multihop sessions.
<P>
<DT><CODE>
<A NAME="bgp-igp-table"></A> igp table <I>name</I></CODE><DD><P>Specifies a table that is used as an IGP routing table. Default: the
same as the table BGP is connected to.
<P>
<DT><CODE>
<A NAME="bgp-check-link"></A> check link <I>switch</I></CODE><DD><P>BGP could use hardware link state into consideration.  If enabled,
BIRD tracks the link state of the associated interface and when link
disappears (e.g. an ethernet cable is unplugged), the BGP session is
immediately shut down. Note that this option cannot be used with
multihop BGP. Default: disabled.
<P>
<DT><CODE>
<A NAME="bgp-bfd"></A> bfd <I>switch</I></CODE><DD><P>BGP could use BFD protocol as an advisory mechanism for neighbor
liveness and failure detection. If enabled, BIRD setups a BFD session
for the BGP neighbor and tracks its liveness by it. This has an
advantage of an order of magnitude lower detection times in case of
failure. Note that BFD protocol also has to be configured, see
<A HREF="#bfd">BFD</A> section for details. Default: disabled.
<P>
<DT><CODE>
<A NAME="bgp-ttl-security"></A> ttl security <I>switch</I></CODE><DD><P>Use GTSM (<A HREF="http://www.rfc-editor.org/info/rfc5082">RFC 5082</A> - the generalized TTL security mechanism). GTSM
protects against spoofed packets by ignoring received packets with a
smaller than expected TTL. To work properly, GTSM have to be enabled on
both sides of a BGP session. If both <CODE>ttl security</CODE> and
<CODE>multihop</CODE> options are enabled, <CODE>multihop</CODE> option should specify
proper hop value to compute expected TTL. Kernel support required:
Linux: 2.6.34+ (IPv4), 2.6.35+ (IPv6), BSD: since long ago, IPv4 only.
Note that full (ICMP protection, for example) <A HREF="http://www.rfc-editor.org/info/rfc5082">RFC 5082</A> support is
provided by Linux only. Default: disabled.
<P>
<DT><CODE>
<A NAME="bgp-pass"></A> password <I>string</I></CODE><DD><P>Use this password for MD5 authentication of BGP sessions (<A HREF="http://www.rfc-editor.org/info/rfc2385">RFC 2385</A>). When
used on BSD systems, see also <CODE>setkey</CODE> option below. Default: no
authentication.
<P>
<DT><CODE>
<A NAME="bgp-setkey"></A> setkey <I>switch</I></CODE><DD><P>On BSD systems, keys for TCP MD5 authentication are stored in the global
SA/SP database, which can be accessed by external utilities (e.g.
setkey(8)). BIRD configures security associations in the SA/SP database
automatically based on <CODE>password</CODE> options (see above), this option
allows to disable automatic updates by BIRD when manual configuration by
external utilities is preferred. Note that automatic SA/SP database
updates are currently implemented only for FreeBSD. Passwords have to be
set manually by an external utility on NetBSD and OpenBSD. Default:
enabled (ignored on non-FreeBSD).
<P>
<DT><CODE>
<A NAME="bgp-passive"></A> passive <I>switch</I></CODE><DD><P>Standard BGP behavior is both initiating outgoing connections and
accepting incoming connections. In passive mode, outgoing connections
are not initiated. Default: off.
<P>
<DT><CODE>
<A NAME="bgp-rr-client"></A> rr client</CODE><DD><P>Be a route reflector and treat the neighbor as a route reflection
client. Default: disabled.
<P>
<DT><CODE>
<A NAME="bgp-rr-cluster-id"></A> rr cluster id <I>IPv4 address</I></CODE><DD><P>Route reflectors use cluster id to avoid route reflection loops. When
there is one route reflector in a cluster it usually uses its router id
as a cluster id, but when there are more route reflectors in a cluster,
these need to be configured (using this option) to use a common cluster
id. Clients in a cluster need not know their cluster id and this option
is not allowed for them. Default: the same as router id.
<P>
<DT><CODE>
<A NAME="bgp-rs-client"></A> rs client</CODE><DD><P>Be a route server and treat the neighbor as a route server client.
A route server is used as a replacement for full mesh EBGP routing in
Internet exchange points in a similar way to route reflectors used in
IBGP routing. BIRD does not implement obsoleted <A HREF="http://www.rfc-editor.org/info/rfc1863">RFC 1863</A>, but
uses ad-hoc implementation, which behaves like plain EBGP but reduces
modifications to advertised route attributes to be transparent (for
example does not prepend its AS number to AS PATH attribute and
keeps MED attribute). Default: disabled.
<P>
<DT><CODE>
<A NAME="bgp-secondary"></A> secondary <I>switch</I></CODE><DD><P>Usually, if an export filter rejects a selected route, no other route is
propagated for that network. This option allows to try the next route in
order until one that is accepted is found or all routes for that network
are rejected. This can be used for route servers that need to propagate
different tables to each client but do not want to have these tables
explicitly (to conserve memory). This option requires that the connected
routing table is 
<A HREF="bird-2.html#dsc-table-sorted">sorted</A>. Default: off.
<P>
<DT><CODE>
<A NAME="bgp-add-paths"></A> add paths <I>switch</I>|rx|tx</CODE><DD><P>Standard BGP can propagate only one path (route) per destination network
(usually the selected one). This option controls the add-path protocol
extension, which allows to advertise any number of paths to a
destination. Note that to be active, add-path has to be enabled on both
sides of the BGP session, but it could be enabled separately for RX and
TX direction. When active, all available routes accepted by the export
filter are advertised to the neighbor. Default: off.
<P>
<DT><CODE>
<A NAME="bgp-allow-local-as"></A> allow local as [<I>number</I>]</CODE><DD><P>BGP prevents routing loops by rejecting received routes with the local
AS number in the AS path. This option allows to loose or disable the
check. Optional <CODE>number</CODE> argument can be used to specify the maximum
number of local ASNs in the AS path that is allowed for received
routes. When the option is used without the argument, the check is
completely disabled and you should ensure loop-free behavior by some
other means. Default: 0 (no local AS number allowed).
<P>
<DT><CODE>
<A NAME="bgp-enable-route-refresh"></A> enable route refresh <I>switch</I></CODE><DD><P>After the initial route exchange, BGP protocol uses incremental updates
to keep BGP speakers synchronized. Sometimes (e.g., if BGP speaker
changes its import filter, or if there is suspicion of inconsistency) it
is necessary to do a new complete route exchange. BGP protocol extension
Route Refresh (<A HREF="http://www.rfc-editor.org/info/rfc2918">RFC 2918</A>) allows BGP speaker to request
re-advertisement of all routes from its neighbor. BGP protocol
extension Enhanced Route Refresh (<A HREF="http://www.rfc-editor.org/info/rfc7313">RFC 7313</A>) specifies explicit
begin and end for such exchanges, therefore the receiver can remove
stale routes that were not advertised during the exchange. This option
specifies whether BIRD advertises these capabilities and supports
related procedures. Note that even when disabled, BIRD can send route
refresh requests.  Default: on.
<P>
<DT><CODE>
<A NAME="bgp-graceful-restart"></A> graceful restart <I>switch</I>|aware</CODE><DD><P>When a BGP speaker restarts or crashes, neighbors will discard all
received paths from the speaker, which disrupts packet forwarding even
when the forwarding plane of the speaker remains intact. <A HREF="http://www.rfc-editor.org/info/rfc4724">RFC 4724</A> specifies an optional graceful restart mechanism to
alleviate this issue. This option controls the mechanism. It has three
states: Disabled, when no support is provided. Aware, when the graceful
restart support is announced and the support for restarting neighbors
is provided, but no local graceful restart is allowed (i.e.
receiving-only role). Enabled, when the full graceful restart
support is provided (i.e. both restarting and receiving role). Note
that proper support for local graceful restart requires also
configuration of other protocols.  Default: aware.
<P>
<DT><CODE>
<A NAME="bgp-graceful-restart-time"></A> graceful restart time <I>number</I></CODE><DD><P>The restart time is announced in the BGP graceful restart capability
and specifies how long the neighbor would wait for the BGP session to
re-establish after a restart before deleting stale routes. Default:
120 seconds.
<P>
<DT><CODE>
<A NAME="bgp-interpret-communities"></A> interpret communities <I>switch</I></CODE><DD><P><A HREF="http://www.rfc-editor.org/info/rfc1997">RFC 1997</A> demands that BGP speaker should process well-known
communities like no-export (65535, 65281) or no-advertise (65535,
65282). For example, received route carrying a no-adverise community
should not be advertised to any of its neighbors. If this option is
enabled (which is by default), BIRD has such behavior automatically (it
is evaluated when a route is exported to the BGP protocol just before
the export filter).  Otherwise, this integrated processing of
well-known communities is disabled. In that case, similar behavior can
be implemented in the export filter.  Default: on.
<P>
<DT><CODE>
<A NAME="bgp-enable-as4"></A> enable as4 <I>switch</I></CODE><DD><P>BGP protocol was designed to use 2B AS numbers and was extended later to
allow 4B AS number. BIRD supports 4B AS extension, but by disabling this
option it can be persuaded not to advertise it and to maintain old-style
sessions with its neighbors. This might be useful for circumventing bugs
in neighbor's implementation of 4B AS extension. Even when disabled
(off), BIRD behaves internally as AS4-aware BGP router. Default: on.
<P>
<DT><CODE>
<A NAME="bgp-enable-extended-messages"></A> enable extended messages <I>switch</I></CODE><DD><P>The BGP protocol uses maximum message length of 4096 bytes. This option
provides an extension to allow extended messages with length up
to 65535 bytes. Default: off.
<P>
<DT><CODE>
<A NAME="bgp-capabilities"></A> capabilities <I>switch</I></CODE><DD><P>Use capability advertisement to advertise optional capabilities. This is
standard behavior for newer BGP implementations, but there might be some
older BGP implementations that reject such connection attempts. When
disabled (off), features that request it (4B AS support) are also
disabled. Default: on, with automatic fallback to off when received
capability-related error.
<P>
<DT><CODE>
<A NAME="bgp-advertise-ipv4"></A> advertise ipv4 <I>switch</I></CODE><DD><P>Advertise IPv4 multiprotocol capability. This is not a correct behavior
according to the strict interpretation of <A HREF="http://www.rfc-editor.org/info/rfc4760">RFC 4760</A>, but it is
widespread and required by some BGP implementations (Cisco and Quagga).
This option is relevant to IPv4 mode with enabled capability
advertisement only. Default: on.
<P>
<DT><CODE>
<A NAME="bgp-route-limit"></A> route limit <I>number</I></CODE><DD><P>The maximal number of routes that may be imported from the protocol. If
the route limit is exceeded, the connection is closed with an error.
Limit is currently implemented as <CODE>import limit <I>number</I> action
restart</CODE>. This option is obsolete and it is replaced by
<A HREF="bird-3.html#proto-import-limit">import limit option</A>. Default: no limit.
<P>
<DT><CODE>
<A NAME="bgp-disable-after-error"></A> disable after error <I>switch</I></CODE><DD><P>When an error is encountered (either locally or by the other side),
disable the instance automatically and wait for an administrator to fix
the problem manually. Default: off.
<P>
<DT><CODE>
<A NAME="bgp-hold-time"></A> hold time <I>number</I></CODE><DD><P>Time in seconds to wait for a Keepalive message from the other side
before considering the connection stale. Default: depends on agreement
with the neighboring router, we prefer 240 seconds if the other side is
willing to accept it.
<P>
<DT><CODE>
<A NAME="bgp-startup-hold-time"></A> startup hold time <I>number</I></CODE><DD><P>Value of the hold timer used before the routers have a chance to exchange
open messages and agree on the real value. Default: 240 seconds.
<P>
<DT><CODE>
<A NAME="bgp-keepalive-time"></A> keepalive time <I>number</I></CODE><DD><P>Delay in seconds between sending of two consecutive Keepalive messages.
Default: One third of the hold time.
<P>
<DT><CODE>
<A NAME="bgp-connect-delay-time"></A> connect delay time <I>number</I></CODE><DD><P>Delay in seconds between protocol startup and the first attempt to
connect. Default: 5 seconds.
<P>
<DT><CODE>
<A NAME="bgp-connect-retry-time"></A> connect retry time <I>number</I></CODE><DD><P>Time in seconds to wait before retrying a failed attempt to connect.
Default: 120 seconds.
<P>
<DT><CODE>
<A NAME="bgp-error-wait-time"></A> error wait time <I>number</I>,<I>number</I></CODE><DD><P>Minimum and maximum delay in seconds between a protocol failure (either
local or reported by the peer) and automatic restart. Doesn't apply
when <CODE>disable after error</CODE> is configured. If consecutive errors
happen, the delay is increased exponentially until it reaches the
maximum. Default: 60, 300.
<P>
<DT><CODE>
<A NAME="bgp-error-forget-time"></A> error forget time <I>number</I></CODE><DD><P>Maximum time in seconds between two protocol failures to treat them as a
error sequence which makes <CODE>error wait time</CODE> increase exponentially.
Default: 300 seconds.
<P>
<DT><CODE>
<A NAME="bgp-path-metric"></A> path metric <I>switch</I></CODE><DD><P>Enable comparison of path lengths when deciding which BGP route is the
best one. Default: on.
<P>
<DT><CODE>
<A NAME="bgp-med-metric"></A> med metric <I>switch</I></CODE><DD><P>Enable comparison of MED attributes (during best route selection) even
between routes received from different ASes. This may be useful if all
MED attributes contain some consistent metric, perhaps enforced in
import filters of AS boundary routers. If this option is disabled, MED
attributes are compared only if routes are received from the same AS
(which is the standard behavior). Default: off.
<P>
<DT><CODE>
<A NAME="bgp-deterministic-med"></A> deterministic med <I>switch</I></CODE><DD><P>BGP route selection algorithm is often viewed as a comparison between
individual routes (e.g. if a new route appears and is better than the
current best one, it is chosen as the new best one). But the proper
route selection, as specified by <A HREF="http://www.rfc-editor.org/info/rfc4271">RFC 4271</A>, cannot be fully
implemented in that way. The problem is mainly in handling the MED
attribute. BIRD, by default, uses an simplification based on individual
route comparison, which in some cases may lead to temporally dependent
behavior (i.e. the selection is dependent on the order in which routes
appeared). This option enables a different (and slower) algorithm
implementing proper <A HREF="http://www.rfc-editor.org/info/rfc4271">RFC 4271</A> route selection, which is
deterministic. Alternative way how to get deterministic behavior is to
use <CODE>med metric</CODE> option. This option is incompatible with 
<A HREF="bird-2.html#dsc-table-sorted">sorted tables</A>.  Default: off.
<P>
<DT><CODE>
<A NAME="bgp-igp-metric"></A> igp metric <I>switch</I></CODE><DD><P>Enable comparison of internal distances to boundary routers during best
route selection. Default: on.
<P>
<DT><CODE>
<A NAME="bgp-prefer-older"></A> prefer older <I>switch</I></CODE><DD><P>Standard route selection algorithm breaks ties by comparing router IDs.
This changes the behavior to prefer older routes (when both are external
and from different peer). For details, see <A HREF="http://www.rfc-editor.org/info/rfc5004">RFC 5004</A>. Default: off.
<P>
<DT><CODE>
<A NAME="bgp-default-med"></A> default bgp_med <I>number</I></CODE><DD><P>Value of the Multiple Exit Discriminator to be used during route
selection when the MED attribute is missing. Default: 0.
<P>
<DT><CODE>
<A NAME="bgp-default-local-pref"></A> default bgp_local_pref <I>number</I></CODE><DD><P>A default value for the Local Preference attribute. It is used when
a new Local Preference attribute is attached to a route by the BGP
protocol itself (for example, if a route is received through eBGP and
therefore does not have such attribute). Default: 100 (0 in pre-1.2.0
versions of BIRD).
</DL>
<P>
<H3><A NAME="bgp-attr"></A> Attributes</H3>

<P>BGP defines several route attributes. Some of them (those marked with
`<CODE>I</CODE>' in the table below) are available on internal BGP connections only,
some of them (marked with `<CODE>O</CODE>') are optional.
<P>
<DL>
<DT><CODE>
<A NAME="rta-bgp-path"></A> bgppath bgp_path/</CODE><DD><P>Sequence of AS numbers describing the AS path the packet will travel
through when forwarded according to the particular route. In case of
internal BGP it doesn't contain the number of the local AS.
<P>
<DT><CODE>
<A NAME="rta-bgp-local-pref"></A> int bgp_local_pref/ [I]</CODE><DD><P>Local preference value used for selection among multiple BGP routes (see
the selection rules above). It's used as an additional metric which is
propagated through the whole local AS.
<P>
<DT><CODE>
<A NAME="rta-bgp-med"></A> int bgp_med/ [O]</CODE><DD><P>The Multiple Exit Discriminator of the route is an optional attribute
which is used on external (inter-AS) links to convey to an adjacent AS
the optimal entry point into the local AS. The received attribute is
also propagated over internal BGP links. The attribute value is zeroed
when a route is exported to an external BGP instance to ensure that the
attribute received from a neighboring AS is not propagated to other
neighboring ASes. A new value might be set in the export filter of an
external BGP instance. See <A HREF="http://www.rfc-editor.org/info/rfc4451">RFC 4451</A> for further discussion of
BGP MED attribute.
<P>
<DT><CODE>
<A NAME="rta-bgp-origin"></A> enum bgp_origin/</CODE><DD><P>Origin of the route: either <CODE>ORIGIN_IGP</CODE> if the route has originated
in an interior routing protocol or <CODE>ORIGIN_EGP</CODE> if it's been imported
from the <CODE>EGP</CODE> protocol (nowadays it seems to be obsolete) or
<CODE>ORIGIN_INCOMPLETE</CODE> if the origin is unknown.
<P>
<DT><CODE>
<A NAME="rta-bgp-next-hop"></A> ip bgp_next_hop/</CODE><DD><P>Next hop to be used for forwarding of packets to this destination. On
internal BGP connections, it's an address of the originating router if
it's inside the local AS or a boundary router the packet will leave the
AS through if it's an exterior route, so each BGP speaker within the AS
has a chance to use the shortest interior path possible to this point.
<P>
<DT><CODE>
<A NAME="rta-bgp-atomic-aggr"></A> void bgp_atomic_aggr/ [O]</CODE><DD><P>This is an optional attribute which carries no value, but the sole
presence of which indicates that the route has been aggregated from
multiple routes by some router on the path from the originator.
<P>
<DT><CODE>
<A NAME="rta-bgp-community"></A> clist bgp_community/ [O]</CODE><DD><P>List of community values associated with the route. Each such value is a
pair (represented as a <CODE>pair</CODE> data type inside the filters) of 16-bit
integers, the first of them containing the number of the AS which
defines the community and the second one being a per-AS identifier.
There are lots of uses of the community mechanism, but generally they
are used to carry policy information like "don't export to USA peers".
As each AS can define its own routing policy, it also has a complete
freedom about which community attributes it defines and what will their
semantics be.
<P>
<DT><CODE>
<A NAME="rta-bgp-ext-community"></A> eclist bgp_ext_community/ [O]</CODE><DD><P>List of extended community values associated with the route. Extended
communities have similar usage as plain communities, but they have an
extended range (to allow 4B ASNs) and a nontrivial structure with a type
field. Individual community values are represented using an <CODE>ec</CODE> data
type inside the filters.
<P>
<DT><CODE>
<A NAME="rta-bgp-large-community"></A> lclist <CODE>bgp_large_community</CODE> [O]</CODE><DD><P>List of large community values associated with the route. Large BGP
communities is another variant of communities, but contrary to extended
communities they behave very much the same way as regular communities,
just larger -- they are uniform untyped triplets of 32bit numbers.
Individual community values are represented using an <CODE>lc</CODE> data type
inside the filters.
<P>
<DT><CODE>
<A NAME="rta-bgp-originator-id"></A> quad bgp_originator_id/ [I, O]</CODE><DD><P>This attribute is created by the route reflector when reflecting the
route and contains the router ID of the originator of the route in the
local AS.
<P>
<DT><CODE>
<A NAME="rta-bgp-cluster-list"></A> clist bgp_cluster_list/ [I, O]</CODE><DD><P>This attribute contains a list of cluster IDs of route reflectors. Each
route reflector prepends its cluster ID when reflecting the route.
</DL>
<P>
<H3><A NAME="bgp-exam"></A> Example</H3>

<P>
<HR>
<PRE>
protocol bgp {
        local as 65000;                      # Use a private AS number
        neighbor 198.51.100.130 as 64496;    # Our neighbor ...
        multihop;                            # ... which is connected indirectly
        export filter {                      # We use non-trivial export rules
                if source = RTS_STATIC then { # Export only static routes
                        # Assign our community
                        bgp_community.add((65000,64501));
                        # Artificially increase path length
                        # by advertising local AS number twice
                        if bgp_path ~ [= 65000 =] then
                                bgp_path.prepend(65000);
                        accept;
                }
                reject;
        };
        import all;
        source address 198.51.100.14;   # Use a non-standard source address
}
</PRE>
<HR>
<P>
<P>
<H2><A NAME="device"></A> <A NAME="ss6.4">6.4</A> <A HREF="bird.html#toc6.4">Device</A>
</H2>

<P>The Device protocol is not a real routing protocol. It doesn't generate any
routes and it only serves as a module for getting information about network
interfaces from the kernel.
<P>
<P>Except for very unusual circumstances, you probably should include this
protocol in the configuration since almost all other protocols require network
interfaces to be defined for them to work with.
<P>
<H3><A NAME="device-config"></A> Configuration</H3>

<P>
<DL>
<P>
<DT><CODE>
<A NAME="device-scan-time"></A> scan time <I>number</I></CODE><DD><P>Time in seconds between two scans of the network interface list. On
systems where we are notified about interface status changes
asynchronously (such as newer versions of Linux), we need to scan the
list only in order to avoid confusion by lost notification messages,
so the default time is set to a large value.
<P>
<DT><CODE>
<A NAME="device-primary"></A> primary [ "<I>mask</I>" ] <I>prefix</I></CODE><DD><P>If a network interface has more than one network address, BIRD has to
choose one of them as a primary one. By default, BIRD chooses the
lexicographically smallest address as the primary one.
<P>This option allows to specify which network address should be chosen as
a primary one. Network addresses that match <I>prefix</I> are preferred to
non-matching addresses. If more <CODE>primary</CODE> options are used, the first
one has the highest preference. If "<I>mask</I>" is specified, then such
<CODE>primary</CODE> option is relevant only to matching network interfaces.
<P>In all cases, an address marked by operating system as secondary cannot
be chosen as the primary one.
</DL>
<P>
<P>As the Device protocol doesn't generate any routes, it cannot have
any attributes. Example configuration looks like this:
<P>
<P>
<HR>
<PRE>
protocol device {
        scan time 10;           # Scan the interfaces often
        primary "eth0" 192.168.1.1;
        primary 192.168.0.0/16;
}
</PRE>
<HR>
<P>
<P>
<H2><A NAME="direct"></A> <A NAME="ss6.5">6.5</A> <A HREF="bird.html#toc6.5">Direct</A>
</H2>

<P>The Direct protocol is a simple generator of device routes for all the
directly connected networks according to the list of interfaces provided by the
kernel via the Device protocol.
<P>
<P>The question is whether it is a good idea to have such device routes in BIRD
routing table. OS kernel usually handles device routes for directly connected
networks by itself so we don't need (and don't want) to export these routes to
the kernel protocol. OSPF protocol creates device routes for its interfaces
itself and BGP protocol is usually used for exporting aggregate routes. Although
there are some use cases that use the direct protocol (like abusing eBGP as an
IGP routing protocol), in most cases it is not needed to have these device
routes in BIRD routing table and to use the direct protocol.
<P>
<P>There is one notable case when you definitely want to use the direct protocol
-- running BIRD on BSD systems. Having high priority device routes for directly
connected networks from the direct protocol protects kernel device routes from
being overwritten or removed by IGP routes during some transient network
conditions, because a lower priority IGP route for the same network is not
exported to the kernel routing table. This is an issue on BSD systems only, as
on Linux systems BIRD cannot change non-BIRD route in the kernel routing table.
<P>
<P>There are just few configuration options for the Direct protocol:
<P>
<P>
<DL>
<DT><CODE>
<A NAME="direct-iface"></A> interface <I>pattern</I> [, <I>...</I>]</CODE><DD><P>By default, the Direct protocol will generate device routes for all the
interfaces available. If you want to restrict it to some subset of
interfaces or addresses (e.g. if you're using multiple routing tables
for policy routing and some of the policy domains don't contain all
interfaces), just use this clause. See 
<A HREF="bird-3.html#proto-iface">interface</A>
common option for detailed description. The Direct protocol uses
extended interface clauses.
<P>
<DT><CODE>
<A NAME="direct-check-link"></A> check link <I>switch</I></CODE><DD><P>If enabled, a hardware link state (reported by OS) is taken into
consideration. Routes for directly connected networks are generated only
if link up is reported and they are withdrawn when link disappears
(e.g., an ethernet cable is unplugged). Default value is no.
</DL>
<P>
<P>Direct device routes don't contain any specific attributes.
<P>
<P>Example config might look like this:
<P>
<P>
<HR>
<PRE>
protocol direct {
        interface "-arc*", "*";         # Exclude the ARCnets
}
</PRE>
<HR>
<P>
<P>
<H2><A NAME="krt"></A> <A NAME="ss6.6">6.6</A> <A HREF="bird.html#toc6.6">Kernel</A>
</H2>

<P>The Kernel protocol is not a real routing protocol. Instead of communicating
with other routers in the network, it performs synchronization of BIRD's routing
tables with the OS kernel. Basically, it sends all routing table updates to the
kernel and from time to time it scans the kernel tables to see whether some
routes have disappeared (for example due to unnoticed up/down transition of an
interface) or whether an `alien' route has been added by someone else (depending
on the <CODE>learn</CODE> switch, such routes are either ignored or accepted to our
table).
<P>
<P>Unfortunately, there is one thing that makes the routing table synchronization
a bit more complicated. In the kernel routing table there are also device routes
for directly connected networks. These routes are usually managed by OS itself
(as a part of IP address configuration) and we don't want to touch that. They
are completely ignored during the scan of the kernel tables and also the export
of device routes from BIRD tables to kernel routing tables is restricted to
prevent accidental interference. This restriction can be disabled using
<CODE>device routes</CODE> switch.
<P>
<P>If your OS supports only a single routing table, you can configure only one
instance of the Kernel protocol. If it supports multiple tables (in order to
allow policy routing; such an OS is for example Linux), you can run as many
instances as you want, but each of them must be connected to a different BIRD
routing table and to a different kernel table.
<P>
<P>Because the kernel protocol is partially integrated with the connected
routing table, there are two limitations - it is not possible to connect more
kernel protocols to the same routing table and changing route destination
(gateway) in an export filter of a kernel protocol does not work. Both
limitations can be overcome using another routing table and the pipe protocol.
<P>
<H3><A NAME="krt-config"></A> Configuration</H3>

<P>
<DL>
<DT><CODE>
<A NAME="krt-persist"></A> persist <I>switch</I></CODE><DD><P>Tell BIRD to leave all its routes in the routing tables when it exits
(instead of cleaning them up).
<P>
<DT><CODE>
<A NAME="krt-scan-time"></A> scan time <I>number</I></CODE><DD><P>Time in seconds between two consecutive scans of the kernel routing
table.
<P>
<DT><CODE>
<A NAME="krt-learn"></A> learn <I>switch</I></CODE><DD><P>Enable learning of routes added to the kernel routing tables by other
routing daemons or by the system administrator. This is possible only on
systems which support identification of route authorship.
<P>
<DT><CODE>
<A NAME="krt-device-routes"></A> device routes <I>switch</I></CODE><DD><P>Enable export of device routes to the kernel routing table. By default,
such routes are rejected (with the exception of explicitly configured
device routes from the static protocol) regardless of the export filter
to protect device routes in kernel routing table (managed by OS itself)
from accidental overwriting or erasing.
<P>
<DT><CODE>
<A NAME="krt-kernel-table"></A> kernel table <I>number</I></CODE><DD><P>Select which kernel table should this particular instance of the Kernel
protocol work with. Available only on systems supporting multiple
routing tables.
<P>
<DT><CODE>
<A NAME="krt-metric"></A> metric <I>number</I></CODE><DD><P>(Linux)
Use specified value as a kernel metric (priority) for all routes sent to
the kernel. When multiple routes for the same network are in the kernel
routing table, the Linux kernel chooses one with lower metric. Also,
routes with different metrics do not clash with each other, therefore
using dedicated metric value is a reliable way to avoid overwriting
routes from other sources (e.g. kernel device routes). Metric 0 has a
special meaning of undefined metric, in which either OS default is used,
or per-route metric can be set using <CODE>krt_metric</CODE> attribute. Default:
0 (undefined).
<P>
<DT><CODE>
<A NAME="krt-graceful-restart"></A> graceful restart <I>switch</I></CODE><DD><P>Participate in graceful restart recovery. If this option is enabled and
a graceful restart recovery is active, the Kernel protocol will defer
synchronization of routing tables until the end of the recovery. Note
that import of kernel routes to BIRD is not affected.
<P>
<DT><CODE>
<A NAME="krt-merge-paths"></A> merge paths <I>switch</I> [limit <I>number</I>]</CODE><DD><P>Usually, only best routes are exported to the kernel protocol. With path
merging enabled, both best routes and equivalent non-best routes are
merged during export to generate one ECMP (equal-cost multipath) route
for each network. This is useful e.g. for BGP multipath. Note that best
routes are still pivotal for route export (responsible for most
properties of resulting ECMP routes), while exported non-best routes are
responsible just for additional multipath next hops. This option also
allows to specify a limit on maximal number of nexthops in one route. By
default, multipath merging is disabled. If enabled, default value of the
limit is 16.
</DL>
<P>
<H3><A NAME="krt-attr"></A> Attributes</H3>

<P>The Kernel protocol defines several attributes. These attributes are
translated to appropriate system (and OS-specific) route attributes. We support
these attributes:
<P>
<DL>
<DT><CODE>
<A NAME="rta-krt-source"></A> int krt_source/</CODE><DD><P>The original source of the imported kernel route. The value is
system-dependent. On Linux, it is a value of the protocol field of the
route. See /etc/iproute2/rt_protos for common values. On BSD, it is
based on STATIC and PROTOx flags. The attribute is read-only.
<P>
<DT><CODE>
<A NAME="rta-krt-metric"></A> int krt_metric/</CODE><DD><P>(Linux)
The kernel metric of the route. When multiple same routes are in a
kernel routing table, the Linux kernel chooses one with lower metric.
Note that preferred way to set kernel metric is to use protocol option
<CODE>metric</CODE>, unless per-route metric values are needed.
<P>
<DT><CODE>
<A NAME="rta-krt-prefsrc"></A> ip krt_prefsrc/</CODE><DD><P>(Linux)
The preferred source address. Used in source address selection for
outgoing packets. Has to be one of the IP addresses of the router.
<P>
<DT><CODE>
<A NAME="rta-krt-realm"></A> int krt_realm/</CODE><DD><P>(Linux)
The realm of the route. Can be used for traffic classification.
<P>
<DT><CODE>
<A NAME="rta-krt-scope"></A> int krt_scope/</CODE><DD><P>(Linux IPv4)
The scope of the route. Valid values are 0-254, although Linux kernel
may reject some values depending on route type and nexthop. It is
supposed to represent `indirectness' of the route, where nexthops of
routes are resolved through routes with a higher scope, but in current
kernels anything below <I>link</I> (253) is treated as <I>global</I> (0).
When not present, global scope is implied for all routes except device
routes, where link scope is used by default.
</DL>
<P>
<P>In Linux, there is also a plenty of obscure route attributes mostly focused
on tuning TCP performance of local connections. BIRD supports most of these
attributes, see Linux or iproute2 documentation for their meaning. Attributes
<CODE>krt_lock_*</CODE> and <CODE>krt_feature_*</CODE> have type bool, others have type int.
Supported attributes are:
<P><CODE>krt_mtu</CODE>, <CODE>krt_lock_mtu</CODE>, <CODE>krt_window</CODE>, <CODE>krt_lock_window</CODE>,
<CODE>krt_rtt</CODE>, <CODE>krt_lock_rtt</CODE>, <CODE>krt_rttvar</CODE>, <CODE>krt_lock_rttvar</CODE>,
<CODE>krt_sstresh</CODE>, <CODE>krt_lock_sstresh</CODE>, <CODE>krt_cwnd</CODE>, <CODE>krt_lock_cwnd</CODE>,
<CODE>krt_advmss</CODE>, <CODE>krt_lock_advmss</CODE>, <CODE>krt_reordering</CODE>, <CODE>krt_lock_reordering</CODE>,
<CODE>krt_hoplimit</CODE>, <CODE>krt_lock_hoplimit</CODE>, <CODE>krt_rto_min</CODE>, <CODE>krt_lock_rto_min</CODE>,
<CODE>krt_initcwnd</CODE>, <CODE>krt_initrwnd</CODE>, <CODE>krt_quickack</CODE>,
<CODE>krt_feature_ecn</CODE>, <CODE>krt_feature_allfrag</CODE>
<P>
<H3><A NAME="krt-exam"></A> Example</H3>

<P>A simple configuration can look this way:
<P>
<P>
<HR>
<PRE>
protocol kernel {
        export all;
}
</PRE>
<HR>
<P>
<P>Or for a system with two routing tables:
<P>
<P>
<HR>
<PRE>
protocol kernel {               # Primary routing table
        learn;                  # Learn alien routes from the kernel
        persist;                # Don't remove routes on bird shutdown
        scan time 10;           # Scan kernel routing table every 10 seconds
        import all;
        export all;
}

protocol kernel {               # Secondary routing table
        table auxtable;
        kernel table 100;
        export all;
}
</PRE>
<HR>
<P>
<P>
<H2><A NAME="ospf"></A> <A NAME="ss6.7">6.7</A> <A HREF="bird.html#toc6.7">OSPF</A>
</H2>

<H3><A NAME="ospf-intro"></A> Introduction</H3>

<P>Open Shortest Path First (OSPF) is a quite complex interior gateway
protocol. The current IPv4 version (OSPFv2) is defined in <A HREF="http://www.rfc-editor.org/info/rfc2328">RFC 2328</A> and
the current IPv6 version (OSPFv3) is defined in <A HREF="http://www.rfc-editor.org/info/rfc5340">RFC 5340</A> It's a link
state (a.k.a. shortest path first) protocol -- each router maintains a database
describing the autonomous system's topology. Each participating router has an
identical copy of the database and all routers run the same algorithm
calculating a shortest path tree with themselves as a root. OSPF chooses the
least cost path as the best path.
<P>
<P>In OSPF, the autonomous system can be split to several areas in order to
reduce the amount of resources consumed for exchanging the routing information
and to protect the other areas from incorrect routing data. Topology of the area
is hidden to the rest of the autonomous system.
<P>
<P>Another very important feature of OSPF is that it can keep routing information
from other protocols (like Static or BGP) in its link state database as external
routes. Each external route can be tagged by the advertising router, making it
possible to pass additional information between routers on the boundary of the
autonomous system.
<P>
<P>OSPF quickly detects topological changes in the autonomous system (such as
router interface failures) and calculates new loop-free routes after a short
period of convergence. Only a minimal amount of routing traffic is involved.
<P>
<P>Each router participating in OSPF routing periodically sends Hello messages
to all its interfaces. This allows neighbors to be discovered dynamically. Then
the neighbors exchange theirs parts of the link state database and keep it
identical by flooding updates. The flooding process is reliable and ensures that
each router detects all changes.
<P>
<H3><A NAME="ospf-config"></A> Configuration</H3>

<P>In the main part of configuration, there can be multiple definitions of OSPF
areas, each with a different id. These definitions includes many other switches
and multiple definitions of interfaces. Definition of interface may contain many
switches and constant definitions and list of neighbors on nonbroadcast
networks.
<P>
<HR>
<PRE>
protocol ospf &lt;name&gt; {
        rfc1583compat &lt;switch&gt;;
        instance id &lt;num&gt;;
        stub router &lt;switch&gt;;
        tick &lt;num&gt;;
        ecmp &lt;switch&gt; [limit &lt;num&gt;];
        merge external &lt;switch&gt;;
        area &lt;id&gt; {
                stub;
                nssa;
                summary &lt;switch&gt;;
                default nssa &lt;switch&gt;;
                default cost &lt;num&gt;;
                default cost2 &lt;num&gt;;
                translator &lt;switch&gt;;
                translator stability &lt;num&gt;;

                networks {
                        &lt;prefix&gt;;
                        &lt;prefix&gt; hidden;
                }
                external {
                        &lt;prefix&gt;;
                        &lt;prefix&gt; hidden;
                        &lt;prefix&gt; tag &lt;num&gt;;
                }
                stubnet &lt;prefix&gt;;
                stubnet &lt;prefix&gt; {
                        hidden &lt;switch&gt;;
                        summary &lt;switch&gt;;
                        cost &lt;num&gt;;
                }
                interface &lt;interface pattern&gt; [instance &lt;num&gt;] {
                        cost &lt;num&gt;;
                        stub &lt;switch&gt;;
                        hello &lt;num&gt;;
                        poll &lt;num&gt;;
                        retransmit &lt;num&gt;;
                        priority &lt;num&gt;;
                        wait &lt;num&gt;;
                        dead count &lt;num&gt;;
                        dead &lt;num&gt;;
                        secondary &lt;switch&gt;;
                        rx buffer [normal|large|&lt;num&gt;];
                        tx length &lt;num&gt;;
                        type [broadcast|bcast|pointopoint|ptp|
                                nonbroadcast|nbma|pointomultipoint|ptmp];
                        link lsa suppression &lt;switch&gt;;
                        strict nonbroadcast &lt;switch&gt;;
                        real broadcast &lt;switch&gt;;
                        ptp netmask &lt;switch&gt;;
                        check link &lt;switch&gt;;
                        bfd &lt;switch&gt;;
                        ecmp weight &lt;num&gt;;
                        ttl security [&lt;switch&gt;; | tx only]
                        tx class|dscp &lt;num&gt;;
                        tx priority &lt;num&gt;;
                        authentication none|simple|cryptographic;
                        password "&lt;text&gt;";
                        password "&lt;text&gt;" {
                                id &lt;num&gt;;
                                generate from "&lt;date&gt;";
                                generate to "&lt;date&gt;";
                                accept from "&lt;date&gt;";
                                accept to "&lt;date&gt;";
                                from "&lt;date&gt;";
                                to "&lt;date&gt;";
                                algorithm ( keyed md5 | keyed sha1 | hmac sha1 | hmac sha256 | hmac sha384 | hmac sha512 );
                        };
                        neighbors {
                                &lt;ip&gt;;
                                &lt;ip&gt; eligible;
                        };
                };
                virtual link &lt;id&gt; [instance &lt;num&gt;] {
                        hello &lt;num&gt;;
                        retransmit &lt;num&gt;;
                        wait &lt;num&gt;;
                        dead count &lt;num&gt;;
                        dead &lt;num&gt;;
                        authentication none|simple|cryptographic;
                        password "&lt;text&gt;";
                        password "&lt;text&gt;" {
                                id &lt;num&gt;;
                                generate from "&lt;date&gt;";
                                generate to "&lt;date&gt;";
                                accept from "&lt;date&gt;";
                                accept to "&lt;date&gt;";
                                from "&lt;date&gt;";
                                to "&lt;date&gt;";
                                algorithm ( keyed md5 | keyed sha1 | hmac sha1 | hmac sha256 | hmac sha384 | hmac sha512 );
                        };
                };
        };
}
</PRE>
<HR>
<P>
<DL>
<DT><CODE>
<A NAME="ospf-rfc1583compat"></A> rfc1583compat <I>switch</I></CODE><DD><P>This option controls compatibility of routing table calculation with
<A HREF="http://www.rfc-editor.org/info/rfc1583">RFC 1583</A>. Default value is no.
<P>
<DT><CODE>
<A NAME="ospf-instance-id"></A> instance id <I>num</I></CODE><DD><P>When multiple OSPF protocol instances are active on the same links, they
should use different instance IDs to distinguish their packets. Although
it could be done on per-interface basis, it is often preferred to set
one instance ID to whole OSPF domain/topology (e.g., when multiple
instances are used to represent separate logical topologies on the same
physical network). This option specifies the default instance ID for all
interfaces of the OSPF instance. Note that this option, if used, must
precede interface definitions. Default value is 0.
<P>
<DT><CODE>
<A NAME="ospf-stub-router"></A> stub router <I>switch</I></CODE><DD><P>This option configures the router to be a stub router, i.e., a router
that participates in the OSPF topology but does not allow transit
traffic. In OSPFv2, this is implemented by advertising maximum metric
for outgoing links. In OSPFv3, the stub router behavior is announced by
clearing the R-bit in the router LSA. See <A HREF="http://www.rfc-editor.org/info/rfc6987">RFC 6987</A> for details.
Default value is no.
<P>
<DT><CODE>
<A NAME="ospf-tick"></A> tick <I>num</I></CODE><DD><P>The routing table calculation and clean-up of areas' databases is not
performed when a single link state change arrives. To lower the CPU
utilization, it's processed later at periodical intervals of <I>num</I>
seconds. The default value is 1.
<P>
<DT><CODE>
<A NAME="ospf-ecmp"></A> ecmp <I>switch</I> [limit <I>number</I>]</CODE><DD><P>This option specifies whether OSPF is allowed to generate ECMP
(equal-cost multipath) routes. Such routes are used when there are
several directions to the destination, each with the same (computed)
cost. This option also allows to specify a limit on maximum number of
nexthops in one route. By default, ECMP is disabled. If enabled,
default value of the limit is 16.
<P>
<DT><CODE>
<A NAME="ospf-merge-external"></A> merge external <I>switch</I></CODE><DD><P>This option specifies whether OSPF should merge external routes from
different routers/LSAs for the same destination. When enabled together
with <CODE>ecmp</CODE>, equal-cost external routes will be combined to multipath
routes in the same way as regular routes. When disabled, external routes
from different LSAs are treated as separate even if they represents the
same destination. Default value is no.
<P>
<DT><CODE>
<A NAME="ospf-area"></A> area <I>id</I></CODE><DD><P>This defines an OSPF area with given area ID (an integer or an IPv4
address, similarly to a router ID). The most important area is the
backbone (ID 0) to which every other area must be connected.
<P>
<DT><CODE>
<A NAME="ospf-stub"></A> stub</CODE><DD><P>This option configures the area to be a stub area. External routes are
not flooded into stub areas. Also summary LSAs can be limited in stub
areas (see option <CODE>summary</CODE>). By default, the area is not a stub
area.
<P>
<DT><CODE>
<A NAME="ospf-nssa"></A> nssa</CODE><DD><P>This option configures the area to be a NSSA (Not-So-Stubby Area). NSSA
is a variant of a stub area which allows a limited way of external route
propagation. Global external routes are not propagated into a NSSA, but
an external route can be imported into NSSA as a (area-wide) NSSA-LSA
(and possibly translated and/or aggregated on area boundary). By
default, the area is not NSSA.
<P>
<DT><CODE>
<A NAME="ospf-summary"></A> summary <I>switch</I></CODE><DD><P>This option controls propagation of summary LSAs into stub or NSSA
areas. If enabled, summary LSAs are propagated as usual, otherwise just
the default summary route (0.0.0.0/0) is propagated (this is sometimes
called totally stubby area). If a stub area has more area boundary
routers, propagating summary LSAs could lead to more efficient routing
at the cost of larger link state database. Default value is no.
<P>
<DT><CODE>
<A NAME="ospf-default-nssa"></A> default nssa <I>switch</I></CODE><DD><P>When <CODE>summary</CODE> option is enabled, default summary route is no longer
propagated to the NSSA. In that case, this option allows to originate
default route as NSSA-LSA to the NSSA. Default value is no.
<P>
<DT><CODE>
<A NAME="ospf-default-cost"></A> default cost <I>num</I></CODE><DD><P>This option controls the cost of a default route propagated to stub and
NSSA areas. Default value is 1000.
<P>
<DT><CODE>
<A NAME="ospf-default-cost2"></A> default cost2 <I>num</I></CODE><DD><P>When a default route is originated as NSSA-LSA, its cost can use either
type 1 or type 2 metric. This option allows to specify the cost of a
default route in type 2 metric. By default, type 1 metric (option
<CODE>default cost</CODE>) is used.
<P>
<DT><CODE>
<A NAME="ospf-translator"></A> translator <I>switch</I></CODE><DD><P>This option controls translation of NSSA-LSAs into external LSAs. By
default, one translator per NSSA is automatically elected from area
boundary routers. If enabled, this area boundary router would
unconditionally translate all NSSA-LSAs regardless of translator
election. Default value is no.
<P>
<DT><CODE>
<A NAME="ospf-translator-stability"></A> translator stability <I>num</I></CODE><DD><P>This option controls the translator stability interval (in seconds).
When the new translator is elected, the old one keeps translating until
the interval is over. Default value is 40.
<P>
<DT><CODE>
<A NAME="ospf-networks"></A> networks { <I>set</I> }</CODE><DD><P>Definition of area IP ranges. This is used in summary LSA origination.
Hidden networks are not propagated into other areas.
<P>
<DT><CODE>
<A NAME="ospf-external"></A> external { <I>set</I> }</CODE><DD><P>Definition of external area IP ranges for NSSAs. This is used for
NSSA-LSA translation. Hidden networks are not translated into external
LSAs. Networks can have configured route tag.
<P>
<DT><CODE>
<A NAME="ospf-stubnet"></A> stubnet <I>prefix</I> { <I>options</I> }</CODE><DD><P>Stub networks are networks that are not transit networks between OSPF
routers. They are also propagated through an OSPF area as a part of a
link state database. By default, BIRD generates a stub network record
for each primary network address on each OSPF interface that does not
have any OSPF neighbors, and also for each non-primary network address
on each OSPF interface. This option allows to alter a set of stub
networks propagated by this router.
<P>Each instance of this option adds a stub network with given network
prefix to the set of propagated stub network, unless option <CODE>hidden</CODE>
is used. It also suppresses default stub networks for given network
prefix. When option <CODE>summary</CODE> is used, also default stub networks
that are subnetworks of given stub network are suppressed. This might be
used, for example, to aggregate generated stub networks.
<P>
<DT><CODE>
<A NAME="ospf-iface"></A> interface <I>pattern</I> [instance <I>num</I>]</CODE><DD><P>Defines that the specified interfaces belong to the area being defined.
See 
<A HREF="bird-3.html#proto-iface">interface</A> common option for detailed
description. In OSPFv2, extended interface clauses are used, because
each network prefix is handled as a separate virtual interface.
<P>You can specify alternative instance ID for the interface definition,
therefore it is possible to have several instances of that interface
with different options or even in different areas. For OSPFv2, instance
ID support is an extension (<A HREF="http://www.rfc-editor.org/info/rfc6549">RFC 6549</A>) and is supposed to be set
per-protocol. For OSPFv3, it is an integral feature.
<P>
<DT><CODE>
<A NAME="ospf-virtual-link"></A> virtual link <I>id</I> [instance <I>num</I>]</CODE><DD><P>Virtual link to router with the router id. Virtual link acts as a
point-to-point interface belonging to backbone. The actual area is used
as a transport area. This item cannot be in the backbone. Like with
<CODE>interface</CODE> option, you could also use several virtual links to one
destination with different instance IDs.
<P>
<DT><CODE>
<A NAME="ospf-cost"></A> cost <I>num</I></CODE><DD><P>Specifies output cost (metric) of an interface. Default value is 10.
<P>
<DT><CODE>
<A NAME="ospf-stub-iface"></A> stub <I>switch</I></CODE><DD><P>If set to interface it does not listen to any packet and does not send
any hello. Default value is no.
<P>
<DT><CODE>
<A NAME="ospf-hello"></A> hello <I>num</I></CODE><DD><P>Specifies interval in seconds between sending of Hello messages. Beware,
all routers on the same network need to have the same hello interval.
Default value is 10.
<P>
<DT><CODE>
<A NAME="ospf-poll"></A> poll <I>num</I></CODE><DD><P>Specifies interval in seconds between sending of Hello messages for some
neighbors on NBMA network. Default value is 20.
<P>
<DT><CODE>
<A NAME="ospf-retransmit"></A> retransmit <I>num</I></CODE><DD><P>Specifies interval in seconds between retransmissions of unacknowledged
updates. Default value is 5.
<P>
<DT><CODE>
<A NAME="ospf-priority"></A> priority <I>num</I></CODE><DD><P>On every multiple access network (e.g., the Ethernet) Designated Router
and Backup Designated router are elected. These routers have some special
functions in the flooding process. Higher priority increases preferences
in this election. Routers with priority 0 are not eligible. Default
value is 1.
<P>
<DT><CODE>
<A NAME="ospf-wait"></A> wait <I>num</I></CODE><DD><P>After start, router waits for the specified number of seconds between
starting election and building adjacency. Default value is 4*<I>hello</I>.
<P>
<DT><CODE>
<A NAME="ospf-dead-count"></A> dead count <I>num</I></CODE><DD><P>When the router does not receive any messages from a neighbor in
<I>dead count</I>*<I>hello</I> seconds, it will consider the neighbor down.
<P>
<DT><CODE>
<A NAME="ospf-dead"></A> dead <I>num</I></CODE><DD><P>When the router does not receive any messages from a neighbor in
<I>dead</I> seconds, it will consider the neighbor down. If both directives
<CODE>dead count</CODE> and <CODE>dead</CODE> are used, <CODE>dead</CODE> has precedence.
<P>
<DT><CODE>
<A NAME="ospf-secondary"></A> secondary <I>switch</I></CODE><DD><P>On BSD systems, older versions of BIRD supported OSPFv2 only for the
primary IP address of an interface, other IP ranges on the interface
were handled as stub networks. Since v1.4.1, regular operation on
secondary IP addresses is supported, but disabled by default for
compatibility. This option allows to enable it. The option is a
transitional measure, will be removed in the next major release as the
behavior will be changed. On Linux systems, the option is irrelevant, as
operation on non-primary addresses is already the regular behavior.
<P>
<DT><CODE>
<A NAME="ospf-rx-buffer"></A> rx buffer <I>num</I></CODE><DD><P>This option allows to specify the size of buffers used for packet
processing. The buffer size should be bigger than maximal size of any
packets. By default, buffers are dynamically resized as needed, but a
fixed value could be specified. Value <CODE>large</CODE> means maximal allowed
packet size - 65535.
<P>
<DT><CODE>
<A NAME="ospf-tx-length"></A> tx length <I>num</I></CODE><DD><P>Transmitted OSPF messages that contain large amount of information are
segmented to separate OSPF packets to avoid IP fragmentation. This
option specifies the soft ceiling for the length of generated OSPF
packets. Default value is the MTU of the network interface. Note that
larger OSPF packets may still be generated if underlying OSPF messages
cannot be splitted (e.g. when one large LSA is propagated).
<P>
<DT><CODE>
<A NAME="ospf-type-bcast"></A> type broadcast|bcast</CODE><DD><P>BIRD detects a type of a connected network automatically, but sometimes
it's convenient to force use of a different type manually. On broadcast
networks (like ethernet), flooding and Hello messages are sent using
multicasts (a single packet for all the neighbors). A designated router
is elected and it is responsible for synchronizing the link-state
databases and originating network LSAs. This network type cannot be used
on physically NBMA networks and on unnumbered networks (networks without
proper IP prefix).
<P>
<DT><CODE>
<A NAME="ospf-type-ptp"></A> type pointopoint|ptp</CODE><DD><P>Point-to-point networks connect just 2 routers together. No election is
performed and no network LSA is originated, which makes it simpler and
faster to establish. This network type is useful not only for physically
PtP ifaces (like PPP or tunnels), but also for broadcast networks used
as PtP links. This network type cannot be used on physically NBMA
networks.
<P>
<DT><CODE>
<A NAME="ospf-type-nbma"></A> type nonbroadcast|nbma</CODE><DD><P>On NBMA networks, the packets are sent to each neighbor separately
because of lack of multicast capabilities. Like on broadcast networks,
a designated router is elected, which plays a central role in propagation
of LSAs. This network type cannot be used on unnumbered networks.
<P>
<DT><CODE>
<A NAME="ospf-type-ptmp"></A> type pointomultipoint|ptmp</CODE><DD><P>This is another network type designed to handle NBMA networks. In this
case the NBMA network is treated as a collection of PtP links. This is
useful if not every pair of routers on the NBMA network has direct
communication, or if the NBMA network is used as an (possibly
unnumbered) PtP link.
<P>
<DT><CODE>
<A NAME="ospf-link-lsa-suppression"></A> link lsa suppression <I>switch</I></CODE><DD><P>In OSPFv3, link LSAs are generated for each link, announcing link-local
IPv6 address of the router to its local neighbors. These are useless on
PtP or PtMP networks and this option allows to suppress the link LSA
origination for such interfaces. The option is ignored on other than PtP
or PtMP interfaces. Default value is no.
<P>
<DT><CODE>
<A NAME="ospf-strict-nonbroadcast"></A> strict nonbroadcast <I>switch</I></CODE><DD><P>If set, don't send hello to any undefined neighbor. This switch is
ignored on other than NBMA or PtMP interfaces. Default value is no.
<P>
<DT><CODE>
<A NAME="ospf-real-broadcast"></A> real broadcast <I>switch</I></CODE><DD><P>In <CODE>type broadcast</CODE> or <CODE>type ptp</CODE> network configuration, OSPF
packets are sent as IP multicast packets. This option changes the
behavior to using old-fashioned IP broadcast packets. This may be useful
as a workaround if IP multicast for some reason does not work or does
not work reliably. This is a non-standard option and probably is not
interoperable with other OSPF implementations. Default value is no.
<P>
<DT><CODE>
<A NAME="ospf-ptp-netmask"></A> ptp netmask <I>switch</I></CODE><DD><P>In <CODE>type ptp</CODE> network configurations, OSPFv2 implementations should
ignore received netmask field in hello packets and should send hello
packets with zero netmask field on unnumbered PtP links. But some OSPFv2
implementations perform netmask checking even for PtP links. This option
specifies whether real netmask will be used in hello packets on <CODE>type
ptp</CODE> interfaces. You should ignore this option unless you meet some
compatibility problems related to this issue. Default value is no for
unnumbered PtP links, yes otherwise.
<P>
<DT><CODE>
<A NAME="ospf-check-link"></A> check link <I>switch</I></CODE><DD><P>If set, a hardware link state (reported by OS) is taken into consideration.
When a link disappears (e.g. an ethernet cable is unplugged), neighbors
are immediately considered unreachable and only the address of the iface
(instead of whole network prefix) is propagated. It is possible that
some hardware drivers or platforms do not implement this feature.
Default value is no.
<P>
<DT><CODE>
<A NAME="ospf-bfd"></A> bfd <I>switch</I></CODE><DD><P>OSPF could use BFD protocol as an advisory mechanism for neighbor
liveness and failure detection. If enabled, BIRD setups a BFD session
for each OSPF neighbor and tracks its liveness by it. This has an
advantage of an order of magnitude lower detection times in case of
failure. Note that BFD protocol also has to be configured, see
<A HREF="#bfd">BFD</A> section for details. Default value is no.
<P>
<DT><CODE>
<A NAME="ospf-ttl-security"></A> ttl security [<I>switch</I> | tx only]</CODE><DD><P>TTL security is a feature that protects routing protocols from remote
spoofed packets by using TTL 255 instead of TTL 1 for protocol packets
destined to neighbors. Because TTL is decremented when packets are
forwarded, it is non-trivial to spoof packets with TTL 255 from remote
locations. Note that this option would interfere with OSPF virtual
links.
<P>If this option is enabled, the router will send OSPF packets with TTL
255 and drop received packets with TTL less than 255. If this option si
set to <CODE>tx only</CODE>, TTL 255 is used for sent packets, but is not
checked for received packets. Default value is no.
<P>
<DT><CODE>
<A NAME="ospf-tx-class"></A> tx class|dscp|priority <I>num</I></CODE><DD><P>These options specify the ToS/DiffServ/Traffic class/Priority of the
outgoing OSPF packets. See 
<A HREF="bird-3.html#proto-tx-class">tx class</A> common
option for detailed description.
<P>
<DT><CODE>
<A NAME="ospf-ecmp-weight"></A> ecmp weight <I>num</I></CODE><DD><P>When ECMP (multipath) routes are allowed, this value specifies a
relative weight used for nexthops going through the iface. Allowed
values are 1-256. Default value is 1.
<P>
<DT><CODE>
<A NAME="ospf-auth-none"></A> authentication none</CODE><DD><P>No passwords are sent in OSPF packets. This is the default value.
<P>
<DT><CODE>
<A NAME="ospf-auth-simple"></A> authentication simple</CODE><DD><P>Every packet carries 8 bytes of password. Received packets lacking this
password are ignored. This authentication mechanism is very weak.
This option is not available in OSPFv3.
<P>
<DT><CODE>
<A NAME="ospf-auth-cryptographic"></A> authentication cryptographic</CODE><DD><P>An authentication code is appended to every packet. The specific
cryptographic algorithm is selected by option <CODE>algorithm</CODE> for each
key. The default cryptographic algorithm for OSPFv2 keys is Keyed-MD5
and for OSPFv3 keys is HMAC-SHA-256. Passwords are not sent open via
network, so this mechanism is quite secure. Packets can still be read by
an attacker.
<P>
<DT><CODE>
<A NAME="ospf-pass"></A> password "<I>text</I>"</CODE><DD><P>Specifies a password used for authentication. See
<A HREF="bird-3.html#proto-pass">password</A> common option for detailed
description.
<P>
<DT><CODE>
<A NAME="ospf-neighbors"></A> neighbors { <I>set</I> } </CODE><DD><P>A set of neighbors to which Hello messages on NBMA or PtMP networks are
to be sent. For NBMA networks, some of them could be marked as eligible.
In OSPFv3, link-local addresses should be used, using global ones is
possible, but it is nonstandard and might be problematic. And definitely,
link-local and global addresses should not be mixed.
</DL>
<P>
<H3><A NAME="ospf-attr"></A> Attributes</H3>

<P>OSPF defines four route attributes. Each internal route has a <CODE>metric</CODE>.
<P>
<P>Metric is ranging from 1 to infinity (65535). External routes use
<CODE>metric type 1</CODE> or <CODE>metric type 2</CODE>. A <CODE>metric of type 1</CODE> is comparable
with internal <CODE>metric</CODE>, a <CODE>metric of type 2</CODE> is always longer than any
<CODE>metric of type 1</CODE> or any <CODE>internal metric</CODE>. <CODE>Internal metric</CODE> or
<CODE>metric of type 1</CODE> is stored in attribute <CODE>ospf_metric1</CODE>, <CODE>metric type
2</CODE> is stored in attribute <CODE>ospf_metric2</CODE>. If you specify both metrics only
metric1 is used.
<P>
<P>Each external route can also carry attribute <CODE>ospf_tag</CODE> which is a 32-bit
integer which is used when exporting routes to other protocols; otherwise, it
doesn't affect routing inside the OSPF domain at all. The fourth attribute
<CODE>ospf_router_id</CODE> is a router ID of the router advertising that route /
network. This attribute is read-only. Default is <CODE>ospf_metric2 = 10000</CODE> and
<CODE>ospf_tag = 0</CODE>.
<P>
<H3><A NAME="ospf-exam"></A> Example</H3>

<P>
<HR>
<PRE>
protocol ospf MyOSPF {
        rfc1583compat yes;
        tick 2;
        export filter {
                if source = RTS_BGP then {
                        ospf_metric1 = 100;
                        accept;
                }
                reject;
        };
        area 0.0.0.0 {
                interface "eth*" {
                        cost 11;
                        hello 15;
                        priority 100;
                        retransmit 7;
                        authentication simple;
                        password "aaa";
                };
                interface "ppp*" {
                        cost 100;
                        authentication cryptographic;
                        password "abc" {
                                id 1;
                                generate to "22-04-2003 11:00:06";
                                accept from "17-01-2001 12:01:05";
                                algorithm hmac sha384;
                        };
                        password "def" {
                                id 2;
                                generate to "22-07-2005 17:03:21";
                                accept from "22-02-2001 11:34:06";
                                algorithm hmac sha512;
                        };
                };
                interface "arc0" {
                        cost 10;
                        stub yes;
                };
                interface "arc1";
        };
        area 120 {
                stub yes;
                networks {
                        172.16.1.0/24;
                        172.16.2.0/24 hidden;
                }
                interface "-arc0" , "arc*" {
                        type nonbroadcast;
                        authentication none;
                        strict nonbroadcast yes;
                        wait 120;
                        poll 40;
                        dead count 8;
                        neighbors {
                                192.168.120.1 eligible;
                                192.168.120.2;
                                192.168.120.10;
                        };
                };
        };
}
</PRE>
<HR>
<P>
<P>
<H2><A NAME="pipe"></A> <A NAME="ss6.8">6.8</A> <A HREF="bird.html#toc6.8">Pipe</A>
</H2>

<H3><A NAME="pipe-intro"></A> Introduction</H3>

<P>The Pipe protocol serves as a link between two routing tables, allowing
routes to be passed from a table declared as primary (i.e., the one the pipe is
connected to using the <CODE>table</CODE> configuration keyword) to the secondary one
(declared using <CODE>peer table</CODE>) and vice versa, depending on what's allowed by
the filters. Export filters control export of routes from the primary table to
the secondary one, import filters control the opposite direction.
<P>
<P>The Pipe protocol may work in the transparent mode mode or in the opaque
mode. In the transparent mode, the Pipe protocol retransmits all routes from
one table to the other table, retaining their original source and attributes.
If import and export filters are set to accept, then both tables would have
the same content. The transparent mode is the default mode.
<P>
<P>In the opaque mode, the Pipe protocol retransmits optimal route from one
table to the other table in a similar way like other protocols send and receive
routes. Retransmitted route will have the source set to the Pipe protocol, which
may limit access to protocol specific route attributes. This mode is mainly for
compatibility, it is not suggested for new configs. The mode can be changed by
<CODE>mode</CODE> option.
<P>
<P>The primary use of multiple routing tables and the Pipe protocol is for
policy routing, where handling of a single packet doesn't depend only on its
destination address, but also on its source address, source interface, protocol
type and other similar parameters. In many systems (Linux being a good example),
the kernel allows to enforce routing policies by defining routing rules which
choose one of several routing tables to be used for a packet according to its
parameters. Setting of these rules is outside the scope of BIRD's work (on
Linux, you can use the <CODE>ip</CODE> command), but you can create several routing
tables in BIRD, connect them to the kernel ones, use filters to control which
routes appear in which tables and also you can employ the Pipe protocol for
exporting a selected subset of one table to another one.
<P>
<H3><A NAME="pipe-config"></A> Configuration</H3>

<P>
<DL>
<DT><CODE>
<A NAME="pipe-peer-table"></A> peer table <I>table</I></CODE><DD><P>Defines secondary routing table to connect to. The primary one is
selected by the <CODE>table</CODE> keyword.
<P>
<DT><CODE>
<A NAME="pipe-mode"></A> mode opaque|transparent</CODE><DD><P>Specifies the mode for the pipe to work in. Default is transparent.
</DL>
<P>
<H3><A NAME="pipe-attr"></A> Attributes</H3>

<P>The Pipe protocol doesn't define any route attributes.
<P>
<H3><A NAME="pipe-exam"></A> Example</H3>

<P>Let's consider a router which serves as a boundary router of two different
autonomous systems, each of them connected to a subset of interfaces of the
router, having its own exterior connectivity and wishing to use the other AS as
a backup connectivity in case of outage of its own exterior line.
<P>
<P>Probably the simplest solution to this situation is to use two routing tables
(we'll call them <CODE>as1</CODE> and <CODE>as2</CODE>) and set up kernel routing rules, so that
packets having arrived from interfaces belonging to the first AS will be routed
according to <CODE>as1</CODE> and similarly for the second AS. Thus we have split our
router to two logical routers, each one acting on its own routing table, having
its own routing protocols on its own interfaces. In order to use the other AS's
routes for backup purposes, we can pass the routes between the tables through a
Pipe protocol while decreasing their preferences and correcting their BGP paths
to reflect the AS boundary crossing.
<P>
<HR>
<PRE>
table as1;                              # Define the tables
table as2;

protocol kernel kern1 {                 # Synchronize them with the kernel
        table as1;
        kernel table 1;
}

protocol kernel kern2 {
        table as2;
        kernel table 2;
}

protocol bgp bgp1 {                     # The outside connections
        table as1;
        local as 1;
        neighbor 192.168.0.1 as 1001;
        export all;
        import all;
}

protocol bgp bgp2 {
        table as2;
        local as 2;
        neighbor 10.0.0.1 as 1002;
        export all;
        import all;
}

protocol pipe {                         # The Pipe
        table as1;
        peer table as2;
        export filter {
                if net ~ [ 1.0.0.0/8+] then {   # Only AS1 networks
                        if preference>10 then preference = preference-10;
                        if source=RTS_BGP then bgp_path.prepend(1);
                        accept;
                }
                reject;
        };
        import filter {
                if net ~ [ 2.0.0.0/8+] then {   # Only AS2 networks
                        if preference>10 then preference = preference-10;
                        if source=RTS_BGP then bgp_path.prepend(2);
                        accept;
                }
                reject;
        };
}
</PRE>
<HR>
<P>
<P>
<H2><A NAME="radv"></A> <A NAME="ss6.9">6.9</A> <A HREF="bird.html#toc6.9">RAdv</A>
</H2>

<H3><A NAME="radv-intro"></A> Introduction</H3>

<P>The RAdv protocol is an implementation of Router Advertisements, which are
used in the IPv6 stateless autoconfiguration. IPv6 routers send (in irregular
time intervals or as an answer to a request) advertisement packets to connected
networks. These packets contain basic information about a local network (e.g. a
list of network prefixes), which allows network hosts to autoconfigure network
addresses and choose a default route. BIRD implements router behavior as defined
in <A HREF="http://www.rfc-editor.org/info/rfc4861">RFC 4861</A> and also the DNS extensions from <A HREF="http://www.rfc-editor.org/info/rfc6106">RFC 6106</A>.
<P>
<H3><A NAME="radv-config"></A> Configuration</H3>

<P>There are several classes of definitions in RAdv configuration -- interface
definitions, prefix definitions and DNS definitions:
<P>
<DL>
<DT><CODE>
<A NAME="radv-iface"></A> interface <I>pattern</I> [, <I>...</I>] { <I>options</I> }</CODE><DD><P>Interface definitions specify a set of interfaces on which the
protocol is activated and contain interface specific options.
See 
<A HREF="bird-3.html#proto-iface">interface</A> common options for
detailed description.
<P>
<DT><CODE>
<A NAME="radv-prefix"></A> prefix <I>prefix</I> { <I>options</I> }</CODE><DD><P>Prefix definitions allow to modify a list of advertised prefixes. By
default, the advertised prefixes are the same as the network prefixes
assigned to the interface. For each network prefix, the matching prefix
definition is found and its options are used. If no matching prefix
definition is found, the prefix is used with default options.
<P>Prefix definitions can be either global or interface-specific. The
second ones are part of interface options. The prefix definition
matching is done in the first-match style, when interface-specific
definitions are processed before global definitions. As expected, the
prefix definition is matching if the network prefix is a subnet of the
prefix in prefix definition.
<P>
<DT><CODE>
<A NAME="radv-rdnss"></A> rdnss { <I>options</I> }</CODE><DD><P>RDNSS definitions allow to specify a list of advertised recursive DNS
servers together with their options. As options are seldom necessary,
there is also a short variant <CODE>rdnss <I>address</I></CODE> that just
specifies one DNS server. Multiple definitions are cumulative. RDNSS
definitions may also be interface-specific when used inside interface
options. By default, interface uses both global and interface-specific
options, but that can be changed by <CODE>rdnss local</CODE> option.
dsc-iface
<DT><CODE>
<A NAME="radv-dnssl"></A> dnssl { <I>options</I> }</CODE><DD><P>DNSSL definitions allow to specify a list of advertised DNS search
domains together with their options. Like <CODE>rdnss</CODE> above, multiple
definitions are cumulative, they can be used also as interface-specific
options and there is a short variant <CODE>dnssl <I>domain</I></CODE> that just
specifies one DNS search domain.
<P>
<DT><CODE>
<A NAME="radv-trigger"></A> trigger <I>prefix</I></CODE><DD><P>RAdv protocol could be configured to change its behavior based on
availability of routes. When this option is used, the protocol waits in
suppressed state until a <I>trigger route</I> (for the specified network)
is exported to the protocol, the protocol also returnsd to suppressed
state if the <I>trigger route</I> disappears. Note that route export
depends on specified export filter, as usual. This option could be used,
e.g., for handling failover in multihoming scenarios.
<P>During suppressed state, router advertisements are generated, but with
some fields zeroed. Exact behavior depends on which fields are zeroed,
this can be configured by <CODE>sensitive</CODE> option for appropriate
fields. By default, just <CODE>default lifetime</CODE> (also called <CODE>router
lifetime</CODE>) is zeroed, which means hosts cannot use the router as a
default router. <CODE>preferred lifetime</CODE> and <CODE>valid lifetime</CODE> could
also be configured as <CODE>sensitive</CODE> for a prefix, which would cause
autoconfigured IPs to be deprecated or even removed.
</DL>
<P>
<P>Interface specific options:
<P>
<DL>
<DT><CODE>
<A NAME="radv-iface-max-ra-interval"></A> max ra interval <I>expr</I></CODE><DD><P>Unsolicited router advertisements are sent in irregular time intervals.
This option specifies the maximum length of these intervals, in seconds.
Valid values are 4-1800. Default: 600
<P>
<DT><CODE>
<A NAME="radv-iface-min-ra-interval"></A> min ra interval <I>expr</I></CODE><DD><P>This option specifies the minimum length of that intervals, in seconds.
Must be at least 3 and at most 3/4 * <CODE>max ra interval</CODE>. Default:
about 1/3 * <CODE>max ra interval</CODE>.
<P>
<DT><CODE>
<A NAME="radv-iface-min-delay"></A> min delay <I>expr</I></CODE><DD><P>The minimum delay between two consecutive router advertisements, in
seconds. Default: 3
<P>
<DT><CODE>
<A NAME="radv-iface-managed"></A> managed <I>switch</I></CODE><DD><P>This option specifies whether hosts should use DHCPv6 for IP address
configuration. Default: no
<P>
<DT><CODE>
<A NAME="radv-iface-other-config"></A> other config <I>switch</I></CODE><DD><P>This option specifies whether hosts should use DHCPv6 to receive other
configuration information. Default: no
<P>
<DT><CODE>
<A NAME="radv-iface-link-mtu"></A> link mtu <I>expr</I></CODE><DD><P>This option specifies which value of MTU should be used by hosts. 0
means unspecified. Default: 0
<P>
<DT><CODE>
<A NAME="radv-iface-reachable-time"></A> reachable time <I>expr</I></CODE><DD><P>This option specifies the time (in milliseconds) how long hosts should
assume a neighbor is reachable (from the last confirmation). Maximum is
3600000, 0 means unspecified. Default 0.
<P>
<DT><CODE>
<A NAME="radv-iface-retrans-timer"></A> retrans timer <I>expr</I></CODE><DD><P>This option specifies the time (in milliseconds) how long hosts should
wait before retransmitting Neighbor Solicitation messages. 0 means
unspecified. Default 0.
<P>
<DT><CODE>
<A NAME="radv-iface-current-hop-limit"></A> current hop limit <I>expr</I></CODE><DD><P>This option specifies which value of Hop Limit should be used by
hosts. Valid values are 0-255, 0 means unspecified. Default: 64
<P>
<DT><CODE>
<A NAME="radv-iface-default-lifetime"></A> default lifetime <I>expr</I> [sensitive <I>switch</I>]</CODE><DD><P>This option specifies the time (in seconds) how long (after the receipt
of RA) hosts may use the router as a default router. 0 means do not use
as a default router. For <CODE>sensitive</CODE> option, see 
<A HREF="#radv-trigger">trigger</A>.
Default: 3 * <CODE>max ra       interval</CODE>, <CODE>sensitive</CODE> yes.
<P>
<DT><CODE>
<A NAME="radv-iface-default-preference-low"></A> default preference low|medium|high</CODE><DD><P>This option specifies the Default Router Preference value to advertise
to hosts. Default: medium.
<P>
<DT><CODE>
<A NAME="radv-iface-rdnss-local"></A> rdnss local <I>switch</I></CODE><DD><P>Use only local (interface-specific) RDNSS definitions for this
interface. Otherwise, both global and local definitions are used. Could
also be used to disable RDNSS for given interface if no local definitons
are specified. Default: no.
<P>
<DT><CODE>
<A NAME="radv-iface-dnssl-local"></A> dnssl local <I>switch</I></CODE><DD><P>Use only local DNSSL definitions for this interface. See <CODE>rdnss local</CODE>
option above. Default: no.
</DL>
<P>
<P>
<P>Prefix specific options
<P>
<DL>
<DT><CODE>
<A NAME="radv-prefix-skip"></A> skip <I>switch</I></CODE><DD><P>This option allows to specify that given prefix should not be
advertised. This is useful for making exceptions from a default policy
of advertising all prefixes. Note that for withdrawing an already
advertised prefix it is more useful to advertise it with zero valid
lifetime. Default: no
<P>
<DT><CODE>
<A NAME="radv-prefix-onlink"></A> onlink <I>switch</I></CODE><DD><P>This option specifies whether hosts may use the advertised prefix for
onlink determination. Default: yes
<P>
<DT><CODE>
<A NAME="radv-prefix-autonomous"></A> autonomous <I>switch</I></CODE><DD><P>This option specifies whether hosts may use the advertised prefix for
stateless autoconfiguration. Default: yes
<P>
<DT><CODE>
<A NAME="radv-prefix-valid-lifetime"></A> valid lifetime <I>expr</I> [sensitive <I>switch</I>]</CODE><DD><P>This option specifies the time (in seconds) how long (after the
receipt of RA) the prefix information is valid, i.e., autoconfigured
IP addresses can be assigned and hosts with that IP addresses are
considered directly reachable. 0 means the prefix is no longer
valid. For <CODE>sensitive</CODE> option, see 
<A HREF="#radv-trigger">trigger</A>.
Default: 86400 (1 day), <CODE>sensitive</CODE> no.
<P>
<DT><CODE>
<A NAME="radv-prefix-preferred-lifetime"></A> preferred lifetime <I>expr</I> [sensitive <I>switch</I>]</CODE><DD><P>This option specifies the time (in seconds) how long (after the
receipt of RA) IP addresses generated from the prefix using stateless
autoconfiguration remain preferred. For <CODE>sensitive</CODE> option,
see 
<A HREF="#radv-trigger">trigger</A>. Default: 14400 (4 hours),
<CODE>sensitive</CODE> no.
</DL>
<P>
<P>
<P>RDNSS specific options:
<P>
<DL>
<DT><CODE>
<A NAME="radv-rdnss-ns"></A> ns <I>address</I></CODE><DD><P>This option specifies one recursive DNS server. Can be used multiple
times for multiple servers. It is mandatory to have at least one
<CODE>ns</CODE> option in <CODE>rdnss</CODE> definition.
<P>
<DT><CODE>
<A NAME="radv-rdnss-lifetime"></A> lifetime [mult] <I>expr</I></CODE><DD><P>This option specifies the time how long the RDNSS information may be
used by clients after the receipt of RA. It is expressed either in
seconds or (when <CODE>mult</CODE> is used) in multiples of <CODE>max ra
interval</CODE>. Note that RDNSS information is also invalidated when
<CODE>default lifetime</CODE> expires. 0 means these addresses are no longer
valid DNS servers. Default: 3 * <CODE>max ra interval</CODE>.
</DL>
<P>
<P>
<P>DNSSL specific options:
<P>
<DL>
<DT><CODE>
<A NAME="radv-dnssl-domain"></A> domain <I>address</I></CODE><DD><P>This option specifies one DNS search domain. Can be used multiple times
for multiple domains. It is mandatory to have at least one <CODE>domain</CODE>
option in <CODE>dnssl</CODE> definition.
<P>
<DT><CODE>
<A NAME="radv-dnssl-lifetime"></A> lifetime [mult] <I>expr</I></CODE><DD><P>This option specifies the time how long the DNSSL information may be
used by clients after the receipt of RA. Details are the same as for
RDNSS <CODE>lifetime</CODE> option above. Default: 3 * <CODE>max ra interval</CODE>.
</DL>
<P>
<P>
<H3><A NAME="radv-exam"></A> Example</H3>

<P>
<HR>
<PRE>
protocol radv {
        interface "eth2" {
                max ra interval 5;      # Fast failover with more routers
                managed yes;            # Using DHCPv6 on eth2
                prefix ::/0 {
                        autonomous off; # So do not autoconfigure any IP
                };
        };

        interface "eth*";               # No need for any other options

        prefix 2001:0DB8:1234::/48 {
                preferred lifetime 0;   # Deprecated address range
        };

        prefix 2001:0DB8:2000::/48 {
                autonomous off;         # Do not autoconfigure
        };

        rdnss 2001:0DB8:1234::10;       # Short form of RDNSS

        rdnss {
                lifetime mult 10;
                ns 2001:0DB8:1234::11;
                ns 2001:0DB8:1234::12;
        };

        dnssl {
                lifetime 3600;
                domain "abc.com";
                domain "xyz.com";
        };
}
</PRE>
<HR>
<P>
<P>
<H2><A NAME="rip"></A> <A NAME="ss6.10">6.10</A> <A HREF="bird.html#toc6.10">RIP</A>
</H2>

<H3><A NAME="rip-intro"></A> Introduction</H3>

<P>The RIP protocol (also sometimes called Rest In Pieces) is a simple protocol,
where each router broadcasts (to all its neighbors) distances to all networks it
can reach. When a router hears distance to another network, it increments it and
broadcasts it back. Broadcasts are done in regular intervals. Therefore, if some
network goes unreachable, routers keep telling each other that its distance is
the original distance plus 1 (actually, plus interface metric, which is usually
one). After some time, the distance reaches infinity (that's 15 in RIP) and all
routers know that network is unreachable. RIP tries to minimize situations where
counting to infinity is necessary, because it is slow. Due to infinity being 16,
you can't use RIP on networks where maximal distance is higher than 15
hosts.
<P>
<P>BIRD supports RIPv1 (<A HREF="http://www.rfc-editor.org/info/rfc1058">RFC 1058</A>), RIPv2 (<A HREF="http://www.rfc-editor.org/info/rfc2453">RFC 2453</A>), RIPng (<A HREF="http://www.rfc-editor.org/info/rfc2080">RFC 2080</A>), and RIP cryptographic authentication (<A HREF="http://www.rfc-editor.org/info/rfc4822">RFC 4822</A>).
<P>
<P>RIP is a very simple protocol, and it has a lot of shortcomings. Slow
convergence, big network load and inability to handle larger networks makes it
pretty much obsolete. It is still usable on very small networks.
<P>
<H3><A NAME="rip-config"></A> Configuration</H3>

<P>RIP configuration consists mainly of common protocol options and interface
definitions, most RIP options are interface specific.
<P>
<HR>
<PRE>
protocol rip [&lt;name&gt;] {
        infinity &lt;number&gt;;
        ecmp &lt;switch&gt; [limit &lt;number&gt;];
        interface &lt;interface pattern&gt; {
                metric &lt;number&gt;;
                mode multicast|broadcast;
                passive &lt;switch&gt;;
                address &lt;ip&gt;;
                port &lt;number&gt;;
                version 1|2;
                split horizon &lt;switch&gt;;
                poison reverse &lt;switch&gt;;
                check zero &lt;switch&gt;;
                update time &lt;number&gt;;
                timeout time &lt;number&gt;;
                garbage time &lt;number&gt;;
                ecmp weight &lt;number&gt;;
                ttl security &lt;switch&gt;; | tx only;
                tx class|dscp &lt;number&gt;;
                tx priority &lt;number&gt;;
                rx buffer &lt;number&gt;;
                tx length &lt;number&gt;;
                check link &lt;switch&gt;;
                authentication none|plaintext|cryptographic;
                password "&lt;text&gt;";
                password "&lt;text&gt;" {
                        id &lt;num&gt;;
                        generate from "&lt;date&gt;";
                        generate to "&lt;date&gt;";
                        accept from "&lt;date&gt;";
                        accept to "&lt;date&gt;";
                        from "&lt;date&gt;";
                        to "&lt;date&gt;";
                        algorithm ( keyed md5 | keyed sha1 | hmac sha1 | hmac sha256 | hmac sha384 | hmac sha512 );
                };
        };
}
</PRE>
<HR>
<P>
<DL>
<DT><CODE>
<A NAME="rip-infinity"></A> infinity <I>number</I></CODE><DD><P>Selects the distance of infinity. Bigger values will make
protocol convergence even slower. The default value is 16.
<P>
<DT><CODE>
<A NAME="rip-ecmp"></A> ecmp <I>switch</I> [limit <I>number</I>]</CODE><DD><P>This option specifies whether RIP is allowed to generate ECMP
(equal-cost multipath) routes. Such routes are used when there are
several directions to the destination, each with the same (computed)
cost. This option also allows to specify a limit on maximum number of
nexthops in one route. By default, ECMP is disabled. If enabled,
default value of the limit is 16.
<P>
<DT><CODE>
<A NAME="rip-iface"></A> interface <I>pattern</I> [, <I>...</I>] { <I>options</I> }</CODE><DD><P>Interface definitions specify a set of interfaces on which the
protocol is activated and contain interface specific options.
See 
<A HREF="bird-3.html#proto-iface">interface</A> common options for
detailed description.
</DL>
<P>
<P>Interface specific options:
<P>
<DL>
<DT><CODE>
<A NAME="rip-iface-metric"></A> metric <I>num</I></CODE><DD><P>This option specifies the metric of the interface. When a route is
received from the interface, its metric is increased by this value
before further processing. Valid values are 1-255, but values higher
than infinity has no further meaning. Default: 1.
<P>
<DT><CODE>
<A NAME="rip-iface-mode"></A> mode multicast|broadcast</CODE><DD><P>This option selects the mode for RIP to use on the interface. The
default is multicast mode for RIPv2 and broadcast mode for RIPv1.
RIPng always uses the multicast mode.
<P>
<DT><CODE>
<A NAME="rip-iface-passive"></A> passive <I>switch</I></CODE><DD><P>Passive interfaces receive routing updates but do not transmit any
messages. Default: no.
<P>
<DT><CODE>
<A NAME="rip-iface-address"></A> address <I>ip</I></CODE><DD><P>This option specifies a destination address used for multicast or
broadcast messages, the default is the official RIP (224.0.0.9) or RIPng
(ff02::9) multicast address, or an appropriate broadcast address in the
broadcast mode.
<P>
<DT><CODE>
<A NAME="rip-iface-port"></A> port <I>number</I></CODE><DD><P>This option selects an UDP port to operate on, the default is the
official RIP (520) or RIPng (521) port.
<P>
<DT><CODE>
<A NAME="rip-iface-version"></A> version 1|2</CODE><DD><P>This option selects the version of RIP used on the interface. For RIPv1,
automatic subnet aggregation is not implemented, only classful network
routes and host routes are propagated. Note that BIRD allows RIPv1 to be
configured with features that are defined for RIPv2 only, like
authentication or using multicast sockets. The default is RIPv2 for IPv4
RIP, the option is not supported for RIPng, as no further versions are
defined.
<P>
<DT><CODE>
<A NAME="rip-iface-version-only"></A> version only <I>switch</I></CODE><DD><P>Regardless of RIP version configured for the interface, BIRD accepts
incoming packets of any RIP version. This option restrict accepted
packets to the configured version. Default: no.
<P>
<DT><CODE>
<A NAME="rip-iface-split-horizon"></A> split horizon <I>switch</I></CODE><DD><P>Split horizon is a scheme for preventing routing loops. When split
horizon is active, routes are not regularly propagated back to the
interface from which they were received. They are either not propagated
back at all (plain split horizon) or propagated back with an infinity
metric (split horizon with poisoned reverse). Therefore, other routers
on the interface will not consider the router as a part of an
independent path to the destination of the route. Default: yes.
<P>
<DT><CODE>
<A NAME="rip-iface-poison-reverse"></A> poison reverse <I>switch</I></CODE><DD><P>When split horizon is active, this option specifies whether the poisoned
reverse variant (propagating routes back with an infinity metric) is
used. The poisoned reverse has some advantages in faster convergence,
but uses more network traffic. Default: yes.
<P>
<DT><CODE>
<A NAME="rip-iface-check-zero"></A> check zero <I>switch</I></CODE><DD><P>Received RIPv1 packets with non-zero values in reserved fields should
be discarded. This option specifies whether the check is performed or
such packets are just processed as usual. Default: yes.
<P>
<DT><CODE>
<A NAME="rip-iface-update-time"></A> update time <I>number</I></CODE><DD><P>Specifies the number of seconds between periodic updates. A lower number
will mean faster convergence but bigger network load. Default: 30.
<P>
<DT><CODE>
<A NAME="rip-iface-timeout-time"></A> timeout time <I>number</I></CODE><DD><P>Specifies the time interval (in seconds) between the last received route
announcement and the route expiration. After that, the network is
considered unreachable, but still is propagated with infinity distance.
Default: 180.
<P>
<DT><CODE>
<A NAME="rip-iface-garbage-time"></A> garbage time <I>number</I></CODE><DD><P>Specifies the time interval (in seconds) between the route expiration
and the removal of the unreachable network entry. The garbage interval,
when a route with infinity metric is propagated, is used for both
internal (after expiration) and external (after withdrawal) routes.
Default: 120.
<P>
<DT><CODE>
<A NAME="rip-iface-ecmp-weight"></A> ecmp weight <I>number</I></CODE><DD><P>When ECMP (multipath) routes are allowed, this value specifies a
relative weight used for nexthops going through the iface. Valid
values are 1-256. Default value is 1.
<P>
<DT><CODE>
<A NAME="rip-iface-auth"></A> authentication none|plaintext|cryptographic</CODE><DD><P>Selects authentication method to be used. <CODE>none</CODE> means that packets
are not authenticated at all, <CODE>plaintext</CODE> means that a plaintext
password is embedded into each packet, and <CODE>cryptographic</CODE> means that
packets are authenticated using some cryptographic hash function
selected by option <CODE>algorithm</CODE> for each key. The default
cryptographic algorithm for RIP keys is Keyed-MD5. If you set
authentication to not-none, it is a good idea to add <CODE>password</CODE>
section. Default: none.
<P>
<DT><CODE>
<A NAME="rip-iface-pass"></A> password "<I>text</I>"</CODE><DD><P>Specifies a password used for authentication. See 
<A HREF="bird-3.html#proto-pass">password</A> common option for detailed description.
<P>
<DT><CODE>
<A NAME="rip-iface-ttl-security"></A> ttl security [<I>switch</I> | tx only]</CODE><DD><P>TTL security is a feature that protects routing protocols from remote
spoofed packets by using TTL 255 instead of TTL 1 for protocol packets
destined to neighbors. Because TTL is decremented when packets are
forwarded, it is non-trivial to spoof packets with TTL 255 from remote
locations.
<P>If this option is enabled, the router will send RIP packets with TTL 255
and drop received packets with TTL less than 255. If this option si set
to <CODE>tx only</CODE>, TTL 255 is used for sent packets, but is not checked
for received packets. Such setting does not offer protection, but offers
compatibility with neighbors regardless of whether they use ttl
security.
<P>For RIPng, TTL security is a standard behavior (required by <A HREF="http://www.rfc-editor.org/info/rfc2080">RFC 2080</A>) and therefore default value is yes. For IPv4 RIP, default
value is no.
<P>
<DT><CODE>
<A NAME="rip-iface-tx-class"></A> tx class|dscp|priority <I>number</I></CODE><DD><P>These options specify the ToS/DiffServ/Traffic class/Priority of the
outgoing RIP packets. See 
<A HREF="bird-3.html#proto-tx-class">tx class</A> common
option for detailed description.
<P>
<DT><CODE>
<A NAME="rip-iface-rx-buffer"></A> rx buffer <I>number</I></CODE><DD><P>This option specifies the size of buffers used for packet processing.
The buffer size should be bigger than maximal size of received packets.
The default value is 532 for IPv4 RIP and interface MTU value for RIPng.
<P>
<DT><CODE>
<A NAME="rip-iface-tx-length"></A> tx length <I>number</I></CODE><DD><P>This option specifies the maximum length of generated RIP packets. To
avoid IP fragmentation, it should not exceed the interface MTU value.
The default value is 532 for IPv4 RIP and interface MTU value for RIPng.
<P>
<DT><CODE>
<A NAME="rip-iface-check-link"></A> check link <I>switch</I></CODE><DD><P>If set, the hardware link state (as reported by OS) is taken into
consideration. When the link disappears (e.g. an ethernet cable is
unplugged), neighbors are immediately considered unreachable and all
routes received from them are withdrawn. It is possible that some
hardware drivers or platforms do not implement this feature.
Default: no.
</DL>
<P>
<H3><A NAME="rip-attr"></A> Attributes</H3>

<P>RIP defines two route attributes:
<P>
<DL>
<DT><CODE>
<A NAME="rta-rip-metric"></A> int rip_metric/</CODE><DD><P>RIP metric of the route (ranging from 0 to <CODE>infinity</CODE>).  When routes
from different RIP instances are available and all of them have the same
preference, BIRD prefers the route with lowest <CODE>rip_metric</CODE>. When a
non-RIP route is exported to RIP, the default metric is 1.
<P>
<DT><CODE>
<A NAME="rta-rip-tag"></A> int rip_tag/</CODE><DD><P>RIP route tag: a 16-bit number which can be used to carry additional
information with the route (for example, an originating AS number in
case of external routes). When a non-RIP route is exported to RIP, the
default tag is 0.
</DL>
<P>
<H3><A NAME="rip-exam"></A> Example</H3>

<P>
<HR>
<PRE>
protocol rip {
        debug all;
        port 1520;
        period 12;
        garbage time 60;
        interface "eth0" { metric 3; mode multicast; };
        interface "eth*" { metric 2; mode broadcast; };
        authentication cryptographic;
        password "secret-shared-key" { algorithm hmac sha256; };
        import filter { print "importing"; accept; };
        export filter { print "exporting"; accept; };
}
</PRE>
<HR>
<P>
<P>
<H2><A NAME="static"></A> <A NAME="ss6.11">6.11</A> <A HREF="bird.html#toc6.11">Static</A>
</H2>

<P>The Static protocol doesn't communicate with other routers in the network,
but instead it allows you to define routes manually. This is often used for
specifying how to forward packets to parts of the network which don't use
dynamic routing at all and also for defining sink routes (i.e., those telling to
return packets as undeliverable if they are in your IP block, you don't have any
specific destination for them and you don't want to send them out through the
default route to prevent routing loops).
<P>
<P>There are five types of static routes: `classical' routes telling to forward
packets to a neighboring router, multipath routes specifying several (possibly
weighted) neighboring routers, device routes specifying forwarding to hosts on a
directly connected network, recursive routes computing their nexthops by doing
route table lookups for a given IP, and special routes (sink, blackhole etc.)
which specify a special action to be done instead of forwarding the packet.
<P>
<P>When the particular destination is not available (the interface is down or
the next hop of the route is not a neighbor at the moment), Static just
uninstalls the route from the table it is connected to and adds it again as soon
as the destination becomes adjacent again.
<P>
<P>There are three classes of definitions in Static protocol configuration --
global options, static route definitions, and per-route options. Usually, the
definition of the protocol contains mainly a list of static routes.
<P>
<P>Global options:
<P>
<DL>
<DT><CODE>
<A NAME="static-check-link"></A> check link <I>switch</I></CODE><DD><P>If set, hardware link states of network interfaces are taken into
consideration.  When link disappears (e.g. ethernet cable is unplugged),
static routes directing to that interface are removed. It is possible
that some hardware drivers or platforms do not implement this feature.
Default: off.
<P>
<DT><CODE>
<A NAME="static-igp-table"></A> igp table <I>name</I></CODE><DD><P>Specifies a table that is used for route table lookups of recursive
routes. Default: the same table as the protocol is connected to.
</DL>
<P>
<P>Route definitions (each may also contain a block of per-route options):
<P>
<DL>
<DT><CODE>
<A NAME="static-route-via-ip"></A> route <I>prefix</I> via <I>ip</I></CODE><DD><P>Static route through a neighboring router. For link-local next hops,
interface can be specified as a part of the address (e.g.,
<CODE>via fe80::1234%eth0</CODE>).
<P>
<DT><CODE>
<A NAME="static-route-via-mpath"></A> route <I>prefix</I> multipath via <I>ip</I> [weight <I>num</I>] [bfd <I>switch</I>] [via <I>...</I>]</CODE><DD><P>Static multipath route. Contains several nexthops (gateways), possibly
with their weights.
<P>
<DT><CODE>
<A NAME="static-route-via-iface"></A> route <I>prefix</I> via <I>"interface"</I></CODE><DD><P>Static device route through an interface to hosts on a directly
connected network.
<P>
<DT><CODE>
<A NAME="static-route-recursive"></A> route <I>prefix</I> recursive <I>ip</I></CODE><DD><P>Static recursive route, its nexthop depends on a route table lookup for
given IP address.
<P>
<DT><CODE>
<A NAME="static-route-drop"></A> route <I>prefix</I> blackhole|unreachable|prohibit</CODE><DD><P>Special routes specifying to silently drop the packet, return it as
unreachable or return it as administratively prohibited. First two
targets are also known as <CODE>drop</CODE> and <CODE>reject</CODE>.
</DL>
<P>
<P>Per-route options:
<P>
<DL>
<DT><CODE>
<A NAME="static-route-bfd"></A> bfd <I>switch</I></CODE><DD><P>The Static protocol could use BFD protocol for next hop liveness
detection. If enabled, a BFD session to the route next hop is created
and the static route is BFD-controlled -- the static route is announced
only if the next hop liveness is confirmed by BFD. If the BFD session
fails, the static route is removed. Note that this is a bit different
compared to other protocols, which may use BFD as an advisory mechanism
for fast failure detection but ignores it if a BFD session is not even
established.
<P>This option can be used for static routes with a direct next hop, or
also for for individual next hops in a static multipath route (see
above). Note that BFD protocol also has to be configured, see
<A HREF="#bfd">BFD</A> section for details. Default value is no.
<P>
<DT><CODE>
<A NAME="static-route-filter"></A> <I>filter expression</I></CODE><DD><P>This is a special option that allows filter expressions to be configured
on per-route basis. Can be used multiple times. These expressions are
evaluated when the route is originated, similarly to the import filter
of the static protocol. This is especially useful for configuring route
attributes, e.g., <CODE>ospf_metric1 = 100;</CODE> for a route that will be
exported to the OSPF protocol.
</DL>
<P>
<P>Static routes have no specific attributes.
<P>
<P>Example static config might look like this:
<P>
<P>
<HR>
<PRE>
protocol static {
        table testable;                 # Connect to a non-default routing table
        check link;                     # Advertise routes only if link is up
        route 0.0.0.0/0 via 198.51.100.130; # Default route
        route 10.0.0.0/8 multipath      # Multipath route
                via 198.51.100.10 weight 2
                via 198.51.100.20 bfd   # BFD-controlled next hop
                via 192.0.2.1;
        route 203.0.113.0/24 unreachable; # Sink route
        route 10.2.0.0/24 via "arc0";   # Secondary network
        route 192.168.10.0/24 via 198.51.100.100 {
                ospf_metric1 = 20;      # Set extended attribute
        }
        route 192.168.10.0/24 via 198.51.100.100 {
                ospf_metric2 = 100;     # Set extended attribute
                ospf_tag = 2;           # Set extended attribute
                bfd;                    # BFD-controlled route
        }
}
</PRE>
<HR>
<P>
<P>
<HR>
<A HREF="bird-7.html">Next</A>
<A HREF="bird-5.html">Previous</A>
<A HREF="bird.html#toc6">Contents</A>
</BODY>
</HTML>
